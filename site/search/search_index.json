{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"git-autosquash","text":"<p>Automatically squash changes back into historical commits where they belong.</p> <p>git-autosquash is a powerful tool that analyzes your working directory changes and automatically distributes them back to the commits where those code sections were last modified. It uses git blame analysis and provides an interactive approval workflow to ensure safe, precise commit history management.</p> <p>Project Status</p> <p>git-autosquash is actively developed and functional. All core features are implemented: git analysis, blame-based targeting, interactive TUI, and rebase execution. The tool is ready for daily use with comprehensive testing and error handling.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83c\udfaf Smart Targeting: Uses git blame to find the exact commits where code was last modified</li> <li>\ud83d\udda5\ufe0f Interactive TUI: Rich terminal interface with syntax-highlighted diff viewer  </li> <li>\ud83d\udd12 Safety First: Default unapproved state with user confirmation for all changes</li> <li>\u26a1 Conflict Resolution: Clear guidance when merge conflicts occur during rebase</li> <li>\ud83d\udcca Progress Tracking: Real-time feedback with detailed commit summaries</li> <li>\ud83d\udd04 Rollback Support: Automatic cleanup and restoration on errors or interruption</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#installation","title":"Installation","text":"pipx (Recommended)pipuv <pre><code>pipx install git-autosquash\n</code></pre> <pre><code>pip install git-autosquash\n</code></pre> <pre><code>uv tool install git-autosquash\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<ol> <li>Make changes to your codebase</li> <li>Run git-autosquash to analyze and distribute changes:</li> </ol> <pre><code>git-autosquash\n</code></pre> <ol> <li>Review the proposed hunk \u2192 commit mappings in the interactive TUI</li> <li>Approve changes you want to squash back into their target commits</li> <li>Let git-autosquash perform the interactive rebase automatically</li> </ol>"},{"location":"#how-it-works","title":"\ud83c\udfac How It Works","text":"<pre><code>graph TD\n    A[Working Directory Changes] --&gt; B[Parse Git Diff into Hunks]\n    B --&gt; C[Run Git Blame Analysis]\n    C --&gt; D[Find Target Commits for Each Hunk]\n    D --&gt; E[Interactive TUI Approval]\n    E --&gt; F[Group Hunks by Target Commit]\n    F --&gt; G[Execute Interactive Rebase]\n    G --&gt; H[Distribute Changes to History]\n\n    E -.-&gt; I[Cancel/Abort]\n    G -.-&gt; J[Conflict Resolution]\n    J -.-&gt; K[User Fixes Conflicts]\n    K --&gt; G</code></pre>"},{"location":"#example-workflow","title":"\ud83d\udccb Example Workflow","text":"<p>Imagine you've been working on a feature and made several changes across different files. Some of these changes are bug fixes that should go back to earlier commits, while others are new feature additions.</p> <p>Typical Scenario</p> <pre><code>$ git status\nOn branch feature/user-auth\nChanges not staged for commit:\n  modified:   src/auth/login.py      # Bug fix for validation\n  modified:   src/auth/session.py    # Performance improvement  \n  modified:   src/ui/dashboard.py    # New feature code\n\n$ git-autosquash\nCurrent branch: feature/user-auth\nMerge base: abc123def\n\nAnalyzing changes and finding target commits...\nFound 3 hunks to process\nFound target commits for 3 hunks\n\nLaunching interactive approval interface...\n</code></pre> <p>The TUI will show you exactly which changes can go back to which commits, with confidence levels and clear diff visualization.</p>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":"<ul> <li>Bug fixes: Automatically squash fixes back to the commits that introduced bugs</li> <li>Refactoring: Distribute code improvements back to their logical commits  </li> <li>Code cleanup: Move formatting and style changes to appropriate historical points</li> <li>Feature development: Separate bug fixes from new features during development</li> <li>Commit message fixes: Clean up commit history by moving changes to better locations</li> </ul>"},{"location":"#safety-features","title":"\ud83d\udee1\ufe0f Safety Features","text":"<p>git-autosquash is designed with safety as the top priority:</p> <ul> <li>Default rejection: All changes start as unapproved, requiring explicit user consent</li> <li>Conflict detection: Clear guidance when rebase conflicts occur</li> <li>Automatic rollback: Repository restored to original state on errors or interruption  </li> <li>Branch validation: Only works on feature branches with clear merge-base</li> <li>Stash management: Safely handles mixed staged/unstaged states</li> <li>Comprehensive testing: 121+ tests covering all edge cases and failure modes</li> </ul>"},{"location":"#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Installation Guide - Detailed setup instructions</li> <li>Getting Started - Your first git-autosquash workflow</li> <li>Basic Workflow - Common usage patterns</li> <li>Advanced Usage - Power user features</li> <li>Examples - Real-world scenarios and solutions</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>git-autosquash is open source and welcomes contributions! Check out our:</p> <ul> <li>Development Guide - Set up development environment</li> <li>Architecture Overview - Understand the codebase</li> <li>Testing Guide - Run and write tests</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"installation/","title":"Installation","text":"<p>git-autosquash is distributed as a Python package and can be installed using several methods. Choose the one that best fits your workflow.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or higher</li> <li>Git 2.20 or higher </li> <li>A terminal that supports ANSI colors (most modern terminals)</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#pipx-recommended","title":"pipx (Recommended)","text":"<p>pipx is the recommended way to install Python CLI tools. It creates isolated environments for each tool, avoiding dependency conflicts.</p> <pre><code>pipx install git-autosquash\n</code></pre> <p>Why pipx?</p> <ul> <li>Installs tools in isolated environments</li> <li>Automatically adds executables to your PATH</li> <li>Easy to upgrade and uninstall</li> <li>No conflicts with other Python packages</li> </ul>"},{"location":"installation/#pip","title":"pip","text":"<p>If you prefer using pip directly:</p> <pre><code>pip install git-autosquash\n</code></pre> <p>Virtual Environment Recommended</p> <p>If using pip, consider installing in a virtual environment to avoid conflicts: <pre><code>python -m venv git-autosquash-env\nsource git-autosquash-env/bin/activate  # On Windows: git-autosquash-env\\Scripts\\activate\npip install git-autosquash\n</code></pre></p>"},{"location":"installation/#uv","title":"uv","text":"<p>uv is a fast Python package manager with tool installation support:</p> <pre><code>uv tool install git-autosquash\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<p>For development or latest features:</p> Using uv (Recommended for Development)Using pip <pre><code>git clone https://github.com/andrewleech/git-autosquash.git\ncd git-autosquash\nuv sync --dev\nuv run git-autosquash --help\n</code></pre> <pre><code>git clone https://github.com/andrewleech/git-autosquash.git\ncd git-autosquash\npip install -e .\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify your installation by running:</p> <pre><code>git-autosquash --version\n</code></pre> <p>You should see output similar to: <pre><code>git-autosquash 1.0.0\n</code></pre></p> <p>Test the help system: <pre><code>git-autosquash --help\n</code></pre></p>"},{"location":"installation/#git-integration","title":"Git Integration","text":""},{"location":"installation/#as-a-git-subcommand","title":"As a Git Subcommand","text":"<p>You can make git-autosquash available as a git subcommand by ensuring it's in your PATH (which the installation methods above handle automatically). Then you can use:</p> <pre><code>git autosquash\n</code></pre> <p>instead of:</p> <pre><code>git-autosquash\n</code></pre>"},{"location":"installation/#shell-completion","title":"Shell Completion","text":"BashZshFish <p>Add to your <code>~/.bashrc</code>: <pre><code>eval \"$(register-python-argcomplete git-autosquash)\"\n</code></pre></p> <p>Add to your <code>~/.zshrc</code>: <pre><code>eval \"$(register-python-argcomplete git-autosquash)\"\n</code></pre></p> <pre><code>register-python-argcomplete --shell fish git-autosquash &gt; ~/.config/fish/completions/git-autosquash.fish\n</code></pre> <p>argcomplete Required</p> <p>Shell completion requires the <code>argcomplete</code> package: <pre><code>pipx inject git-autosquash argcomplete\n# or\npip install argcomplete\n</code></pre></p>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>git-autosquash automatically installs these dependencies:</p> <ul> <li>Textual - Rich terminal user interface framework</li> <li>Rich - Rich text and beautiful formatting in the terminal</li> </ul>"},{"location":"installation/#system-specific-notes","title":"System-Specific Notes","text":""},{"location":"installation/#macos","title":"macOS","text":"<p>On macOS, you might need to install a more recent version of Git if using the system default:</p> <pre><code># Using Homebrew\nbrew install git\n\n# Or using MacPorts  \nsudo port install git\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<p>git-autosquash works on Windows with:</p> <ul> <li>Git for Windows (includes Git Bash)</li> <li>Windows Terminal (recommended for best experience)</li> <li>WSL (Windows Subsystem for Linux)</li> </ul>"},{"location":"installation/#linux","title":"Linux","text":"<p>Most modern Linux distributions include compatible versions of Git and Python. If needed:</p> Ubuntu/DebianCentOS/RHEL/FedoraArch Linux <pre><code>sudo apt update\nsudo apt install git python3 python3-pip\n</code></pre> <pre><code>sudo dnf install git python3 python3-pip\n</code></pre> <pre><code>sudo pacman -S git python python-pip\n</code></pre>"},{"location":"installation/#upgrading","title":"Upgrading","text":""},{"location":"installation/#pipx","title":"pipx","text":"<pre><code>pipx upgrade git-autosquash\n</code></pre>"},{"location":"installation/#pip_1","title":"pip","text":"<pre><code>pip install --upgrade git-autosquash\n</code></pre>"},{"location":"installation/#uv_1","title":"uv","text":"<pre><code>uv tool upgrade git-autosquash\n</code></pre>"},{"location":"installation/#uninstallation","title":"Uninstallation","text":""},{"location":"installation/#pipx_1","title":"pipx","text":"<pre><code>pipx uninstall git-autosquash\n</code></pre>"},{"location":"installation/#pip_2","title":"pip","text":"<pre><code>pip uninstall git-autosquash\n</code></pre>"},{"location":"installation/#uv_2","title":"uv","text":"<pre><code>uv tool uninstall git-autosquash\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#command-not-found","title":"Command Not Found","text":"<p>If you get \"command not found\" after installation:</p> <ol> <li>Check your PATH: The installation location should be in your PATH</li> <li>Restart your terminal: Changes to PATH may require a new terminal session</li> <li>Verify installation: Run <code>pip list | grep git-autosquash</code> to confirm it's installed</li> </ol>"},{"location":"installation/#permission-errors","title":"Permission Errors","text":"<p>If you encounter permission errors:</p> <ol> <li>Use pipx instead of pip: pipx handles permissions automatically</li> <li>Use virtual environments: Avoid system-wide pip installations</li> <li>Check directory permissions: Ensure you can write to the installation directory</li> </ol>"},{"location":"installation/#import-errors","title":"Import Errors","text":"<p>If you see import errors about missing modules:</p> <ol> <li>Check Python version: Ensure you're using Python 3.12 or higher</li> <li>Verify installation: Reinstall with <code>pip install --force-reinstall git-autosquash</code></li> <li>Check dependencies: All dependencies should install automatically</li> </ol> <p>For more troubleshooting help, see our Troubleshooting Guide.</p>"},{"location":"examples/basic-scenarios/","title":"Basic Scenarios","text":"<p>This guide walks through common real-world scenarios where git-autosquash provides immediate value.</p>"},{"location":"examples/basic-scenarios/#scenario-1-bug-fix-during-feature-development","title":"Scenario 1: Bug Fix During Feature Development","text":"<p>Situation: You're implementing user authentication and discover a validation bug in existing login code.</p>"},{"location":"examples/basic-scenarios/#initial-state","title":"Initial State","text":"<pre><code>$ git log --oneline -5\nabc1234 Add OAuth integration framework\ndef5678 Implement user dashboard \n789abcd Fix login validation logic\n012cdef Add initial user model\n345ef01 Initial project setup\n</code></pre>"},{"location":"examples/basic-scenarios/#your-changes","title":"Your Changes","text":"<pre><code>$ git status\nOn branch feature/oauth-integration\nChanges not staged for commit:\n  modified:   src/auth/oauth.py        # New OAuth implementation\n  modified:   src/auth/login.py        # Fix validation bug discovered\n  modified:   src/ui/login_form.py     # Update form for OAuth\n</code></pre>"},{"location":"examples/basic-scenarios/#running-git-autosquash","title":"Running git-autosquash","text":"<pre><code>$ git-autosquash\n</code></pre> <p>TUI Output: <pre><code>\u250c\u2500 Hunk Mappings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u25cf src/auth/oauth.py:15-30 \u2192 No target (new feature)            \u2502\n\u2502 \u25cf src/auth/login.py:45-47 \u2192 789abcd Fix login validation logic  \u2502 HIGH\n\u2502 \u25cf src/ui/login_form.py:12 \u2192 def5678 Implement user dashboard    \u2502 MED \n\u2502 \u25cf src/ui/login_form.py:20-25 \u2192 No target (new feature)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"examples/basic-scenarios/#result-after-approval","title":"Result After Approval","text":"<ul> <li>OAuth implementation \u2192 Stays as new changes</li> <li>Validation bug fix \u2192 Squashed into commit <code>789abcd</code> </li> <li>Form OAuth changes \u2192 Stays as new changes</li> <li>Form improvement \u2192 Squashed into commit <code>def5678</code></li> </ul> <p>Final commit history: <pre><code>$ git log --oneline -5  \nabc1234 Add OAuth integration framework (updated)\ndef5678 Implement user dashboard (updated with form fix)\n789abcd Fix login validation logic (updated with additional fix)\n012cdef Add initial user model\n345ef01 Initial project setup\n</code></pre></p>"},{"location":"examples/basic-scenarios/#scenario-2-code-review-feedback","title":"Scenario 2: Code Review Feedback","text":"<p>Situation: You receive code review feedback asking for changes across multiple historical commits.</p>"},{"location":"examples/basic-scenarios/#review-comments","title":"Review Comments","text":"<ol> <li>\"Fix error handling in user registration\" (affects commit <code>abc1234</code>)</li> <li>\"Update API documentation for login endpoint\" (affects commit <code>def5678</code>)</li> <li>\"Add input validation to dashboard form\" (affects commit <code>789abcd</code>)</li> <li>\"Fix typo in README\" (affects commit <code>012cdef</code>)</li> </ol>"},{"location":"examples/basic-scenarios/#your-fixes","title":"Your Fixes","text":"<pre><code>$ git status\nChanges not staged for commit:\n  modified:   src/auth/registration.py  # Error handling improvement\n  modified:   docs/api/login.md         # Documentation update\n  modified:   src/ui/dashboard.py       # Input validation\n  modified:   README.md                 # Typo fix\n</code></pre>"},{"location":"examples/basic-scenarios/#git-autosquash-results","title":"git-autosquash Results","text":"<pre><code>$ git-autosquash\n</code></pre> <p>Each fix goes back to its original commit: - Registration fix \u2192 <code>abc1234</code>  - API docs \u2192 <code>def5678</code> - Dashboard validation \u2192 <code>789abcd</code> - README typo \u2192 <code>012cdef</code></p> <p>Benefit: Clean, logical history where each commit remains focused and complete.</p>"},{"location":"examples/basic-scenarios/#scenario-3-refactoring-session","title":"Scenario 3: Refactoring Session","text":"<p>Situation: After a refactoring session, you have improvements scattered across many files.</p>"},{"location":"examples/basic-scenarios/#changes-made","title":"Changes Made","text":"<pre><code>$ git diff --stat\nsrc/auth/login.py          | 5 ++---     # Performance improvement\nsrc/auth/registration.py   | 3 +--      # Code style cleanup  \nsrc/ui/dashboard.py        | 8 ++++----   # Error handling improvement\nsrc/utils/validation.py    | 12 ++++++------  # Algorithm optimization\nsrc/database/models.py     | 6 +++---    # Type annotation fixes\ntests/test_auth.py         | 4 ++--    # Test improvements\n</code></pre>"},{"location":"examples/basic-scenarios/#git-autosquash-analysis","title":"git-autosquash Analysis","text":"<pre><code>$ git-autosquash --line-by-line  # More precision for refactoring\n</code></pre> <p>Results: - Login performance \u2192 Back to original login implementation commit - Registration cleanup \u2192 Back to registration commit - Dashboard error handling \u2192 Back to dashboard commit - Validation optimization \u2192 Back to validation utility commit - Model annotations \u2192 Back to model definition commit - Test improvements \u2192 Back to corresponding test commits</p> <p>Outcome: Each original commit now includes its improvements, maintaining focused history.</p>"},{"location":"examples/basic-scenarios/#scenario-4-mixed-development-session","title":"Scenario 4: Mixed Development Session","text":"<p>Situation: During one coding session, you both add new features and fix existing bugs.</p>"},{"location":"examples/basic-scenarios/#session-work","title":"Session Work","text":"<ol> <li>New feature: Add password reset functionality</li> <li>Bug fix: Fix email validation in existing signup</li> <li>New feature: Add user profile editing</li> <li>Bug fix: Fix error handling in existing login</li> <li>Improvement: Optimize existing database queries</li> </ol>"},{"location":"examples/basic-scenarios/#files-changed","title":"Files Changed","text":"<pre><code>$ git status --porcelain\nM  src/auth/password_reset.py    # New feature\nM  src/auth/signup.py            # Bug fix in existing code\nM  src/ui/profile_editor.py      # New feature  \nM  src/auth/login.py             # Bug fix in existing code\nM  src/database/queries.py       # Optimization of existing code\n</code></pre>"},{"location":"examples/basic-scenarios/#git-autosquash-organization","title":"git-autosquash Organization","text":"<pre><code>$ git-autosquash\n</code></pre> <p>Intelligent separation: - Password reset \u2192 Stays as new feature commit - Email validation fix \u2192 Goes to original signup commit - Profile editor \u2192 Stays as new feature commit - Login error handling \u2192 Goes to original login commit - Database optimization \u2192 Goes to original database commit</p>"},{"location":"examples/basic-scenarios/#final-result","title":"Final Result","text":"<pre><code># New commits for features\ngit commit -m \"Add password reset functionality\" \ngit commit -m \"Add user profile editing interface\"\n\n# Historical commits updated with fixes/improvements\n# - Signup commit now includes email validation fix\n# - Login commit now includes better error handling  \n# - Database commit now includes query optimizations\n</code></pre>"},{"location":"examples/basic-scenarios/#scenario-5-large-feature-branch-cleanup","title":"Scenario 5: Large Feature Branch Cleanup","text":"<p>Situation: Before merging a large feature branch, clean up the commit history.</p>"},{"location":"examples/basic-scenarios/#branch-state","title":"Branch State","text":"<pre><code>$ git log --oneline origin/main..HEAD\na1b2c3d Add user preferences UI\n4e5f6g7 Fix bug in preferences saving  \n8h9i0j1 Add user avatar upload\n2k3l4m5 Fix avatar validation\n6n7o8p9 Update user profile display\n0q1r2s3 Fix profile loading performance\n</code></pre> <p>Problem: Bug fixes are separate commits, making history noisy.</p>"},{"location":"examples/basic-scenarios/#cleanup-with-git-autosquash","title":"Cleanup with git-autosquash","text":"<pre><code># Make additional tweaks and improvements\nvim src/ui/preferences.py    # Minor improvement\nvim src/ui/avatar.py         # Style cleanup\nvim src/ui/profile.py        # Performance tweak\n\n$ git-autosquash\n</code></pre> <p>Result: Bug fixes and improvements get squashed back into their logical commits: - Preferences fix \u2192 Into <code>a1b2c3d</code> - Avatar validation \u2192 Into <code>8h9i0j1</code>  - Profile performance \u2192 Into <code>6n7o8p9</code> - Plus your new improvements distributed appropriately</p>"},{"location":"examples/basic-scenarios/#clean-final-history","title":"Clean Final History","text":"<pre><code>$ git log --oneline origin/main..HEAD\na1b2c3d Add user preferences UI (with fixes and improvements)\n8h9i0j1 Add user avatar upload (with validation fixes) \n6n7o8p9 Update user profile display (with performance improvements)\n</code></pre>"},{"location":"examples/basic-scenarios/#scenario-6-hotfix-distribution","title":"Scenario 6: Hotfix Distribution","text":"<p>Situation: You need to apply the same fix to multiple points in history.</p>"},{"location":"examples/basic-scenarios/#problem-discovery","title":"Problem Discovery","text":"<p>Security vulnerability found in authentication code that appears in multiple commits.</p>"},{"location":"examples/basic-scenarios/#your-fix","title":"Your Fix","text":"<pre><code># Apply comprehensive fix\nvim src/auth/security.py\nvim src/auth/validation.py  \nvim src/utils/crypto.py\n\n$ git status\nChanges not staged for commit:\n  modified:   src/auth/security.py\n  modified:   src/auth/validation.py  \n  modified:   src/utils/crypto.py\n</code></pre>"},{"location":"examples/basic-scenarios/#git-autosquash-distribution","title":"git-autosquash Distribution","text":"<pre><code>$ git-autosquash --line-by-line  # Precision for security fixes\n</code></pre> <p>Result: Security improvements distributed to multiple historical commits where each component was introduced: - Security module fixes \u2192 Original security implementation - Validation fixes \u2192 Original validation implementation - Crypto fixes \u2192 Original crypto implementation</p> <p>Benefit: Security fix is applied comprehensively across all related commits in branch history.</p>"},{"location":"examples/basic-scenarios/#scenario-7-documentation-and-code-sync","title":"Scenario 7: Documentation and Code Sync","text":"<p>Situation: Update documentation to match recent code changes across multiple commits.</p>"},{"location":"examples/basic-scenarios/#changes-needed","title":"Changes Needed","text":"<pre><code>$ git diff --name-only\ndocs/api/auth.md           # Update for auth changes\ndocs/api/user.md           # Update for user model changes\ndocs/deployment.md         # Update for deployment changes\nsrc/auth/models.py         # Minor code improvement  \nsrc/deployment/config.py   # Configuration update\n</code></pre>"},{"location":"examples/basic-scenarios/#git-autosquash-organization_1","title":"git-autosquash Organization","text":"<pre><code>$ git-autosquash\n</code></pre> <p>Result: - API docs \u2192 Back to commits that introduced those APIs - Deployment docs \u2192 Back to deployment implementation commit - Code improvements \u2192 Back to original implementation commits</p> <p>Outcome: Each commit now has both its implementation AND corresponding documentation, maintaining completeness.</p>"},{"location":"examples/basic-scenarios/#key-patterns","title":"Key Patterns","text":""},{"location":"examples/basic-scenarios/#when-git-autosquash-helps-most","title":"When git-autosquash Helps Most","text":"<ol> <li>Bug fixes during feature work - Keeps bug fixes with original implementation</li> <li>Code review responses - Distributes feedback fixes to logical commits</li> <li>Refactoring improvements - Puts optimizations with original implementations  </li> <li>Documentation updates - Keeps docs synchronized with code changes</li> <li>Branch cleanup - Organizes messy development history before merging</li> </ol>"},{"location":"examples/basic-scenarios/#when-to-use-standard-mode-vs-line-by-line","title":"When to Use Standard Mode vs Line-by-Line","text":"<p>Standard Mode (<code>git-autosquash</code>): - Feature development with occasional bug fixes - General code organization - Performance (faster analysis)</p> <p>Line-by-Line Mode (<code>git-autosquash --line-by-line</code>): - Refactoring sessions with mixed changes - Security fixes requiring precision - Code review responses to specific lines - Complex scenarios with unrelated changes</p>"},{"location":"examples/basic-scenarios/#success-indicators","title":"Success Indicators","text":"<p>After git-autosquash, you should see: - \u2705 Bug fixes integrated into original implementations - \u2705 Feature additions remain as new commits - \u2705 Related changes grouped logically - \u2705 Cleaner, more maintainable git history - \u2705 Each commit tells a complete story</p> <p>For more complex scenarios, see Complex Workflows.</p>"},{"location":"examples/complex-workflows/","title":"Complex Workflows","text":"<p>This guide covers challenging scenarios that require advanced git-autosquash techniques and careful planning.</p>"},{"location":"examples/complex-workflows/#complex-scenario-1-multi-team-feature-integration","title":"Complex Scenario 1: Multi-Team Feature Integration","text":"<p>Situation: Large feature spanning multiple teams, with cross-cutting concerns and shared components.</p>"},{"location":"examples/complex-workflows/#team-structure","title":"Team Structure","text":"<ul> <li>Team A: Authentication &amp; Security</li> <li>Team B: UI &amp; Frontend  </li> <li>Team C: Backend API</li> <li>Team D: Database &amp; Infrastructure</li> </ul>"},{"location":"examples/complex-workflows/#development-timeline","title":"Development Timeline","text":"<pre><code>gitGraph\n    commit id: \"Initial setup\"\n    branch feature/user-management\n    commit id: \"Add user model (Team D)\"\n    commit id: \"Add auth API (Team C)\"\n    commit id: \"Add login UI (Team B)\"\n    commit id: \"Add security layer (Team A)\"\n    commit id: \"Fix user model validation (Team D)\"\n    commit id: \"Fix API error handling (Team C)\"\n    commit id: \"Fix UI accessibility (Team B)\"\n    commit id: \"Fix security vulnerability (Team A)\"</code></pre>"},{"location":"examples/complex-workflows/#cross-team-changes","title":"Cross-Team Changes","text":"<p>After integration testing, multiple teams need to make fixes:</p> <pre><code>$ git status --porcelain\nM  src/database/user_model.py      # Team D: Validation improvements\nM  src/api/auth_endpoints.py       # Team C: Error handling fixes\nM  src/ui/login_components.py      # Team B: Accessibility improvements  \nM  src/security/auth_middleware.py # Team A: Security enhancements\nM  src/shared/validation.py        # Multiple teams: Shared utility fixes\nM  tests/integration/test_auth.py  # All teams: Integration test updates\n</code></pre>"},{"location":"examples/complex-workflows/#coordinated-git-autosquash","title":"Coordinated git-autosquash","text":"<pre><code># Each team's changes go back to their original implementations\n$ git-autosquash --line-by-line\n\n# Results:\n# - Database fixes \u2192 Original user model commit\n# - API fixes \u2192 Original auth API commit\n# - UI fixes \u2192 Original login UI commit  \n# - Security fixes \u2192 Original security layer commit\n# - Shared utility fixes \u2192 Most frequent contributor's commit\n# - Integration tests \u2192 Distributed based on test content\n</code></pre>"},{"location":"examples/complex-workflows/#benefits","title":"Benefits","text":"<ul> <li>Each team's commit remains complete and self-contained</li> <li>Cross-cutting fixes distributed appropriately</li> <li>Integration branch maintains clear team boundaries</li> <li>Easier to track team contributions and review changes</li> </ul>"},{"location":"examples/complex-workflows/#complex-scenario-2-performance-optimization-campaign","title":"Complex Scenario 2: Performance Optimization Campaign","text":"<p>Situation: Systematic performance improvements across entire codebase affecting many historical commits.</p>"},{"location":"examples/complex-workflows/#performance-audit-results","title":"Performance Audit Results","text":"<pre><code># Profiling identified bottlenecks across multiple modules\nsrc/database/query_engine.py     # N+1 query issues\nsrc/cache/redis_client.py        # Connection pooling problems\nsrc/api/serialization.py         # Inefficient JSON encoding\nsrc/ui/data_tables.py            # Slow rendering algorithms\nsrc/utils/image_processing.py    # Memory leaks in processing\nsrc/background/task_queue.py     # Poor queue management\n</code></pre>"},{"location":"examples/complex-workflows/#optimization-implementation","title":"Optimization Implementation","text":"<p>Each file requires multiple types of improvements:</p> <pre><code># Example: src/database/query_engine.py\n# 1. Add query caching (lines 45-60)\n# 2. Fix N+1 queries (lines 120-135) \n# 3. Add connection pooling (lines 200-215)\n# 4. Optimize batch operations (lines 300-320)\n</code></pre>"},{"location":"examples/complex-workflows/#advanced-git-autosquash-strategy","title":"Advanced git-autosquash Strategy","text":"<pre><code># Use line-by-line for maximum precision\n$ git-autosquash --line-by-line\n\n# Each optimization technique goes to different historical commits:\n# - Query caching \u2192 Original query implementation commit\n# - N+1 fix \u2192 Commit that introduced the problematic pattern\n# - Connection pooling \u2192 Original database connection commit\n# - Batch optimization \u2192 Commit that added batch operations\n</code></pre>"},{"location":"examples/complex-workflows/#result-analysis","title":"Result Analysis","text":"<pre><code>$ git log --oneline -20\n# Each historical commit now includes its performance improvements\na1b2c3d Add batch operations (now with optimizations)\n4e5f6g7 Add database connection layer (now with pooling)\n8h9i0j1 Implement query engine (now with caching and N+1 fixes)  \n2k3l4m5 Add JSON serialization (now with efficient encoding)\n...\n</code></pre>"},{"location":"examples/complex-workflows/#verification","title":"Verification","text":"<pre><code># Performance improvements distributed correctly\n$ git show 8h9i0j1 --stat\nsrc/database/query_engine.py | 45 ++++++++++++++++++++++++++++++++++++++++\n# Shows original implementation plus all related optimizations\n\n# Each commit is now performance-complete\n$ git log --grep=\"performance\" --oneline\n# No separate performance commits - all integrated\n</code></pre>"},{"location":"examples/complex-workflows/#complex-scenario-3-security-hardening-across-history","title":"Complex Scenario 3: Security Hardening Across History","text":"<p>Situation: Security audit reveals vulnerabilities in multiple components introduced at different times.</p>"},{"location":"examples/complex-workflows/#security-audit-findings","title":"Security Audit Findings","text":"<ol> <li>SQL Injection: User input validation (3 different commits)</li> <li>XSS Vulnerabilities: Template rendering (2 commits)  </li> <li>Authentication Bypass: Session handling (4 commits)</li> <li>Information Disclosure: Error messages (5 commits)</li> <li>CSRF Attacks: Form handling (2 commits)</li> </ol>"},{"location":"examples/complex-workflows/#comprehensive-security-fixes","title":"Comprehensive Security Fixes","text":"<pre><code>$ git status --porcelain\nM  src/auth/session_manager.py     # Fix session vulnerabilities\nM  src/auth/login_handler.py       # Fix auth bypass issues\nM  src/ui/templates/base.html      # XSS prevention  \nM  src/ui/forms/user_forms.py      # CSRF protection\nM  src/database/user_queries.py    # SQL injection prevention\nM  src/api/error_handlers.py       # Information disclosure fixes\nM  src/utils/input_validator.py    # Input sanitization\nM  src/middleware/security.py      # Additional security headers\nM  tests/security/test_auth.py     # Security test coverage\n</code></pre>"},{"location":"examples/complex-workflows/#security-focused-git-autosquash","title":"Security-Focused git-autosquash","text":"<pre><code># Line-by-line precision for security fixes\n$ git-autosquash --line-by-line\n\n# Security fixes distributed to vulnerable commits:\n# - Session fixes \u2192 Original session implementation\n# - Auth bypass \u2192 Authentication implementation commits\n# - XSS prevention \u2192 Template system commits\n# - SQL injection \u2192 Database query commits  \n# - Error handling \u2192 Original error system commits\n</code></pre>"},{"location":"examples/complex-workflows/#security-verification","title":"Security Verification","text":"<pre><code># Each historical commit now secure\n$ git log --oneline | while read commit message; do\n    echo \"Checking security of: $message\"\n    git show $commit:src/ | grep -E \"(sql|exec|eval|innerHTML)\" || echo \"\u2713 Clean\"\ndone\n\n# Security improvements integrated throughout history\n$ git log --grep=\"security\" --oneline  \n# Should show minimal separate security commits\n</code></pre>"},{"location":"examples/complex-workflows/#complex-scenario-4-large-scale-refactoring","title":"Complex Scenario 4: Large-Scale Refactoring","text":"<p>Situation: Architectural refactoring affecting directory structure, module organization, and design patterns.</p>"},{"location":"examples/complex-workflows/#refactoring-goals","title":"Refactoring Goals","text":"<ol> <li>Extract service layer from monolithic controllers</li> <li>Implement dependency injection throughout application</li> <li>Add consistent error handling across all modules</li> <li>Standardize logging patterns in all components</li> <li>Refactor data access to repository pattern</li> </ol>"},{"location":"examples/complex-workflows/#refactoring-implementation","title":"Refactoring Implementation","text":"<pre><code># Before: Monolithic structure\nsrc/\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 user_controller.py      # Mixed business logic + data access\n\u2502   \u251c\u2500\u2500 auth_controller.py      # No error handling consistency\n\u2502   \u2514\u2500\u2500 api_controller.py       # Direct database calls\n\u251c\u2500\u2500 models/\n\u2514\u2500\u2500 utils/\n\n# After: Clean architecture  \nsrc/\n\u251c\u2500\u2500 controllers/     # Thin controllers\n\u251c\u2500\u2500 services/        # Business logic layer (NEW)\n\u251c\u2500\u2500 repositories/    # Data access layer (NEW)  \n\u251c\u2500\u2500 models/          # Domain models\n\u2514\u2500\u2500 utils/           # Cross-cutting concerns\n</code></pre>"},{"location":"examples/complex-workflows/#complex-change-distribution","title":"Complex Change Distribution","text":"<pre><code># Example: user_controller.py transformation\n# Original commit abc1234: \"Add user management controller\"\n\n# Changes during refactoring:\n# 1. Extract UserService \u2192 NEW service layer (stays as new)\n# 2. Add dependency injection \u2192 Goes back to abc1234\n# 3. Improve error handling \u2192 Goes back to abc1234  \n# 4. Add consistent logging \u2192 Goes back to abc1234\n# 5. Use repository pattern \u2192 Goes back to abc1234\n</code></pre>"},{"location":"examples/complex-workflows/#advanced-git-autosquash-execution","title":"Advanced git-autosquash Execution","text":"<pre><code># Refactoring produces many files\n$ git diff --name-only | wc -l\n47\n\n# Use line-by-line for architectural precision\n$ git-autosquash --line-by-line\n\n# Results:\n# - Service extractions \u2192 Stay as new architecture commits\n# - Controller improvements \u2192 Back to original controller commits\n# - Repository pattern \u2192 Back to original data access commits  \n# - Error handling \u2192 Back to original feature implementations\n# - Logging improvements \u2192 Back to original implementations\n</code></pre>"},{"location":"examples/complex-workflows/#post-refactoring-verification","title":"Post-Refactoring Verification","text":"<pre><code># Architecture commits remain clean\n$ git log --oneline --grep=\"Add.*Service\"\ndef5678 Add UserService and business logic layer\n789abcd Add AuthService and security layer  \nabc1234 Add EmailService and notification layer\n\n# Historical commits enhanced with patterns\n$ git show abc1234:src/controllers/user_controller.py | head -20\n# Shows original controller now with DI, error handling, logging\n\n# No refactoring noise in history\n$ git log --oneline | grep -i refactor | wc -l\n0  # All refactoring integrated into logical commits\n</code></pre>"},{"location":"examples/complex-workflows/#complex-scenario-5-multi-platform-feature-consistency","title":"Complex Scenario 5: Multi-Platform Feature Consistency","text":"<p>Situation: Feature implemented separately for web, mobile, and API needs consistency fixes across all platforms.</p>"},{"location":"examples/complex-workflows/#platform-specific-implementations","title":"Platform-Specific Implementations","text":"<pre><code># Feature: User notifications\nsrc/web/notifications/          # Web implementation (commit abc1234)\nsrc/mobile/notifications/       # Mobile implementation (commit def5678)  \nsrc/api/notifications/          # API implementation (commit ghi9012)\nsrc/shared/notification_types/  # Shared types (commit jkl3456)\n</code></pre>"},{"location":"examples/complex-workflows/#consistency-issues-discovered","title":"Consistency Issues Discovered","text":"<ol> <li>Different validation logic across platforms</li> <li>Inconsistent error messages between web and mobile</li> <li>Missing API endpoints for some notification types</li> <li>Shared types incomplete for all use cases</li> </ol>"},{"location":"examples/complex-workflows/#cross-platform-fixes","title":"Cross-Platform Fixes","text":"<pre><code>$ git status --porcelain\nM  src/web/notifications/validator.py      # Standardize validation\nM  src/mobile/notifications/validator.py   # Match web validation\nM  src/api/notifications/endpoints.py      # Add missing endpoints\nM  src/api/notifications/validator.py      # Match other platforms  \nM  src/shared/notification_types/base.py   # Extend shared types\nM  src/shared/notification_types/email.py  # Add missing email types\nM  tests/notifications/test_validation.py  # Cross-platform tests\n</code></pre>"},{"location":"examples/complex-workflows/#platform-aware-git-autosquash","title":"Platform-Aware git-autosquash","text":"<pre><code>$ git-autosquash --line-by-line\n\n# Platform-specific fixes go to platform commits:\n# - Web validation \u2192 abc1234 (original web implementation)\n# - Mobile validation \u2192 def5678 (original mobile implementation)  \n# - API endpoints \u2192 ghi9012 (original API implementation)\n# - Shared types \u2192 jkl3456 (original shared types)\n# - Cross-platform tests \u2192 Distributed by test content\n</code></pre>"},{"location":"examples/complex-workflows/#consistency-verification","title":"Consistency Verification","text":"<pre><code># Each platform commit now complete and consistent\n$ git show abc1234 --name-only | grep validation\nsrc/web/notifications/validator.py       # Now standardized\n\n$ git show def5678 --name-only | grep validation  \nsrc/mobile/notifications/validator.py    # Now matches web\n\n$ git show ghi9012 --name-only | grep endpoints\nsrc/api/notifications/endpoints.py       # Now complete\n\n# Cross-platform consistency achieved without noise\n$ git log --oneline | grep -i \"consistency\\|standardize\" | wc -l\n0  # All integrated into platform-specific commits\n</code></pre>"},{"location":"examples/complex-workflows/#complex-scenario-6-legacy-system-migration","title":"Complex Scenario 6: Legacy System Migration","text":"<p>Situation: Gradual migration from legacy system requires fixes to both old and new implementations.</p>"},{"location":"examples/complex-workflows/#migration-architecture","title":"Migration Architecture","text":"<pre><code># Parallel implementations during transition\nsrc/\n\u251c\u2500\u2500 legacy/\n\u2502   \u251c\u2500\u2500 user_auth.py        # Old authentication (commit abc1234)\n\u2502   \u251c\u2500\u2500 data_access.py      # Old database layer (commit def5678)\n\u2502   \u2514\u2500\u2500 session_mgmt.py     # Old session handling (commit ghi9012)\n\u251c\u2500\u2500 modern/\n\u2502   \u251c\u2500\u2500 auth_service.py     # New authentication (commit jkl3456) \n\u2502   \u251c\u2500\u2500 repository.py       # New data layer (commit mno7890)\n\u2502   \u2514\u2500\u2500 session_store.py    # New session handling (commit pqr1234)\n\u2514\u2500\u2500 bridge/\n    \u251c\u2500\u2500 auth_adapter.py     # Legacy bridge (commit stu5678)\n    \u2514\u2500\u2500 data_adapter.py     # Data bridge (commit vwx9012)\n</code></pre>"},{"location":"examples/complex-workflows/#migration-issues","title":"Migration Issues","text":"<p>During parallel operation, bugs found in both systems:</p> <pre><code>$ git status --porcelain  \nM  src/legacy/user_auth.py      # Security fix for legacy system\nM  src/modern/auth_service.py   # Corresponding fix in modern system\nM  src/bridge/auth_adapter.py   # Bridge compatibility fix\nM  src/legacy/data_access.py    # Performance fix in legacy\nM  src/modern/repository.py     # Equivalent modern improvement  \nM  src/bridge/data_adapter.py   # Bridge performance optimization\nM  tests/legacy/test_auth.py    # Legacy system tests\nM  tests/modern/test_auth.py    # Modern system tests\nM  tests/bridge/test_adapter.py # Bridge integration tests\n</code></pre>"},{"location":"examples/complex-workflows/#migration-aware-git-autosquash","title":"Migration-Aware git-autosquash","text":"<pre><code>$ git-autosquash --line-by-line\n\n# Fixes distributed to appropriate system commits:\n# - Legacy auth fix \u2192 abc1234 (legacy auth implementation)\n# - Modern auth fix \u2192 jkl3456 (modern auth implementation)  \n# - Bridge fixes \u2192 stu5678 (auth bridge implementation)\n# - Legacy data fix \u2192 def5678 (legacy data implementation)\n# - Modern data fix \u2192 mno7890 (modern data implementation)\n# - Data bridge fix \u2192 vwx9012 (data bridge implementation)\n</code></pre>"},{"location":"examples/complex-workflows/#migration-history-integrity","title":"Migration History Integrity","text":"<pre><code># Both systems maintain clean, parallel histories\n$ git log --oneline src/legacy/\nabc1234 Add legacy authentication system (with security fixes)\ndef5678 Add legacy data access layer (with performance improvements)\nghi9012 Add legacy session management\n\n$ git log --oneline src/modern/  \njkl3456 Add modern authentication service (with security fixes)\nmno7890 Add modern repository pattern (with performance improvements)\npqr1234 Add modern session store\n\n$ git log --oneline src/bridge/\nstu5678 Add authentication bridge (with compatibility fixes)\nvwx9012 Add data access bridge (with performance optimizations)\n\n# No migration noise - each system's history remains clean\n</code></pre>"},{"location":"examples/complex-workflows/#best-practices-for-complex-scenarios","title":"Best Practices for Complex Scenarios","text":""},{"location":"examples/complex-workflows/#pre-analysis-planning","title":"Pre-Analysis Planning","text":"<ol> <li>Map change intentions to historical commits</li> <li>Identify cross-cutting concerns that should stay together</li> <li>Plan line-by-line vs standard mode usage</li> <li>Coordinate with team for shared branches</li> </ol>"},{"location":"examples/complex-workflows/#execution-strategy","title":"Execution Strategy","text":"<ol> <li>Start with line-by-line mode for complex scenarios</li> <li>Review mappings carefully - complexity increases false positives</li> <li>Test thoroughly after each git-autosquash operation</li> <li>Use incremental approach - process subsets if needed</li> </ol>"},{"location":"examples/complex-workflows/#verification-checklist","title":"Verification Checklist","text":"<ul> <li> Each historical commit tells complete story</li> <li> No functionality broken by distribution  </li> <li> Cross-cutting concerns properly handled</li> <li> Team boundaries respected in shared development</li> <li> Security/performance improvements integrated appropriately</li> <li> Test coverage distributed correctly</li> <li> Documentation updated with code changes</li> </ul>"},{"location":"examples/complex-workflows/#recovery-planning","title":"Recovery Planning","text":"<p>For complex scenarios, always have recovery plan:</p> <pre><code># Before starting complex git-autosquash\ngit branch backup-before-autosquash\n\n# If results unsatisfactory\ngit reset --hard backup-before-autosquash\n\n# Try different approach\ngit-autosquash --line-by-line  # Or other options\n</code></pre> <p>Complex scenarios benefit most from git-autosquash's intelligence, but require careful planning and verification to ensure optimal results.</p>"},{"location":"examples/integration/","title":"Integration Examples","text":"<p>This guide demonstrates how to integrate git-autosquash into existing development workflows, tools, and team processes.</p>"},{"location":"examples/integration/#ide-integration","title":"IDE Integration","text":""},{"location":"examples/integration/#visual-studio-code","title":"Visual Studio Code","text":""},{"location":"examples/integration/#tasks-configuration","title":"Tasks Configuration","text":"<p>Create <code>.vscode/tasks.json</code>:</p> <pre><code>{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"git-autosquash\",\n            \"type\": \"shell\",\n            \"command\": \"git-autosquash\",\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": false\n            },\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"always\",\n                \"focus\": true,\n                \"panel\": \"new\",\n                \"showReuseMessage\": true,\n                \"clear\": true\n            },\n            \"problemMatcher\": [],\n            \"runOptions\": {\n                \"runOn\": \"default\"\n            }\n        },\n        {\n            \"label\": \"git-autosquash (line-by-line)\",\n            \"type\": \"shell\", \n            \"command\": \"git-autosquash\",\n            \"args\": [\"--line-by-line\"],\n            \"group\": \"build\",\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"always\",\n                \"focus\": true,\n                \"panel\": \"new\"\n            },\n            \"problemMatcher\": []\n        },\n        {\n            \"label\": \"check-autosquash-needed\",\n            \"type\": \"shell\",\n            \"command\": \"bash\",\n            \"args\": [\n                \"-c\",\n                \"if ! git diff --quiet; then echo 'Changes detected - consider git-autosquash'; git diff --stat; else echo 'No changes to organize'; fi\"\n            ],\n            \"group\": \"build\",\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"silent\",\n                \"panel\": \"shared\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"examples/integration/#keybindings","title":"Keybindings","text":"<p>Add to <code>.vscode/keybindings.json</code>:</p> <pre><code>[\n    {\n        \"key\": \"ctrl+shift+g a\",\n        \"command\": \"workbench.action.tasks.runTask\",\n        \"args\": \"git-autosquash\"\n    },\n    {\n        \"key\": \"ctrl+shift+g ctrl+a\", \n        \"command\": \"workbench.action.tasks.runTask\",\n        \"args\": \"git-autosquash (line-by-line)\"\n    },\n    {\n        \"key\": \"ctrl+shift+g c\",\n        \"command\": \"workbench.action.tasks.runTask\", \n        \"args\": \"check-autosquash-needed\"\n    }\n]\n</code></pre>"},{"location":"examples/integration/#settings-and-extensions","title":"Settings and Extensions","text":"<p>Add to <code>.vscode/settings.json</code>:</p> <pre><code>{\n    \"git.autofetch\": true,\n    \"git.confirmSync\": false,\n    \"terminal.integrated.defaultProfile.linux\": \"bash\",\n    \"terminal.integrated.profiles.linux\": {\n        \"bash\": {\n            \"path\": \"bash\",\n            \"args\": [\"-l\"],\n            \"env\": {\n                \"TERM\": \"xterm-256color\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"examples/integration/#intellij-idea-pycharm","title":"IntelliJ IDEA / PyCharm","text":""},{"location":"examples/integration/#external-tools-setup","title":"External Tools Setup","text":"<ol> <li>Settings \u2192 Tools \u2192 External Tools</li> <li>Add New Tool:</li> </ol> <p>git-autosquash (Standard): <pre><code>Name: git-autosquash\nDescription: Organize changes into historical commits\nProgram: git-autosquash\nWorking directory: $ProjectFileDir$\n</code></pre></p> <p>git-autosquash (Precise): <pre><code>Name: git-autosquash (line-by-line)\nDescription: Organize changes with line-by-line precision  \nProgram: git-autosquash\nArguments: --line-by-line\nWorking directory: $ProjectFileDir$\n</code></pre></p>"},{"location":"examples/integration/#toolbar-integration","title":"Toolbar Integration","text":"<ol> <li>Settings \u2192 Appearance &amp; Behavior \u2192 Menus and Toolbars</li> <li>Main Toolbar \u2192 Add Action \u2192 External Tools</li> <li>Add both git-autosquash tools</li> </ol>"},{"location":"examples/integration/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<ol> <li>Settings \u2192 Keymap</li> <li>External Tools \u2192 git-autosquash</li> <li>Add Keyboard Shortcut: <code>Ctrl+Alt+G</code></li> </ol>"},{"location":"examples/integration/#vimneovim","title":"Vim/Neovim","text":""},{"location":"examples/integration/#basic-integration","title":"Basic Integration","text":"<p>Add to <code>.vimrc</code> or <code>init.vim</code>:</p> <pre><code>\" git-autosquash integration\nnnoremap &lt;leader&gt;ga :!git-autosquash&lt;CR&gt;\nnnoremap &lt;leader&gt;gA :!git-autosquash --line-by-line&lt;CR&gt;\n\n\" Check if autosquash would be useful\nfunction! CheckAutosquash()\n    let l:status = system('git diff --quiet')\n    if v:shell_error != 0\n        echo \"Changes detected - consider git-autosquash\"\n        echo system('git diff --stat')\n    else\n        echo \"No changes to organize\"\n    endif\nendfunction\n\ncommand! CheckAutosquash call CheckAutosquash()\nnnoremap &lt;leader&gt;gc :CheckAutosquash&lt;CR&gt;\n\n\" Pre-commit check\nfunction! PreCommitCheck()\n    if !empty(system('git diff --name-only'))\n        let l:response = input(\"Uncommitted changes detected. Run git-autosquash first? (y/n): \")\n        if l:response ==? 'y'\n            !git-autosquash\n        endif\n    endif\nendfunction\n\ncommand! PreCommitCheck call PreCommitCheck()\n</code></pre>"},{"location":"examples/integration/#advanced-neovim-integration","title":"Advanced Neovim Integration","text":"<p>For Neovim with Lua configuration:</p> <pre><code>-- init.lua or plugin configuration\nlocal function git_autosquash(line_by_line)\n    local cmd = line_by_line and \"git-autosquash --line-by-line\" or \"git-autosquash\"\n    vim.cmd(\"!\" .. cmd)\nend\n\nlocal function check_autosquash()\n    local handle = io.popen(\"git diff --quiet\")\n    local result = handle:close()\n\n    if not result then\n        print(\"Changes detected - consider git-autosquash\")\n        local stats = io.popen(\"git diff --stat\"):read(\"*all\")\n        print(stats)\n    else\n        print(\"No changes to organize\")\n    end\nend\n\n-- Keymaps\nvim.keymap.set('n', '&lt;leader&gt;ga', function() git_autosquash(false) end, { desc = \"git-autosquash\" })\nvim.keymap.set('n', '&lt;leader&gt;gA', function() git_autosquash(true) end, { desc = \"git-autosquash line-by-line\" })\nvim.keymap.set('n', '&lt;leader&gt;gc', check_autosquash, { desc = \"Check autosquash needed\" })\n\n-- Commands\nvim.api.nvim_create_user_command('GitAutosquash', function() git_autosquash(false) end, {})\nvim.api.nvim_create_user_command('GitAutosquashPrecise', function() git_autosquash(true) end, {})\nvim.api.nvim_create_user_command('CheckAutosquash', check_autosquash, {})\n</code></pre>"},{"location":"examples/integration/#git-hooks-integration","title":"Git Hooks Integration","text":""},{"location":"examples/integration/#pre-commit-hook","title":"Pre-commit Hook","text":"<pre><code>#!/bin/bash\n# .git/hooks/pre-commit\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m' # No Color\n\necho -e \"${YELLOW}Pre-commit: Checking working directory...${NC}\"\n\n# Check if there are unstaged changes\nif ! git diff --quiet; then\n    echo -e \"${YELLOW}Unstaged changes detected.${NC}\"\n    echo -e \"Consider running ${GREEN}git-autosquash${NC} to organize changes before committing.\"\n    echo\n    echo \"Changed files:\"\n    git diff --name-only | sed 's/^/  /'\n    echo\n\n    # Option to run git-autosquash automatically\n    if [ -t 0 ]; then  # Only prompt if interactive\n        read -p \"Run git-autosquash now? (y/n): \" -n 1 -r\n        echo\n        if [[ $REPLY =~ ^[Yy]$ ]]; then\n            git-autosquash\n            exit $?  # Exit with git-autosquash result\n        fi\n    fi\n\n    # Continue with commit if user declined\n    echo -e \"${YELLOW}Proceeding with commit of staged changes only...${NC}\"\nfi\n\n# Run standard pre-commit checks (linting, tests, etc.)\necho -e \"${GREEN}Pre-commit: All checks passed${NC}\"\nexit 0\n</code></pre>"},{"location":"examples/integration/#pre-push-hook","title":"Pre-push Hook","text":"<pre><code>#!/bin/bash\n# .git/hooks/pre-push\n\n# Arguments: $1 = remote name, $2 = remote URL\nremote=\"$1\"\nurl=\"$2\"\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m' \nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\necho -e \"${YELLOW}Pre-push: Checking branch organization...${NC}\"\n\n# Get current branch\nbranch=$(git rev-parse --abbrev-ref HEAD)\n\n# Skip checks for main/master branches\nif [[ \"$branch\" == \"main\" || \"$branch\" == \"master\" ]]; then\n    echo -e \"${GREEN}Pre-push: Main branch, skipping autosquash checks${NC}\"\n    exit 0\nfi\n\n# Check if there are uncommitted changes\nif ! git diff --quiet || ! git diff --cached --quiet; then\n    echo -e \"${RED}Uncommitted changes detected on branch: $branch${NC}\"\n    echo \"Consider organizing changes with git-autosquash before pushing.\"\n    echo\n\n    # Show what's changed\n    if ! git diff --quiet; then\n        echo \"Unstaged changes:\"\n        git diff --name-only | sed 's/^/  /'\n    fi\n\n    if ! git diff --cached --quiet; then\n        echo \"Staged changes:\"\n        git diff --cached --name-only | sed 's/^/  /'\n    fi\n    echo\n\n    if [ -t 0 ]; then  # Interactive terminal\n        read -p \"Continue with push anyway? (y/n): \" -n 1 -r\n        echo\n        if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n            echo -e \"${RED}Push cancelled. Organize changes and try again.${NC}\"\n            exit 1\n        fi\n    else\n        echo -e \"${RED}Push cancelled due to uncommitted changes.${NC}\"\n        exit 1\n    fi\nfi\n\n# Check branch history quality (optional enhancement)\ncommit_count=$(git rev-list --count origin/main..HEAD 2&gt;/dev/null || echo \"0\")\nif [ \"$commit_count\" -gt 10 ]; then\n    echo -e \"${YELLOW}Branch has many commits ($commit_count). Consider using git-autosquash for cleaner history.${NC}\"\nfi\n\necho -e \"${GREEN}Pre-push: Branch organization looks good${NC}\"\nexit 0\n</code></pre>"},{"location":"examples/integration/#post-commit-hook","title":"Post-commit Hook","text":"<pre><code>#!/bin/bash\n# .git/hooks/post-commit\n\n# Colors\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\n# Check if working directory has changes after commit\nif ! git diff --quiet; then\n    echo -e \"${YELLOW}Working directory still has changes after commit.${NC}\"\n    echo -e \"Consider running ${GREEN}git-autosquash${NC} to organize remaining changes.\"\n    echo\n    echo \"Remaining changes:\"\n    git diff --name-only | sed 's/^/  /'\n    echo\nfi\n</code></pre>"},{"location":"examples/integration/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"examples/integration/#github-actions","title":"GitHub Actions","text":""},{"location":"examples/integration/#autosquash-opportunity-detection","title":"Autosquash Opportunity Detection","text":"<pre><code># .github/workflows/autosquash-check.yml\nname: Autosquash Opportunity Check\non: \n  pull_request:\n    types: [opened, synchronize]\n\njobs:\n  check-organization:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0  # Need full history for analysis\n\n      - name: Install git-autosquash\n        run: pipx install git-autosquash\n\n      - name: Analyze branch organization\n        run: |\n          echo \"## Branch Analysis\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Count commits in PR\n          COMMIT_COUNT=$(git rev-list --count origin/main..HEAD)\n          echo \"Commits in branch: $COMMIT_COUNT\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Count changed files\n          FILE_COUNT=$(git diff --name-only origin/main..HEAD | wc -l)\n          echo \"Files changed: $FILE_COUNT\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Check for potential organization opportunities\n          if [ $COMMIT_COUNT -gt 5 ] &amp;&amp; [ $FILE_COUNT -gt 10 ]; then\n            echo \"::notice::Branch might benefit from git-autosquash organization\"\n            echo \"::notice::Consider running git-autosquash to organize $COMMIT_COUNT commits across $FILE_COUNT files\"\n\n            echo \"## Recommendation\" &gt;&gt; $GITHUB_STEP_SUMMARY\n            echo \"This branch has many commits and file changes. Consider:\" &gt;&gt; $GITHUB_STEP_SUMMARY\n            echo \"1. Run \\`git-autosquash\\` to organize commits\" &gt;&gt; $GITHUB_STEP_SUMMARY\n            echo \"2. Review the organized history\" &gt;&gt; $GITHUB_STEP_SUMMARY\n            echo \"3. Force-push the cleaned branch\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else\n            echo \"::notice::Branch organization looks good\"\n            echo \"## Status\" &gt;&gt; $GITHUB_STEP_SUMMARY\n            echo \"Branch organization appears well-structured.\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n\n          # Show commit history\n          echo \"## Commit History\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo '```' &gt;&gt; $GITHUB_STEP_SUMMARY\n          git log --oneline origin/main..HEAD &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo '```' &gt;&gt; $GITHUB_STEP_SUMMARY\n</code></pre>"},{"location":"examples/integration/#documentation-for-pr-authors","title":"Documentation for PR Authors","text":"<pre><code># .github/workflows/pr-guidance.yml\nname: PR Development Guidance\non:\n  pull_request:\n    types: [opened]\n\njobs:\n  provide-guidance:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Comment on PR with git-autosquash guidance\n        uses: actions/github-script@v7\n        with:\n          script: |\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: `## Development Workflow Guidance\n\n              Thank you for your contribution! Here are some tips for maintaining clean commit history:\n\n              ### Using git-autosquash\n\n              If you need to make additional changes to this PR:\n\n              1. **Make your changes** as normal in your working directory\n              2. **Run git-autosquash** to organize changes:\n                 \\`\\`\\`bash\n                 git-autosquash\n                 \\`\\`\\`\n              3. **Review the proposed organization** in the TUI\n              4. **Force-push** the cleaned history:\n                 \\`\\`\\`bash\n                 git push --force-with-lease\n                 \\`\\`\\`\n\n              ### When to use git-autosquash\n\n              - \u2705 Bug fixes for existing features\n              - \u2705 Code review feedback  \n              - \u2705 Refactoring improvements\n              - \u2705 Documentation updates\n\n              ### Benefits\n\n              - Maintains logical commit organization\n              - Each commit tells a complete story\n              - Easier code review and maintenance\n              - Cleaner project history\n\n              Questions? See our [git-autosquash documentation](https://docs.example.com/git-autosquash).`\n            })\n</code></pre>"},{"location":"examples/integration/#gitlab-ci","title":"GitLab CI","text":"<pre><code># .gitlab-ci.yml\nstages:\n  - analyze\n  - build\n  - test\n\nautosquash-analysis:\n  stage: analyze\n  image: python:3.12-slim\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y git\n    - pip install pipx\n    - pipx install git-autosquash\n  script:\n    - |\n      if [ \"$CI_PIPELINE_SOURCE\" == \"merge_request_event\" ]; then\n        echo \"Analyzing merge request branch organization...\"\n\n        # Fetch target branch for comparison\n        git fetch origin $CI_MERGE_REQUEST_TARGET_BRANCH_NAME\n\n        # Count commits and files\n        COMMIT_COUNT=$(git rev-list --count origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME..HEAD)\n        FILE_COUNT=$(git diff --name-only origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME..HEAD | wc -l)\n\n        echo \"Commits in MR: $COMMIT_COUNT\"\n        echo \"Files changed: $FILE_COUNT\"\n\n        # Provide recommendations\n        if [ $COMMIT_COUNT -gt 5 ] &amp;&amp; [ $FILE_COUNT -gt 10 ]; then\n          echo \"::warning::Consider using git-autosquash to organize this branch\"\n          echo \"Run: git-autosquash &amp;&amp; git push --force-with-lease\"\n        else\n          echo \"::info::Branch organization looks good\"\n        fi\n      fi\n  only:\n    - merge_requests\n</code></pre>"},{"location":"examples/integration/#build-tool-integration","title":"Build Tool Integration","text":""},{"location":"examples/integration/#makefile","title":"Makefile","text":"<pre><code>.PHONY: autosquash autosquash-check autosquash-precise clean-history pre-commit\n\n# Standard git-autosquash\nautosquash:\n    @echo \"Running git-autosquash...\"\n    @if ! git diff --quiet; then \\\n        git-autosquash; \\\n    else \\\n        echo \"No changes to organize\"; \\\n    fi\n\n# Line-by-line precision mode  \nautosquash-precise:\n    @echo \"Running git-autosquash with line-by-line precision...\"\n    @if ! git diff --quiet; then \\\n        git-autosquash --line-by-line; \\\n    else \\\n        echo \"No changes to organize\"; \\\n    fi\n\n# Check if autosquash would be useful\nautosquash-check:\n    @if ! git diff --quiet; then \\\n        echo \"Changes detected:\"; \\\n        git diff --stat; \\\n        echo \"\"; \\\n        echo \"Consider running 'make autosquash' to organize changes\"; \\\n    else \\\n        echo \"No changes to analyze\"; \\\n    fi\n\n# Clean up branch history before merge\nclean-history: autosquash\n    @echo \"Branch history cleaned\"\n    @git log --oneline -10\n\n# Pre-commit workflow\npre-commit: autosquash-check\n    @echo \"Pre-commit checks completed\"\n\n# Development workflow shortcuts\ndev-commit: autosquash\n    @echo \"Ready for commit after organization\"\n\ndev-push: autosquash  \n    @echo \"Organized changes, ready to push\"\n    @git push --force-with-lease\n\n# Integration with existing workflows\ntest: autosquash-check\n    pytest tests/\n\nlint: autosquash-check\n    ruff check src/\n    ruff format src/\n\nbuild: autosquash-check lint test\n    python -m build\n\n# Help target\nhelp:\n    @echo \"git-autosquash integration targets:\"\n    @echo \"  autosquash        - Organize changes into logical commits\"  \n    @echo \"  autosquash-precise - Use line-by-line precision\"\n    @echo \"  autosquash-check  - Check if organization would be useful\"\n    @echo \"  clean-history     - Clean up branch before merge\"\n    @echo \"  pre-commit        - Pre-commit workflow with checks\"\n    @echo \"  dev-commit        - Organize then prompt for commit\"\n    @echo \"  dev-push          - Organize and force-push\"\n</code></pre>"},{"location":"examples/integration/#npm-scripts","title":"NPM Scripts","text":"<p>For Node.js projects, add to <code>package.json</code>:</p> <pre><code>{\n  \"scripts\": {\n    \"autosquash\": \"git-autosquash\",\n    \"autosquash:precise\": \"git-autosquash --line-by-line\",  \n    \"autosquash:check\": \"bash -c 'if ! git diff --quiet; then echo \\\"Changes detected:\\\"; git diff --stat; echo \\\"\\\"; echo \\\"Run: npm run autosquash\\\"; else echo \\\"No changes to organize\\\"; fi'\",\n    \"pre-commit\": \"npm run autosquash:check &amp;&amp; npm run lint &amp;&amp; npm run test\",\n    \"pre-push\": \"npm run autosquash:check\",\n    \"clean-history\": \"npm run autosquash &amp;&amp; git log --oneline -10\",\n    \"dev:organize\": \"npm run autosquash &amp;&amp; echo 'Ready for commit'\",\n    \"dev:push\": \"npm run autosquash &amp;&amp; git push --force-with-lease\"\n  },\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"npm run pre-commit\",\n      \"pre-push\": \"npm run pre-push\"\n    }\n  }\n}\n</code></pre>"},{"location":"examples/integration/#gradle","title":"Gradle","text":"<p>For Java projects, add to <code>build.gradle</code>:</p> <pre><code>task autosquash(type: Exec) {\n    group = 'git'\n    description = 'Organize changes into logical commits'\n    commandLine 'git-autosquash'\n}\n\ntask autosquashPrecise(type: Exec) {\n    group = 'git'\n    description = 'Organize changes with line-by-line precision'\n    commandLine 'git-autosquash', '--line-by-line'\n}\n\ntask autosquashCheck(type: Exec) {\n    group = 'git'\n    description = 'Check if git-autosquash would be useful'\n    commandLine 'bash', '-c', '''\n        if ! git diff --quiet; then\n            echo \"Changes detected:\"\n            git diff --stat\n            echo \"\"\n            echo \"Consider running: ./gradlew autosquash\"\n        else\n            echo \"No changes to organize\"\n        fi\n    '''\n}\n\ntask preCommit {\n    group = 'git'\n    description = 'Pre-commit workflow with organization check'\n    dependsOn autosquashCheck, test, checkstyleMain\n}\n\n// Integration with existing tasks\ntest.finalizedBy autosquashCheck\nbuild.dependsOn preCommit\n</code></pre>"},{"location":"examples/integration/#team-workflow-integration","title":"Team Workflow Integration","text":""},{"location":"examples/integration/#code-review-process","title":"Code Review Process","text":"<pre><code># Team Code Review Checklist\n\n## Before Requesting Review\n\n- [ ] Run `git-autosquash` to organize commits\n- [ ] Ensure each commit has a clear, focused purpose  \n- [ ] Verify commit messages follow team conventions\n- [ ] Force-push organized branch: `git push --force-with-lease`\n\n## During Code Review\n\n### Reviewer Checklist\n- [ ] Commit organization makes logical sense\n- [ ] Each commit can be understood independently\n- [ ] Bug fixes are integrated into original implementations\n- [ ] Feature additions are clearly separated\n\n### Feedback Integration\nWhen addressing review feedback:\n\n1. Make requested changes in working directory\n2. Run `git-autosquash` to distribute fixes appropriately\n3. Review proposed organization in TUI\n4. Force-push updated branch\n5. Respond to review with summary of changes\n</code></pre>"},{"location":"examples/integration/#branch-naming-conventions","title":"Branch Naming Conventions","text":"<pre><code># Team conventions that work well with git-autosquash\n\n# Feature branches - new functionality\nfeature/user-authentication\nfeature/dashboard-ui\nfeature/api-endpoints\n\n# Bugfix branches - primarily fixes\nbugfix/login-validation\nbugfix/memory-leaks\nbugfix/security-issues\n\n# Refactor branches - improvements to existing code  \nrefactor/auth-service\nrefactor/database-layer\nrefactor/error-handling\n\n# Mixed branches - both new features and fixes\nmixed/user-management\nmixed/notification-system\n</code></pre>"},{"location":"examples/integration/#documentation-standards","title":"Documentation Standards","text":"<p>Team documentation template for PRs:</p> <pre><code>## Changes Made\n\n### New Features\n- List new functionality that will remain as new commits\n\n### Bug Fixes  \n- List fixes that git-autosquash distributed to historical commits\n\n### Improvements\n- List refactoring/optimization that was integrated into existing commits\n\n## git-autosquash Usage\n\n- [x] Ran git-autosquash to organize commits\n- [x] Reviewed proposed organization in TUI  \n- [x] Verified each commit maintains focused scope\n- [ ] N/A - No changes needed organization\n\n## Testing\n\n- [ ] All tests pass\n- [ ] Added tests for new functionality\n- [ ] Verified fixes resolve reported issues\n</code></pre> <p>This integration approach ensures git-autosquash becomes a natural part of development workflow rather than an additional burden.</p>"},{"location":"includes/mkdocs/","title":"Mkdocs","text":""},{"location":"reference/cli-options/","title":"CLI Options","text":"<p>git-autosquash provides a simple command-line interface with focus on ease of use. This reference covers all available options and their usage.</p>"},{"location":"reference/cli-options/#basic-usage","title":"Basic Usage","text":"<pre><code>git-autosquash [OPTIONS]\n</code></pre>"},{"location":"reference/cli-options/#command-line-options","title":"Command-Line Options","text":""},{"location":"reference/cli-options/#-line-by-line","title":"<code>--line-by-line</code>","text":"<p>Usage: <code>git-autosquash --line-by-line</code></p> <p>Description: Use line-by-line hunk splitting instead of default git hunks.</p> <p>Default: Git's default hunk boundaries (typically more efficient)</p> <p>When to use: - When you need very fine-grained control over which changes go where - When default hunks group unrelated changes together - When you want maximum precision in blame analysis</p> <p>Example: <pre><code># Standard mode - uses git's hunk boundaries\ngit-autosquash\n\n# Line-by-line mode - splits changes into individual lines\ngit-autosquash --line-by-line\n</code></pre></p> <p>Performance impact: Line-by-line mode is slower but more precise.</p>"},{"location":"reference/cli-options/#-version","title":"<code>--version</code>","text":"<p>Usage: <code>git-autosquash --version</code></p> <p>Description: Display version information and exit.</p> <p>Example: <pre><code>$ git-autosquash --version\ngit-autosquash 1.0.0\n</code></pre></p>"},{"location":"reference/cli-options/#-help-h","title":"<code>--help</code> / <code>-h</code>","text":"<p>Usage: <code>git-autosquash --help</code></p> <p>Description: Show help message with available options and exit.</p> <p>Example: <pre><code>$ git-autosquash --help\nusage: git-autosquash [-h] [--line-by-line] [--version]\n\nAutomatically squash changes back into historical commits\n\noptions:\n  -h, --help       show this help message and exit\n  --line-by-line   Use line-by-line hunk splitting instead of default git hunks\n  --version        show program's version number and exit\n</code></pre></p>"},{"location":"reference/cli-options/#option-details","title":"Option Details","text":""},{"location":"reference/cli-options/#hunk-splitting-default-vs-line-by-line","title":"Hunk Splitting: Default vs Line-by-Line","text":"<p>The <code>--line-by-line</code> option changes how git-autosquash analyzes your changes:</p>"},{"location":"reference/cli-options/#default-mode-recommended","title":"Default Mode (Recommended)","text":"<pre><code>git-autosquash\n</code></pre> <p>How it works: - Uses Git's natural hunk boundaries from <code>git diff</code> - Groups related changes together (e.g., function modifications) - More efficient for most scenarios - Better performance with large changes</p> <p>Example diff handling: <pre><code>@@ -10,6 +10,8 @@ def authenticate_user(username, password):\n     if not username:\n-        return None\n+        return {\"error\": \"Username required\"}\n\n     if not password:\n-        return None  \n+        return {\"error\": \"Password required\"}\n+        \n+    # Validate credentials\n     return validate_credentials(username, password)\n</code></pre></p> <p>Result: This entire change is treated as one hunk, going to whichever commit most frequently modified this function.</p>"},{"location":"reference/cli-options/#line-by-line-mode","title":"Line-by-Line Mode","text":"<pre><code>git-autosquash --line-by-line\n</code></pre> <p>How it works: - Splits changes into individual line modifications - Each line change analyzed separately for blame - Maximum precision in targeting - Slower but more granular control</p> <p>Example diff handling: Using the same diff above, line-by-line mode creates separate hunks for: 1. Line 12: <code>return None</code> \u2192 <code>return {\"error\": \"Username required\"}</code> 2. Line 15: <code>return None</code> \u2192 <code>return {\"error\": \"Password required\"}</code> 3. Line 17: Addition of <code># Validate credentials</code></p> <p>Result: Each line change can go to different commits based on individual blame analysis.</p>"},{"location":"reference/cli-options/#when-to-use-each-mode","title":"When to Use Each Mode","text":"Scenario Recommended Mode Reason General development Default Faster, handles related changes together Large refactoring Default More efficient for bulk changes Precise bug fixes <code>--line-by-line</code> Individual lines may belong to different commits Code review fixes <code>--line-by-line</code> Review comments often target specific lines Mixed change types <code>--line-by-line</code> Better separation of unrelated modifications"},{"location":"reference/cli-options/#exit-codes","title":"Exit Codes","text":"<p>git-autosquash uses standard Unix exit codes:</p> Code Meaning Description 0 Success Operation completed successfully 1 General error Git operation failed, invalid repository, etc. 130 Interrupted User cancelled with Ctrl+C <p>Examples: <pre><code># Success\n$ git-autosquash\n# ... TUI workflow ...\n\u2713 Squash operation completed successfully!\n$ echo $?\n0\n\n# User cancellation  \n$ git-autosquash\n# ... user presses Escape or Ctrl+C ...\nOperation cancelled by user\n$ echo $?\n130\n\n# Error (not in git repository)\n$ cd /tmp &amp;&amp; git-autosquash\nError: Not in a git repository\n$ echo $?\n1\n</code></pre></p>"},{"location":"reference/cli-options/#environment-variables","title":"Environment Variables","text":"<p>git-autosquash respects these environment variables:</p>"},{"location":"reference/cli-options/#term","title":"<code>TERM</code>","text":"<p>Purpose: Controls terminal capabilities for TUI rendering</p> <p>Example: <pre><code># Force basic terminal mode\nTERM=dumb git-autosquash\n\n# Ensure full color support\nTERM=xterm-256color git-autosquash\n</code></pre></p>"},{"location":"reference/cli-options/#no_color","title":"<code>NO_COLOR</code>","text":"<p>Purpose: Disable colored output when set to any value</p> <p>Example: <pre><code># Disable colors\nNO_COLOR=1 git-autosquash\n\n# Enable colors (default)\nunset NO_COLOR\ngit-autosquash\n</code></pre></p>"},{"location":"reference/cli-options/#git_sequence_editor","title":"<code>GIT_SEQUENCE_EDITOR</code>","text":"<p>Purpose: git-autosquash temporarily overrides this during rebase operations</p> <p>Don't Set Manually</p> <p>git-autosquash manages this automatically. Setting it manually may interfere with the rebase process.</p>"},{"location":"reference/cli-options/#editor-visual","title":"<code>EDITOR</code> / <code>VISUAL</code>","text":"<p>Purpose: Used by Git for conflict resolution when rebase conflicts occur</p> <p>Example: <pre><code># Use specific editor for conflict resolution\nEDITOR=vim git-autosquash\n\n# Or set globally\nexport EDITOR=code\ngit-autosquash\n</code></pre></p>"},{"location":"reference/cli-options/#git-configuration-integration","title":"Git Configuration Integration","text":"<p>git-autosquash works with standard Git configuration:</p>"},{"location":"reference/cli-options/#relevant-git-settings","title":"Relevant Git Settings","text":"<pre><code># These Git settings affect git-autosquash behavior:\n\n# Default editor for conflict resolution\ngit config --global core.editor vim\n\n# Merge tool for resolving conflicts\ngit config --global merge.tool vimdiff  \n\n# Automatic stashing during rebase (overridden by git-autosquash)\ngit config --global rebase.autoStash true\n</code></pre>"},{"location":"reference/cli-options/#git-aliases","title":"Git Aliases","text":"<p>You can create Git aliases for convenience:</p> <pre><code># Set up alias\ngit config --global alias.autosquash '!git-autosquash'\n\n# Now you can use:\ngit autosquash\ngit autosquash --line-by-line\n</code></pre>"},{"location":"reference/cli-options/#shell-integration","title":"Shell Integration","text":""},{"location":"reference/cli-options/#tab-completion","title":"Tab Completion","text":"<p>If you have <code>argcomplete</code> installed, git-autosquash supports tab completion:</p> <pre><code># Install argcomplete\npipx inject git-autosquash argcomplete\n\n# Enable completion (add to your shell config)\neval \"$(register-python-argcomplete git-autosquash)\"\n\n# Now you can tab-complete:\ngit-autosquash --&lt;TAB&gt;\n# Shows: --line-by-line --version --help\n</code></pre>"},{"location":"reference/cli-options/#shell-functions","title":"Shell Functions","text":"<p>Useful shell functions for git-autosquash:</p> <pre><code># Quick function to check if autosquash would be useful\ncheck-autosquash() {\n    if git diff --quiet; then\n        echo \"No changes to analyze\"\n    else\n        echo \"Found changes - git-autosquash might be useful\"\n        git diff --stat\n    fi\n}\n\n# Function to run autosquash with confirmation\nsafe-autosquash() {\n    echo \"Current changes:\"\n    git status --short\n    read -p \"Run git-autosquash? (y/n): \" -n 1 -r\n    echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n        git-autosquash \"$@\"\n    fi\n}\n</code></pre>"},{"location":"reference/cli-options/#debugging-and-troubleshooting","title":"Debugging and Troubleshooting","text":""},{"location":"reference/cli-options/#verbose-output","title":"Verbose Output","text":"<p>While git-autosquash doesn't have a verbose flag, you can monitor Git operations:</p> <pre><code># Set Git trace for debugging\nGIT_TRACE=1 git-autosquash\n\n# Monitor specific Git operations\nGIT_TRACE_SETUP=1 git-autosquash\n</code></pre>"},{"location":"reference/cli-options/#common-issues","title":"Common Issues","text":""},{"location":"reference/cli-options/#command-not-found","title":"\"Command not found\"","text":"<pre><code># Check if installed\nwhich git-autosquash\necho $PATH\n\n# Reinstall if needed\npipx reinstall git-autosquash\n</code></pre>"},{"location":"reference/cli-options/#permission-denied","title":"\"Permission denied\"","text":"<pre><code># Check file permissions\nls -la $(which git-autosquash)\n\n# Fix if needed (pipx should handle this automatically)\nchmod +x $(which git-autosquash)\n</code></pre>"},{"location":"reference/cli-options/#tui-not-working","title":"\"TUI not working\"","text":"<pre><code># Check terminal capabilities\necho $TERM\ntput colors\n\n# Try with basic terminal\nTERM=dumb git-autosquash\n</code></pre>"},{"location":"reference/cli-options/#integration-examples","title":"Integration Examples","text":""},{"location":"reference/cli-options/#pre-commit-hook","title":"Pre-commit Hook","text":"<pre><code>#!/bin/bash\n# .git/hooks/pre-commit\n\n# Check if we have unstaged changes that might benefit from autosquash\nif ! git diff --quiet; then\n    echo \"Consider running 'git-autosquash' before committing\"\n    echo \"to distribute changes to their logical commits.\"\nfi\n</code></pre>"},{"location":"reference/cli-options/#makefile-integration","title":"Makefile Integration","text":"<pre><code>.PHONY: autosquash\nautosquash:\n    @echo \"Running git-autosquash...\"\n    @git-autosquash\n\n.PHONY: autosquash-precise  \nautosquash-precise:\n    @echo \"Running git-autosquash with line-by-line precision...\"\n    @git-autosquash --line-by-line\n</code></pre>"},{"location":"reference/cli-options/#cicd-integration","title":"CI/CD Integration","text":"<pre><code># .github/workflows/check-autosquash.yml\nname: Check if autosquash needed\non: [pull_request]\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Check for unorganized changes\n        run: |\n          if ! git diff --quiet origin/main..HEAD; then\n            echo \"::notice::Consider using git-autosquash to organize changes\"\n          fi\n</code></pre> <p>For more advanced usage patterns, see Advanced Usage.</p>"},{"location":"reference/configuration/","title":"Configuration Reference","text":"<p>git-autosquash supports various configuration options through environment variables, Git configuration, and command-line arguments.</p>"},{"location":"reference/configuration/#command-line-options","title":"Command-Line Options","text":""},{"location":"reference/configuration/#core-options","title":"Core Options","text":""},{"location":"reference/configuration/#-line-by-line","title":"<code>--line-by-line</code>","text":"<p>Description: Enable line-by-line hunk splitting mode Usage: <code>git-autosquash --line-by-line</code> Default: Disabled (uses git's default hunk boundaries)</p> <p>When to use: - Refactoring sessions with mixed changes - Security fixes requiring precision - Code review responses targeting specific lines - Complex scenarios with unrelated modifications</p> <p>Performance impact: Slower analysis but more precise targeting.</p>"},{"location":"reference/configuration/#-version","title":"<code>--version</code>","text":"<p>Description: Display version information and exit Usage: <code>git-autosquash --version</code> Output: <code>git-autosquash X.Y.Z</code></p>"},{"location":"reference/configuration/#-help-h","title":"<code>--help</code> / <code>-h</code>","text":"<p>Description: Show help message and exit Usage: <code>git-autosquash --help</code></p>"},{"location":"reference/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"reference/configuration/#terminal-control","title":"Terminal Control","text":""},{"location":"reference/configuration/#term","title":"<code>TERM</code>","text":"<p>Purpose: Controls terminal capabilities for TUI rendering Default: System default Common values: - <code>xterm-256color</code> - Full color terminal - <code>xterm</code> - Basic color support - <code>dumb</code> - No color or advanced features</p> <p>Example: <pre><code># Force full color support\nTERM=xterm-256color git-autosquash\n\n# Basic terminal mode for compatibility\nTERM=dumb git-autosquash\n</code></pre></p>"},{"location":"reference/configuration/#no_color","title":"<code>NO_COLOR</code>","text":"<p>Purpose: Disable colored output when set to any value Default: Unset (colors enabled) Specification: Follows NO_COLOR standard</p> <p>Example: <pre><code># Disable all colors\nNO_COLOR=1 git-autosquash\n\n# Enable colors (default behavior)\nunset NO_COLOR\ngit-autosquash\n</code></pre></p>"},{"location":"reference/configuration/#git-integration","title":"Git Integration","text":""},{"location":"reference/configuration/#git_sequence_editor","title":"<code>GIT_SEQUENCE_EDITOR</code>","text":"<p>Purpose: git-autosquash temporarily overrides this during rebase operations Default: Managed automatically by git-autosquash  </p> <p>Don't Set Manually</p> <p>git-autosquash manages this variable automatically during rebase operations. Setting it manually may interfere with the rebase process.</p>"},{"location":"reference/configuration/#editor-visual","title":"<code>EDITOR</code> / <code>VISUAL</code>","text":"<p>Purpose: Editor used by Git for conflict resolution Default: Git's configured editor  </p> <p>Example: <pre><code># Use specific editor for conflict resolution\nEDITOR=vim git-autosquash\n\n# Or set globally\nexport EDITOR=code\ngit-autosquash\n</code></pre></p>"},{"location":"reference/configuration/#debug-and-tracing","title":"Debug and Tracing","text":""},{"location":"reference/configuration/#git_trace","title":"<code>GIT_TRACE</code>","text":"<p>Purpose: Enable Git command tracing for debugging Values: <code>1</code> (basic), <code>2</code> (detailed) Default: Disabled</p> <p>Example: <pre><code># Basic git command tracing\nGIT_TRACE=1 git-autosquash\n\n# Detailed tracing\nGIT_TRACE=2 git-autosquash\n</code></pre></p>"},{"location":"reference/configuration/#git_trace_setup","title":"<code>GIT_TRACE_SETUP</code>","text":"<p>Purpose: Trace Git setup and configuration discovery Values: <code>1</code> (enabled) Default: Disabled</p> <p>Example: <pre><code># Debug git configuration issues\nGIT_TRACE_SETUP=1 git-autosquash\n</code></pre></p>"},{"location":"reference/configuration/#git-configuration","title":"Git Configuration","text":""},{"location":"reference/configuration/#relevant-git-settings","title":"Relevant Git Settings","text":"<p>git-autosquash respects standard Git configuration settings:</p>"},{"location":"reference/configuration/#core-settings","title":"Core Settings","text":"<pre><code># Default editor for conflict resolution\ngit config --global core.editor vim\n\n# Automatic line ending conversion\ngit config --global core.autocrlf true\n\n# Show original diff in conflict markers\ngit config --global merge.conflictstyle diff3\n</code></pre>"},{"location":"reference/configuration/#merge-and-rebase-settings","title":"Merge and Rebase Settings","text":"<pre><code># Merge tool for resolving conflicts\ngit config --global merge.tool vimdiff\n\n# Automatic stashing during rebase (overridden by git-autosquash)\ngit config --global rebase.autoStash true\n\n# Preserve merge commits during rebase\ngit config --global rebase.preserveMerges true\n</code></pre>"},{"location":"reference/configuration/#user-settings","title":"User Settings","text":"<pre><code># Required for commits (used during rebase)\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# GPG signing (if enabled)\ngit config --global user.signingkey YOUR_KEY_ID\ngit config --global commit.gpgsign true\n</code></pre>"},{"location":"reference/configuration/#git-aliases","title":"Git Aliases","text":"<p>Create convenient aliases for git-autosquash:</p> <pre><code># Basic alias\ngit config --global alias.autosquash '!git-autosquash'\n\n# Alias with line-by-line mode\ngit config --global alias.autosquash-precise '!git-autosquash --line-by-line'\n\n# Check if autosquash would be useful\ngit config --global alias.check-autosquash '!bash -c \"if ! git diff --quiet; then echo \\\"Changes detected - consider git-autosquash\\\"; git diff --stat; else echo \\\"No changes to organize\\\"; fi\"'\n\n# Usage after setting aliases\ngit autosquash\ngit autosquash-precise\ngit check-autosquash\n</code></pre>"},{"location":"reference/configuration/#tui-configuration","title":"TUI Configuration","text":""},{"location":"reference/configuration/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>Default keyboard shortcuts in the TUI:</p> Action Key Description Navigate up \u2191 or k Move to previous hunk mapping Navigate down \u2193 or j Move to next hunk mapping Toggle approval Space Approve/reject current mapping Toggle all a Approve or reject all mappings Execute Enter Start rebase with approved changes Cancel Escape or q Abort operation"},{"location":"reference/configuration/#display-configuration","title":"Display Configuration","text":"<p>The TUI adapts to terminal capabilities:</p> <p>Minimum requirements: - Terminal size: 80x24 characters - Basic cursor movement support</p> <p>Enhanced features (when supported): - 256-color support for syntax highlighting - Unicode characters for improved display - Mouse support for navigation</p> <p>Fallback behavior: - Automatically falls back to text-based approval if TUI fails - Graceful degradation on limited terminals - Clear error messages for unsupported environments</p>"},{"location":"reference/configuration/#performance-configuration","title":"Performance Configuration","text":""},{"location":"reference/configuration/#caching","title":"Caching","text":"<p>git-autosquash includes automatic caching for performance:</p> <p>Blame cache: - Commit metadata cached per session - Branch scope filtering cached - File blame results cached</p> <p>Cache location: Memory only (not persisted) Cache lifetime: Single git-autosquash session</p>"},{"location":"reference/configuration/#memory-management","title":"Memory Management","text":"<p>Default limits: - Maximum hunks processed: No limit - Maximum file size analyzed: 10MB per file - Maximum diff size: 100MB total</p> <p>Optimization strategies: - Hunks processed incrementally - Large files analyzed in chunks - Memory released after processing each file</p>"},{"location":"reference/configuration/#shell-integration","title":"Shell Integration","text":""},{"location":"reference/configuration/#tab-completion","title":"Tab Completion","text":"<p>Enable tab completion with <code>argcomplete</code>:</p> <pre><code># Install argcomplete in git-autosquash environment\npipx inject git-autosquash argcomplete\n\n# Enable completion in bash\necho 'eval \"$(register-python-argcomplete git-autosquash)\"' &gt;&gt; ~/.bashrc\n\n# Enable completion in zsh  \necho 'eval \"$(register-python-argcomplete git-autosquash)\"' &gt;&gt; ~/.zshrc\n\n# Reload shell configuration\nsource ~/.bashrc  # or ~/.zshrc\n</code></pre> <p>Completion features: - Option completion: <code>git-autosquash --&lt;TAB&gt;</code> - Shows available options: <code>--line-by-line</code>, <code>--version</code>, <code>--help</code></p>"},{"location":"reference/configuration/#shell-functions","title":"Shell Functions","text":"<p>Useful shell functions for integration:</p> <pre><code># Add to ~/.bashrc or ~/.zshrc\n\n# Check if autosquash would be useful\ncheck-autosquash() {\n    if git diff --quiet; then\n        echo \"No changes to analyze\"\n        return 0\n    fi\n\n    echo \"Changes detected:\"\n    git diff --stat\n    echo\n    echo \"Consider running 'git-autosquash' to organize changes\"\n}\n\n# Safe autosquash with confirmation\nsafe-autosquash() {\n    if git diff --quiet; then\n        echo \"No changes to organize\"\n        return 0\n    fi\n\n    echo \"Current changes:\"\n    git status --short\n    echo\n    read -p \"Run git-autosquash? (y/n): \" -n 1 -r\n    echo\n\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n        git-autosquash \"$@\"\n    else\n        echo \"Cancelled\"\n    fi\n}\n\n# Pre-commit helper\npre-commit-autosquash() {\n    if ! git diff --quiet; then\n        echo \"Uncommitted changes detected\"\n        echo \"Run git-autosquash to organize before committing\"\n        return 1\n    fi\n    echo \"Ready for commit\"\n}\n</code></pre>"},{"location":"reference/configuration/#project-specific-configuration","title":"Project-Specific Configuration","text":""},{"location":"reference/configuration/#gitconfig-per-repository","title":"<code>.gitconfig</code> Per Repository","text":"<p>Configure git-autosquash behavior per repository:</p> <pre><code># In repository root\ncd /path/to/your/project\n\n# Set repository-specific editor\ngit config core.editor \"code --wait\"\n\n# Set repository-specific merge tool\ngit config merge.tool vscode\n\n# Disable GPG signing for this repository\ngit config commit.gpgsign false\n</code></pre>"},{"location":"reference/configuration/#ide-integration-settings","title":"IDE Integration Settings","text":""},{"location":"reference/configuration/#vs-code-settings-vscodesettingsjson","title":"VS Code Settings (<code>.vscode/settings.json</code>)","text":"<pre><code>{\n    \"terminal.integrated.env.linux\": {\n        \"TERM\": \"xterm-256color\"\n    },\n    \"terminal.integrated.env.osx\": {\n        \"TERM\": \"xterm-256color\"  \n    },\n    \"terminal.integrated.env.windows\": {\n        \"TERM\": \"xterm-256color\"\n    },\n    \"git.autofetch\": true,\n    \"git.confirmSync\": false\n}\n</code></pre>"},{"location":"reference/configuration/#intellijpycharm-external-tools","title":"IntelliJ/PyCharm External Tools","text":"<p>Configure git-autosquash as external tool:</p> <p>Program: <code>git-autosquash</code> Arguments: (none for standard mode, <code>--line-by-line</code> for precise mode) Working directory: <code>$ProjectFileDir$</code> Environment variables: <code>TERM=xterm-256color</code></p>"},{"location":"reference/configuration/#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"reference/configuration/#common-configuration-issues","title":"Common Configuration Issues","text":""},{"location":"reference/configuration/#tui-not-working","title":"TUI Not Working","text":"<p>Problem: TUI displays incorrectly or doesn't start</p> <p>Solutions: <pre><code># Check terminal capabilities\necho $TERM\ntput colors\n\n# Try with different terminal setting\nTERM=xterm git-autosquash\n\n# Force basic mode\nTERM=dumb git-autosquash\n</code></pre></p>"},{"location":"reference/configuration/#git-commands-failing","title":"Git Commands Failing","text":"<p>Problem: Git operations fail or behave unexpectedly</p> <p>Solutions: <pre><code># Check git configuration\ngit config --list\n\n# Verify git version\ngit --version  # Requires 2.25+\n\n# Test basic git operations\ngit status\ngit log --oneline -5\n</code></pre></p>"},{"location":"reference/configuration/#performance-issues","title":"Performance Issues","text":"<p>Problem: git-autosquash runs slowly</p> <p>Solutions: <pre><code># Check repository size\ndu -sh .git/\ngit count-objects -v\n\n# Clean up repository\ngit gc --aggressive\n\n# Monitor resource usage\ntime git-autosquash\n</code></pre></p>"},{"location":"reference/configuration/#permission-issues","title":"Permission Issues","text":"<p>Problem: Permission denied when running git-autosquash</p> <p>Solutions: <pre><code># Check installation\nwhich git-autosquash\nls -la $(which git-autosquash)\n\n# Fix permissions\nchmod +x $(which git-autosquash)\n\n# Reinstall if needed\npipx reinstall git-autosquash\n</code></pre></p>"},{"location":"reference/configuration/#environment-variable-debugging","title":"Environment Variable Debugging","text":"<p>Debug environment issues:</p> <pre><code># Check all relevant environment variables\necho \"TERM: $TERM\"\necho \"NO_COLOR: $NO_COLOR\"\necho \"EDITOR: $EDITOR\"\necho \"VISUAL: $VISUAL\"\necho \"GIT_SEQUENCE_EDITOR: $GIT_SEQUENCE_EDITOR\"\necho \"PATH: $PATH\"\n\n# Test git environment\ngit config --list\ngit --exec-path\n</code></pre> <p>For additional troubleshooting, see Troubleshooting Guide.</p>"},{"location":"reference/faq/","title":"Frequently Asked Questions","text":""},{"location":"reference/faq/#general-questions","title":"General Questions","text":""},{"location":"reference/faq/#what-is-git-autosquash","title":"What is git-autosquash?","text":"<p>git-autosquash is a tool that automatically organizes your uncommitted changes by squashing them back into the historical commits where those code sections were last modified. Instead of creating messy \"fix typo\" or \"address review feedback\" commits, it integrates improvements directly into the commits they logically belong to.</p>"},{"location":"reference/faq/#how-is-this-different-from-git-rebase-autosquash","title":"How is this different from <code>git rebase --autosquash</code>?","text":"<p><code>git rebase --autosquash</code> requires you to manually create fixup/squash commits first, then run the rebase. git-autosquash analyzes your working directory changes and automatically determines which historical commits they should be squashed into using git blame analysis.</p>"},{"location":"reference/faq/#is-git-autosquash-safe-to-use","title":"Is git-autosquash safe to use?","text":"<p>Yes, git-autosquash is designed with safety in mind: - It never automatically executes changes without user approval - The TUI shows exactly what will happen before execution - You can abort at any time during the process - All operations are standard git operations that can be undone - It only operates on your local branch, never affecting remote repositories</p>"},{"location":"reference/faq/#what-if-i-make-a-mistake","title":"What if I make a mistake?","text":"<p>You can always undo git-autosquash operations:</p> <pre><code># Find the previous state in reflog\ngit reflog\n\n# Reset to previous state  \ngit reset --hard HEAD@{N}  # Replace N with appropriate entry\n\n# Or create backup branch before running\ngit branch backup-before-autosquash\ngit-autosquash\n# If needed: git reset --hard backup-before-autosquash\n</code></pre>"},{"location":"reference/faq/#installation-and-setup","title":"Installation and Setup","text":""},{"location":"reference/faq/#how-do-i-install-git-autosquash","title":"How do I install git-autosquash?","text":"<p>The recommended installation method is using pipx:</p> <pre><code>pipx install git-autosquash\n</code></pre> <p>For other installation methods, see the Getting Started Guide.</p>"},{"location":"reference/faq/#can-i-use-git-autosquash-without-pipx","title":"Can I use git-autosquash without pipx?","text":"<p>Yes, you can install with regular pip:</p> <pre><code>pip install git-autosquash\n</code></pre> <p>However, pipx is recommended because it isolates git-autosquash in its own environment, preventing conflicts with other Python packages.</p>"},{"location":"reference/faq/#how-do-i-update-git-autosquash","title":"How do I update git-autosquash?","text":"<pre><code># With pipx (recommended)\npipx upgrade git-autosquash\n\n# With pip\npip install --upgrade git-autosquash\n</code></pre>"},{"location":"reference/faq/#does-git-autosquash-work-on-windows","title":"Does git-autosquash work on Windows?","text":"<p>Yes, git-autosquash works on Windows, macOS, and Linux. However, Windows users may need: - A terminal that supports ANSI color codes (Windows Terminal, PowerShell 7+) - Git for Windows or similar git installation - Python 3.9 or later</p>"},{"location":"reference/faq/#usage-questions","title":"Usage Questions","text":""},{"location":"reference/faq/#when-should-i-use-git-autosquash","title":"When should I use git-autosquash?","text":"<p>git-autosquash is most useful when: - You fix bugs while working on new features - You address code review feedback affecting multiple commits - You make improvements to existing code during development - You want to maintain clean, logical commit history - You're refactoring and want improvements integrated with original implementations</p>"},{"location":"reference/faq/#when-should-i-not-use-git-autosquash","title":"When should I NOT use git-autosquash?","text":"<p>Avoid git-autosquash when: - Working on main/master branch directly (use feature branches) - Changes are truly independent and deserve their own commits - You're not familiar with git rebase and conflict resolution - Working on shared branches without team coordination - Repository is in unusual state (detached HEAD, corrupt history)</p>"},{"location":"reference/faq/#whats-the-difference-between-standard-and-line-by-line-mode","title":"What's the difference between standard and line-by-line mode?","text":"<p>Standard mode (<code>git-autosquash</code>): - Uses git's default hunk boundaries - Faster analysis - Good for most scenarios - Groups related changes together</p> <p>Line-by-line mode (<code>git-autosquash --line-by-line</code>): - Analyzes each changed line individually - More precise targeting - Slower but more granular control - Better for complex refactoring or mixed changes</p>"},{"location":"reference/faq/#how-does-git-autosquash-decide-where-changes-should-go","title":"How does git-autosquash decide where changes should go?","text":"<p>git-autosquash uses git blame to analyze who last modified each line of code. It then:</p> <ol> <li>Counts frequency: How many lines in each hunk were last modified by each commit</li> <li>Selects target: Chooses the commit that modified the most lines (frequency-first)</li> <li>Breaks ties: If multiple commits have same frequency, chooses the more recent one</li> <li>Filters scope: Only considers commits on the current branch back to the merge-base with main</li> </ol>"},{"location":"reference/faq/#what-does-the-confidence-level-mean","title":"What does the confidence level mean?","text":"<p>Confidence indicates how certain git-autosquash is about the target:</p> <ul> <li>High (Green): All or most lines blame to the same commit - very likely correct</li> <li>Medium (Yellow): Majority of lines blame to target commit - probably correct</li> <li>Low (Red): Mixed blame results - might be incorrect, review carefully</li> </ul> <p>Low confidence often means changes affect code from multiple commits and might be better as a new commit.</p>"},{"location":"reference/faq/#technical-questions","title":"Technical Questions","text":""},{"location":"reference/faq/#can-git-autosquash-handle-merge-conflicts","title":"Can git-autosquash handle merge conflicts?","text":"<p>Yes, but conflicts require manual resolution. When conflicts occur:</p> <ol> <li>git-autosquash pauses and shows conflicted files</li> <li>You resolve conflicts manually in your editor</li> <li>Stage resolved files with <code>git add</code></li> <li>Continue with <code>git rebase --continue</code></li> <li>git-autosquash completes the remaining operations</li> </ol> <p>For complex conflicts, you can abort with <code>git rebase --abort</code> and try a different approach.</p>"},{"location":"reference/faq/#does-git-autosquash-work-with-large-repositories","title":"Does git-autosquash work with large repositories?","text":"<p>Yes, git-autosquash is designed to work efficiently with large repositories:</p> <ul> <li>Blame analysis is cached during each session</li> <li>Files are processed incrementally to manage memory</li> <li>Performance optimizations for repositories with extensive history</li> <li>Reasonable performance even with thousands of commits</li> </ul> <p>For very large repositories, the first run may be slower as caches are built.</p>"},{"location":"reference/faq/#can-i-use-git-autosquash-on-shared-branches","title":"Can I use git-autosquash on shared branches?","text":"<p>Use caution with shared branches:</p> <ol> <li>Coordinate with team: Let others know you'll be rebasing</li> <li>Force push required: After git-autosquash, you need <code>git push --force-with-lease</code></li> <li>Team must update: Others need to rebase their local copies</li> </ol> <p>It's safer to use git-autosquash on personal feature branches before sharing.</p>"},{"location":"reference/faq/#what-git-version-is-required","title":"What Git version is required?","text":"<p>git-autosquash requires Git 2.25 or later for: - Modern <code>git diff</code> output format - Reliable <code>git blame</code> behavior - Interactive rebase features - Proper conflict handling</p>"},{"location":"reference/faq/#does-git-autosquash-modify-my-git-configuration","title":"Does git-autosquash modify my git configuration?","text":"<p>No, git-autosquash never modifies your permanent git configuration. It may temporarily set environment variables during rebase operations, but these don't persist after the session ends.</p>"},{"location":"reference/faq/#workflow-questions","title":"Workflow Questions","text":""},{"location":"reference/faq/#how-do-i-integrate-git-autosquash-into-my-development-workflow","title":"How do I integrate git-autosquash into my development workflow?","text":"<p>Common integration patterns:</p> <p>Before committing: <pre><code># Make changes throughout the day\ngit-autosquash  # Organize changes\ngit commit -m \"Add user authentication feature\"\n</code></pre></p> <p>Before creating pull request: <pre><code># Clean up branch history\ngit-autosquash\ngit push --force-with-lease origin feature-branch\n</code></pre></p> <p>After addressing code review: <pre><code># Make review changes\ngit-autosquash  # Distribute fixes to appropriate commits\ngit push --force-with-lease\n</code></pre></p>"},{"location":"reference/faq/#can-i-use-git-autosquash-with-pre-commit-hooks","title":"Can I use git-autosquash with pre-commit hooks?","text":"<p>Yes, you can integrate with pre-commit hooks, but be careful about automation:</p> <pre><code>#!/bin/bash\n# .git/hooks/pre-commit\nif ! git diff --quiet; then\n    echo \"Uncommitted changes detected.\"\n    echo \"Consider running 'git-autosquash' first.\"\n    read -p \"Continue with commit? (y/n): \" -n 1 -r\n    echo\n    if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n        exit 1\n    fi\nfi\n</code></pre> <p>Avoid automatically running git-autosquash in hooks - the interactive nature requires user decision-making.</p>"},{"location":"reference/faq/#how-do-i-handle-file-renames","title":"How do I handle file renames?","text":"<p>git-autosquash handles file renames automatically when git detects them. Ensure renames are properly staged:</p> <pre><code># Git automatically detects renames when files are &gt;50% similar\ngit add old_file.py new_file.py\ngit status  # Should show \"renamed: old_file.py -&gt; new_file.py\"\ngit-autosquash\n</code></pre> <p>If git doesn't detect the rename, you may need to handle it manually before running git-autosquash.</p>"},{"location":"reference/faq/#error-and-troubleshooting","title":"Error and Troubleshooting","text":""},{"location":"reference/faq/#why-do-i-get-no-target-commits-found","title":"Why do I get \"No target commits found\"?","text":"<p>This happens when: - All changes are in new files (expected - no history to squash into) - Changes are outside the branch scope (before merge-base with main) - Git blame can't find clear ownership (e.g., heavily refactored code)</p> <p>This is often normal behavior. New functionality should remain as new commits.</p>"},{"location":"reference/faq/#the-tui-doesnt-work-on-my-system","title":"The TUI doesn't work on my system","text":"<p>Try these solutions:</p> <pre><code># Check terminal capabilities\necho $TERM\ntput colors\n\n# Try different terminal setting\nTERM=xterm-256color git-autosquash\n\n# Force basic mode\nTERM=dumb git-autosquash\n\n# Disable colors\nNO_COLOR=1 git-autosquash\n</code></pre> <p>The TUI requires a terminal with basic cursor movement support. It automatically falls back to text-based prompts if the TUI fails.</p>"},{"location":"reference/faq/#git-autosquash-is-slow-on-my-repository","title":"git-autosquash is slow on my repository","text":"<p>Performance optimization steps:</p> <pre><code># Clean up repository\ngit gc --aggressive\ngit prune\n\n# Check repository size\ndu -sh .git/\n\n# Try line-by-line for better precision (may be faster for complex changes)\ngit-autosquash --line-by-line\n\n# Process changes in smaller batches\ngit stash push -m \"batch2\" -- large_module/\ngit-autosquash  # Process remaining\ngit stash pop\ngit-autosquash  # Process batch2\n</code></pre>"},{"location":"reference/faq/#can-i-customize-the-tui-colors-or-shortcuts","title":"Can I customize the TUI colors or shortcuts?","text":"<p>Currently, git-autosquash uses standard colors and shortcuts that aren't customizable. However:</p> <ul> <li>Colors respect the <code>NO_COLOR</code> environment variable</li> <li>Terminal capabilities are automatically detected</li> <li>Shortcuts follow vim-like conventions (j/k for navigation)</li> </ul> <p>Future versions may add more customization options.</p>"},{"location":"reference/faq/#comparison-questions","title":"Comparison Questions","text":""},{"location":"reference/faq/#how-does-git-autosquash-compare-to-other-git-tools","title":"How does git-autosquash compare to other Git tools?","text":"<p>vs <code>git rebase -i</code>: - git-autosquash automatically determines what should be squashed - No manual editing of rebase todo lists - Uses blame analysis instead of manual decision-making</p> <p>vs <code>git commit --fixup</code>: - No need to identify target commits manually - Works on working directory changes, not just commits - Handles multiple targets automatically</p> <p>vs <code>git absorb</code>: - Similar concept but different implementation - git-autosquash provides interactive TUI for approval - Different algorithms for target selection</p>"},{"location":"reference/faq/#should-i-use-git-autosquash-or-traditional-git-rebase","title":"Should I use git-autosquash or traditional git rebase?","text":"<p>Use git-autosquash when: - You want intelligent automation for common squash scenarios - You frequently fix bugs in existing commits during development - You want to maintain clean history without manual analysis</p> <p>Use traditional rebase when: - You need complete control over commit organization - You're doing complex history manipulation - You're comfortable with manual interactive rebase</p> <p>They're complementary tools - you can use both in your workflow as appropriate.</p> <p>For more specific questions, check the Troubleshooting Guide or report issues at https://github.com/andrewleech/git-autosquash/issues.</p>"},{"location":"technical/api-reference/","title":"API Reference","text":"<p>This section provides detailed API documentation for git-autosquash's core components. The documentation is auto-generated from docstrings to ensure accuracy.</p>"},{"location":"technical/api-reference/#core-components","title":"Core Components","text":""},{"location":"technical/api-reference/#gitops","title":"GitOps","text":"<p>The central interface for all Git operations with proper error handling.</p>"},{"location":"technical/api-reference/#git_autosquash.git_ops","title":"<code>git_autosquash.git_ops</code>","text":"<p>Git operations module for repository analysis and commands.</p>"},{"location":"technical/api-reference/#git_autosquash.git_ops-classes","title":"Classes","text":""},{"location":"technical/api-reference/#git_autosquash.git_ops.GitOps","title":"<code>GitOps</code>","text":"<p>Handles git operations for repository analysis and validation.</p> Source code in <code>src/git_autosquash/git_ops.py</code> <pre><code>class GitOps:\n    \"\"\"Handles git operations for repository analysis and validation.\"\"\"\n\n    def __init__(self, repo_path: Optional[Path] = None) -&gt; None:\n        \"\"\"Initialize GitOps with optional repository path.\n\n        Args:\n            repo_path: Path to git repository. Defaults to current directory.\n        \"\"\"\n        self.repo_path = repo_path if repo_path is not None else Path.cwd()\n\n    def _run_git_command(self, *args: str) -&gt; tuple[bool, str]:\n        \"\"\"Run a git command and return success status and output.\n\n        Args:\n            *args: Git command arguments\n\n        Returns:\n            Tuple of (success, output/error_message)\n        \"\"\"\n        try:\n            result = subprocess.run(\n                [\"git\", *args],\n                cwd=self.repo_path,\n                capture_output=True,\n                text=True,\n                check=False,\n            )\n            return (\n                result.returncode == 0,\n                result.stdout.strip() or result.stderr.strip(),\n            )\n        except (subprocess.SubprocessError, FileNotFoundError) as e:\n            return False, f\"Git command failed: {e}\"\n\n    def is_git_repo(self) -&gt; bool:\n        \"\"\"Check if current directory is inside a git repository.\n\n        Returns:\n            True if in a git repository, False otherwise\n        \"\"\"\n        success, _ = self._run_git_command(\"rev-parse\", \"--git-dir\")\n        return success\n\n    def get_current_branch(self) -&gt; Optional[str]:\n        \"\"\"Get the current branch name.\n\n        Returns:\n            Branch name if on a branch, None if detached HEAD\n        \"\"\"\n        success, output = self._run_git_command(\"symbolic-ref\", \"--short\", \"HEAD\")\n        return output if success else None\n\n    def get_merge_base_with_main(self, current_branch: str) -&gt; Optional[str]:\n        \"\"\"Find merge base with main/master branch.\n\n        Args:\n            current_branch: Current branch name\n\n        Returns:\n            Commit hash of merge base, or None if not found\n        \"\"\"\n        # Try merge-base directly, let git handle missing refs\n        for main_branch in [\"main\", \"master\"]:\n            if main_branch == current_branch:\n                continue\n\n            success, output = self._run_git_command(\n                \"merge-base\", main_branch, current_branch\n            )\n            if success:\n                return output\n\n        return None\n\n    def get_working_tree_status(self) -&gt; dict[str, bool]:\n        \"\"\"Get working tree status information.\n\n        Returns:\n            Dictionary with status flags: has_staged, has_unstaged, is_clean\n        \"\"\"\n        success, output = self._run_git_command(\"status\", \"--porcelain\")\n        if not success:\n            return {\"has_staged\": False, \"has_unstaged\": False, \"is_clean\": True}\n\n        lines = output.split(\"\\n\") if output else []\n        has_staged = any(line and line[0] not in \"? \" for line in lines)\n        has_unstaged = any(line and line[1] not in \" \" for line in lines)\n        is_clean = not lines or all(not line.strip() for line in lines)\n\n        return {\n            \"has_staged\": has_staged,\n            \"has_unstaged\": has_unstaged,\n            \"is_clean\": is_clean,\n        }\n\n    def has_commits_since_merge_base(self, merge_base: str) -&gt; bool:\n        \"\"\"Check if there are commits on current branch since merge base.\n\n        Args:\n            merge_base: Merge base commit hash\n\n        Returns:\n            True if there are commits to work with\n        \"\"\"\n        success, output = self._run_git_command(\n            \"rev-list\", \"--count\", f\"{merge_base}..HEAD\"\n        )\n        if not success:\n            return False\n\n        try:\n            count = int(output)\n            return count &gt; 0\n        except ValueError:\n            return False\n\n    def run_git_command(\n        self, args: list[str], env: dict[str, str] | None = None\n    ) -&gt; subprocess.CompletedProcess[str]:\n        \"\"\"Run a git command and return the complete result.\n\n        Args:\n            args: Git command arguments (without 'git')\n            env: Optional environment variables\n\n        Returns:\n            CompletedProcess with stdout, stderr, and return code\n        \"\"\"\n        cmd = [\"git\"] + args\n        try:\n            result = subprocess.run(\n                cmd,\n                cwd=self.repo_path,\n                capture_output=True,\n                text=True,\n                env=env,\n                timeout=300,  # 5 minute timeout\n            )\n            return result\n        except subprocess.TimeoutExpired as e:\n            return subprocess.CompletedProcess(\n                args=cmd,\n                returncode=124,  # timeout exit code\n                stdout=e.stdout.decode() if e.stdout else \"\",\n                stderr=f\"Command timed out after 300 seconds: {e}\",\n            )\n        except Exception as e:\n            return subprocess.CompletedProcess(\n                args=cmd,\n                returncode=1,\n                stdout=\"\",\n                stderr=str(e),\n            )\n</code></pre> Functions\u00b6 <code>__init__(repo_path: Optional[Path] = None) -&gt; None</code> \u00b6 <p>Initialize GitOps with optional repository path.</p> <p>Parameters:</p> Name Type Description Default <code>repo_path</code> <code>Optional[Path]</code> <p>Path to git repository. Defaults to current directory.</p> <code>None</code> Source code in <code>src/git_autosquash/git_ops.py</code> <pre><code>def __init__(self, repo_path: Optional[Path] = None) -&gt; None:\n    \"\"\"Initialize GitOps with optional repository path.\n\n    Args:\n        repo_path: Path to git repository. Defaults to current directory.\n    \"\"\"\n    self.repo_path = repo_path if repo_path is not None else Path.cwd()\n</code></pre> <code>is_git_repo() -&gt; bool</code> \u00b6 <p>Check if current directory is inside a git repository.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if in a git repository, False otherwise</p> Source code in <code>src/git_autosquash/git_ops.py</code> <pre><code>def is_git_repo(self) -&gt; bool:\n    \"\"\"Check if current directory is inside a git repository.\n\n    Returns:\n        True if in a git repository, False otherwise\n    \"\"\"\n    success, _ = self._run_git_command(\"rev-parse\", \"--git-dir\")\n    return success\n</code></pre> <code>get_current_branch() -&gt; Optional[str]</code> \u00b6 <p>Get the current branch name.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Branch name if on a branch, None if detached HEAD</p> Source code in <code>src/git_autosquash/git_ops.py</code> <pre><code>def get_current_branch(self) -&gt; Optional[str]:\n    \"\"\"Get the current branch name.\n\n    Returns:\n        Branch name if on a branch, None if detached HEAD\n    \"\"\"\n    success, output = self._run_git_command(\"symbolic-ref\", \"--short\", \"HEAD\")\n    return output if success else None\n</code></pre> <code>get_merge_base_with_main(current_branch: str) -&gt; Optional[str]</code> \u00b6 <p>Find merge base with main/master branch.</p> <p>Parameters:</p> Name Type Description Default <code>current_branch</code> <code>str</code> <p>Current branch name</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Commit hash of merge base, or None if not found</p> Source code in <code>src/git_autosquash/git_ops.py</code> <pre><code>def get_merge_base_with_main(self, current_branch: str) -&gt; Optional[str]:\n    \"\"\"Find merge base with main/master branch.\n\n    Args:\n        current_branch: Current branch name\n\n    Returns:\n        Commit hash of merge base, or None if not found\n    \"\"\"\n    # Try merge-base directly, let git handle missing refs\n    for main_branch in [\"main\", \"master\"]:\n        if main_branch == current_branch:\n            continue\n\n        success, output = self._run_git_command(\n            \"merge-base\", main_branch, current_branch\n        )\n        if success:\n            return output\n\n    return None\n</code></pre> <code>get_working_tree_status() -&gt; dict[str, bool]</code> \u00b6 <p>Get working tree status information.</p> <p>Returns:</p> Type Description <code>dict[str, bool]</code> <p>Dictionary with status flags: has_staged, has_unstaged, is_clean</p> Source code in <code>src/git_autosquash/git_ops.py</code> <pre><code>def get_working_tree_status(self) -&gt; dict[str, bool]:\n    \"\"\"Get working tree status information.\n\n    Returns:\n        Dictionary with status flags: has_staged, has_unstaged, is_clean\n    \"\"\"\n    success, output = self._run_git_command(\"status\", \"--porcelain\")\n    if not success:\n        return {\"has_staged\": False, \"has_unstaged\": False, \"is_clean\": True}\n\n    lines = output.split(\"\\n\") if output else []\n    has_staged = any(line and line[0] not in \"? \" for line in lines)\n    has_unstaged = any(line and line[1] not in \" \" for line in lines)\n    is_clean = not lines or all(not line.strip() for line in lines)\n\n    return {\n        \"has_staged\": has_staged,\n        \"has_unstaged\": has_unstaged,\n        \"is_clean\": is_clean,\n    }\n</code></pre> <code>has_commits_since_merge_base(merge_base: str) -&gt; bool</code> \u00b6 <p>Check if there are commits on current branch since merge base.</p> <p>Parameters:</p> Name Type Description Default <code>merge_base</code> <code>str</code> <p>Merge base commit hash</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are commits to work with</p> Source code in <code>src/git_autosquash/git_ops.py</code> <pre><code>def has_commits_since_merge_base(self, merge_base: str) -&gt; bool:\n    \"\"\"Check if there are commits on current branch since merge base.\n\n    Args:\n        merge_base: Merge base commit hash\n\n    Returns:\n        True if there are commits to work with\n    \"\"\"\n    success, output = self._run_git_command(\n        \"rev-list\", \"--count\", f\"{merge_base}..HEAD\"\n    )\n    if not success:\n        return False\n\n    try:\n        count = int(output)\n        return count &gt; 0\n    except ValueError:\n        return False\n</code></pre> <code>run_git_command(args: list[str], env: dict[str, str] | None = None) -&gt; subprocess.CompletedProcess[str]</code> \u00b6 <p>Run a git command and return the complete result.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>Git command arguments (without 'git')</p> required <code>env</code> <code>dict[str, str] | None</code> <p>Optional environment variables</p> <code>None</code> <p>Returns:</p> Type Description <code>CompletedProcess[str]</code> <p>CompletedProcess with stdout, stderr, and return code</p> Source code in <code>src/git_autosquash/git_ops.py</code> <pre><code>def run_git_command(\n    self, args: list[str], env: dict[str, str] | None = None\n) -&gt; subprocess.CompletedProcess[str]:\n    \"\"\"Run a git command and return the complete result.\n\n    Args:\n        args: Git command arguments (without 'git')\n        env: Optional environment variables\n\n    Returns:\n        CompletedProcess with stdout, stderr, and return code\n    \"\"\"\n    cmd = [\"git\"] + args\n    try:\n        result = subprocess.run(\n            cmd,\n            cwd=self.repo_path,\n            capture_output=True,\n            text=True,\n            env=env,\n            timeout=300,  # 5 minute timeout\n        )\n        return result\n    except subprocess.TimeoutExpired as e:\n        return subprocess.CompletedProcess(\n            args=cmd,\n            returncode=124,  # timeout exit code\n            stdout=e.stdout.decode() if e.stdout else \"\",\n            stderr=f\"Command timed out after 300 seconds: {e}\",\n        )\n    except Exception as e:\n        return subprocess.CompletedProcess(\n            args=cmd,\n            returncode=1,\n            stdout=\"\",\n            stderr=str(e),\n        )\n</code></pre>"},{"location":"technical/api-reference/#hunkparser","title":"HunkParser","text":"<p>Parses Git diff output into structured hunk objects.</p>"},{"location":"technical/api-reference/#git_autosquash.hunk_parser","title":"<code>git_autosquash.hunk_parser</code>","text":"<p>Diff parsing and hunk splitting module.</p>"},{"location":"technical/api-reference/#git_autosquash.hunk_parser-classes","title":"Classes","text":""},{"location":"technical/api-reference/#git_autosquash.hunk_parser.DiffHunk","title":"<code>DiffHunk</code>  <code>dataclass</code>","text":"<p>Represents a single diff hunk with metadata.</p> Source code in <code>src/git_autosquash/hunk_parser.py</code> <pre><code>@dataclass\nclass DiffHunk:\n    \"\"\"Represents a single diff hunk with metadata.\"\"\"\n\n    file_path: str\n    old_start: int\n    old_count: int\n    new_start: int\n    new_count: int\n    lines: List[str]\n    context_before: List[str]\n    context_after: List[str]\n\n    @property\n    def affected_lines(self) -&gt; range:\n        \"\"\"Get the range of lines affected in the new file.\"\"\"\n        return range(self.new_start, self.new_start + self.new_count)\n\n    @property\n    def has_additions(self) -&gt; bool:\n        \"\"\"Check if hunk contains added lines.\"\"\"\n        return any(\n            line.startswith(\"+\") and not line.startswith(\"+++\") for line in self.lines\n        )\n\n    @property\n    def has_deletions(self) -&gt; bool:\n        \"\"\"Check if hunk contains deleted lines.\"\"\"\n        return any(\n            line.startswith(\"-\") and not line.startswith(\"---\") for line in self.lines\n        )\n</code></pre> Attributes\u00b6 <code>affected_lines: range</code> <code>property</code> \u00b6 <p>Get the range of lines affected in the new file.</p> <code>has_additions: bool</code> <code>property</code> \u00b6 <p>Check if hunk contains added lines.</p> <code>has_deletions: bool</code> <code>property</code> \u00b6 <p>Check if hunk contains deleted lines.</p>"},{"location":"technical/api-reference/#git_autosquash.hunk_parser.HunkParser","title":"<code>HunkParser</code>","text":"<p>Parses git diff output into structured hunks.</p> Source code in <code>src/git_autosquash/hunk_parser.py</code> <pre><code>class HunkParser:\n    \"\"\"Parses git diff output into structured hunks.\"\"\"\n\n    def __init__(self, git_ops: GitOps) -&gt; None:\n        \"\"\"Initialize HunkParser with GitOps instance.\n\n        Args:\n            git_ops: GitOps instance for running git commands\n        \"\"\"\n        self.git_ops = git_ops\n\n    def get_diff_hunks(self, line_by_line: bool = False) -&gt; List[DiffHunk]:\n        \"\"\"Extract hunks from current working tree or staged changes.\n\n        Args:\n            line_by_line: If True, split hunks line-by-line for finer granularity\n\n        Returns:\n            List of DiffHunk objects representing changes\n        \"\"\"\n        # Get working tree status to determine what to diff\n        status = self.git_ops.get_working_tree_status()\n\n        if status[\"is_clean\"]:\n            # Working tree is clean, diff HEAD~1 to get previous commit changes\n            success, diff_output = self.git_ops._run_git_command(\n                \"show\", \"--format=\", \"HEAD\"\n            )\n        elif status[\"has_staged\"] and not status[\"has_unstaged\"]:\n            # Only staged changes, diff them\n            success, diff_output = self.git_ops._run_git_command(\"diff\", \"--cached\")\n        elif not status[\"has_staged\"] and status[\"has_unstaged\"]:\n            # Only unstaged changes, diff them\n            success, diff_output = self.git_ops._run_git_command(\"diff\")\n        else:\n            # Mixed changes, diff all (staged + unstaged)\n            success, diff_output = self.git_ops._run_git_command(\"diff\", \"HEAD\")\n\n        if not success:\n            return []\n\n        hunks = self._parse_diff_output(diff_output)\n\n        if line_by_line:\n            hunks = self._split_hunks_line_by_line(hunks)\n\n        return hunks\n\n    def _parse_diff_output(self, diff_output: str) -&gt; List[DiffHunk]:\n        \"\"\"Parse git diff output into DiffHunk objects.\n\n        Args:\n            diff_output: Raw git diff output\n\n        Returns:\n            List of parsed DiffHunk objects\n        \"\"\"\n        if not diff_output.strip():\n            return []\n\n        hunks = []\n        lines = diff_output.split(\"\\n\")\n        current_file = None\n        i = 0\n\n        while i &lt; len(lines):\n            line = lines[i]\n\n            # Track current file being processed\n            if line.startswith(\"diff --git\"):\n                # Extract file path from \"diff --git a/path b/path\"\n                match = re.match(r\"diff --git a/(.*) b/(.*)\", line)\n                if match:\n                    current_file = match.group(2)  # Use the new file path\n\n            elif line.startswith(\"@@\") and current_file:\n                # Parse hunk header: @@ -old_start,old_count +new_start,new_count @@\n                hunk_match = re.match(\n                    r\"@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@\", line\n                )\n                if hunk_match:\n                    old_start = int(hunk_match.group(1))\n                    old_count = int(hunk_match.group(2) or 1)\n                    new_start = int(hunk_match.group(3))\n                    new_count = int(hunk_match.group(4) or 1)\n\n                    # Collect hunk lines\n                    hunk_lines = [line]  # Include the @@ line\n                    i += 1\n\n                    while (\n                        i &lt; len(lines)\n                        and not lines[i].startswith(\"@@\")\n                        and not lines[i].startswith(\"diff --git\")\n                    ):\n                        hunk_lines.append(\n                            lines[i]\n                        )  # Preserve all lines including empty ones\n                        i += 1\n\n                    # Create DiffHunk object\n                    hunk = DiffHunk(\n                        file_path=current_file,\n                        old_start=old_start,\n                        old_count=old_count,\n                        new_start=new_start,\n                        new_count=new_count,\n                        lines=hunk_lines,\n                        context_before=[],\n                        context_after=[],\n                    )\n\n                    hunks.append(hunk)\n                    continue  # Don't increment i, it was already incremented in the loop\n\n            i += 1\n\n        return hunks\n\n    def _split_hunks_line_by_line(self, hunks: List[DiffHunk]) -&gt; List[DiffHunk]:\n        \"\"\"Split hunks into line-by-line changes for finer granularity.\n\n        Args:\n            hunks: List of original hunks to split\n\n        Returns:\n            List of line-by-line split hunks\n        \"\"\"\n        split_hunks = []\n\n        for hunk in hunks:\n            # If hunk is already small (single line change), keep as-is\n            change_lines = [\n                line for line in hunk.lines[1:] if line.startswith((\"+\", \"-\"))\n            ]\n            if len(change_lines) &lt;= 1:\n                split_hunks.append(hunk)\n                continue\n\n            # Split into individual line changes\n            current_old_line = hunk.old_start\n            current_new_line = hunk.new_start\n\n            i = 1  # Skip the @@ header line\n            while i &lt; len(hunk.lines):\n                line = hunk.lines[i]\n\n                if line.startswith(\"+\"):\n                    # Addition: create a single-line hunk with proper line counts\n                    header = f\"@@ -{current_old_line},0 +{current_new_line},1 @@\"\n                    new_hunk = DiffHunk(\n                        file_path=hunk.file_path,\n                        old_start=current_old_line,\n                        old_count=0,\n                        new_start=current_new_line,\n                        new_count=1,\n                        lines=[header, line],\n                        context_before=[],\n                        context_after=[],\n                    )\n                    split_hunks.append(new_hunk)\n                    current_new_line += 1\n\n                elif line.startswith(\"-\"):\n                    # Deletion: create a single-line hunk with proper line counts\n                    header = f\"@@ -{current_old_line},1 +{current_new_line},0 @@\"\n                    new_hunk = DiffHunk(\n                        file_path=hunk.file_path,\n                        old_start=current_old_line,\n                        old_count=1,\n                        new_start=current_new_line,\n                        new_count=0,\n                        lines=[header, line],\n                        context_before=[],\n                        context_after=[],\n                    )\n                    split_hunks.append(new_hunk)\n                    current_old_line += 1\n\n                else:\n                    # Context line: advance both pointers\n                    current_old_line += 1\n                    current_new_line += 1\n\n                i += 1\n\n        return split_hunks\n\n    def get_file_content_at_lines(\n        self, file_path: str, start_line: int, end_line: int\n    ) -&gt; List[str]:\n        \"\"\"Get file content at specific line range for context.\n\n        Args:\n            file_path: Path to the file\n            start_line: Starting line number (1-based)\n            end_line: Ending line number (1-based, inclusive)\n\n        Returns:\n            List of lines from the file, empty list on error\n        \"\"\"\n        # Use git show with line range for efficiency on large files\n        success, output = self.git_ops._run_git_command(\"show\", f\"HEAD:{file_path}\")\n\n        if not success:\n            return []\n\n        try:\n            lines = output.split(\"\\n\")\n            # Convert to 0-based indexing and ensure bounds\n            start_idx = max(0, start_line - 1)\n            end_idx = min(len(lines), end_line)\n\n            return lines[start_idx:end_idx]\n        except Exception:\n            # Handle any parsing errors gracefully\n            return []\n</code></pre> Functions\u00b6 <code>__init__(git_ops: GitOps) -&gt; None</code> \u00b6 <p>Initialize HunkParser with GitOps instance.</p> <p>Parameters:</p> Name Type Description Default <code>git_ops</code> <code>GitOps</code> <p>GitOps instance for running git commands</p> required Source code in <code>src/git_autosquash/hunk_parser.py</code> <pre><code>def __init__(self, git_ops: GitOps) -&gt; None:\n    \"\"\"Initialize HunkParser with GitOps instance.\n\n    Args:\n        git_ops: GitOps instance for running git commands\n    \"\"\"\n    self.git_ops = git_ops\n</code></pre> <code>get_diff_hunks(line_by_line: bool = False) -&gt; List[DiffHunk]</code> \u00b6 <p>Extract hunks from current working tree or staged changes.</p> <p>Parameters:</p> Name Type Description Default <code>line_by_line</code> <code>bool</code> <p>If True, split hunks line-by-line for finer granularity</p> <code>False</code> <p>Returns:</p> Type Description <code>List[DiffHunk]</code> <p>List of DiffHunk objects representing changes</p> Source code in <code>src/git_autosquash/hunk_parser.py</code> <pre><code>def get_diff_hunks(self, line_by_line: bool = False) -&gt; List[DiffHunk]:\n    \"\"\"Extract hunks from current working tree or staged changes.\n\n    Args:\n        line_by_line: If True, split hunks line-by-line for finer granularity\n\n    Returns:\n        List of DiffHunk objects representing changes\n    \"\"\"\n    # Get working tree status to determine what to diff\n    status = self.git_ops.get_working_tree_status()\n\n    if status[\"is_clean\"]:\n        # Working tree is clean, diff HEAD~1 to get previous commit changes\n        success, diff_output = self.git_ops._run_git_command(\n            \"show\", \"--format=\", \"HEAD\"\n        )\n    elif status[\"has_staged\"] and not status[\"has_unstaged\"]:\n        # Only staged changes, diff them\n        success, diff_output = self.git_ops._run_git_command(\"diff\", \"--cached\")\n    elif not status[\"has_staged\"] and status[\"has_unstaged\"]:\n        # Only unstaged changes, diff them\n        success, diff_output = self.git_ops._run_git_command(\"diff\")\n    else:\n        # Mixed changes, diff all (staged + unstaged)\n        success, diff_output = self.git_ops._run_git_command(\"diff\", \"HEAD\")\n\n    if not success:\n        return []\n\n    hunks = self._parse_diff_output(diff_output)\n\n    if line_by_line:\n        hunks = self._split_hunks_line_by_line(hunks)\n\n    return hunks\n</code></pre> <code>get_file_content_at_lines(file_path: str, start_line: int, end_line: int) -&gt; List[str]</code> \u00b6 <p>Get file content at specific line range for context.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file</p> required <code>start_line</code> <code>int</code> <p>Starting line number (1-based)</p> required <code>end_line</code> <code>int</code> <p>Ending line number (1-based, inclusive)</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of lines from the file, empty list on error</p> Source code in <code>src/git_autosquash/hunk_parser.py</code> <pre><code>def get_file_content_at_lines(\n    self, file_path: str, start_line: int, end_line: int\n) -&gt; List[str]:\n    \"\"\"Get file content at specific line range for context.\n\n    Args:\n        file_path: Path to the file\n        start_line: Starting line number (1-based)\n        end_line: Ending line number (1-based, inclusive)\n\n    Returns:\n        List of lines from the file, empty list on error\n    \"\"\"\n    # Use git show with line range for efficiency on large files\n    success, output = self.git_ops._run_git_command(\"show\", f\"HEAD:{file_path}\")\n\n    if not success:\n        return []\n\n    try:\n        lines = output.split(\"\\n\")\n        # Convert to 0-based indexing and ensure bounds\n        start_idx = max(0, start_line - 1)\n        end_idx = min(len(lines), end_line)\n\n        return lines[start_idx:end_idx]\n    except Exception:\n        # Handle any parsing errors gracefully\n        return []\n</code></pre>"},{"location":"technical/api-reference/#blameanalyzer","title":"BlameAnalyzer","text":"<p>Analyzes Git blame information to determine target commits for hunks.</p>"},{"location":"technical/api-reference/#git_autosquash.blame_analyzer","title":"<code>git_autosquash.blame_analyzer</code>","text":"<p>Git blame analysis and target commit resolution.</p>"},{"location":"technical/api-reference/#git_autosquash.blame_analyzer-classes","title":"Classes","text":""},{"location":"technical/api-reference/#git_autosquash.blame_analyzer.BlameInfo","title":"<code>BlameInfo</code>  <code>dataclass</code>","text":"<p>Represents git blame information for a line.</p> Source code in <code>src/git_autosquash/blame_analyzer.py</code> <pre><code>@dataclass\nclass BlameInfo:\n    \"\"\"Represents git blame information for a line.\"\"\"\n\n    commit_hash: str\n    author: str\n    timestamp: str\n    line_number: int\n    line_content: str\n</code></pre>"},{"location":"technical/api-reference/#git_autosquash.blame_analyzer.HunkTargetMapping","title":"<code>HunkTargetMapping</code>  <code>dataclass</code>","text":"<p>Maps a hunk to its target commit for squashing.</p> Source code in <code>src/git_autosquash/blame_analyzer.py</code> <pre><code>@dataclass\nclass HunkTargetMapping:\n    \"\"\"Maps a hunk to its target commit for squashing.\"\"\"\n\n    hunk: DiffHunk\n    target_commit: Optional[str]\n    confidence: str  # 'high', 'medium', 'low'\n    blame_info: List[BlameInfo]\n</code></pre>"},{"location":"technical/api-reference/#git_autosquash.blame_analyzer.BlameAnalyzer","title":"<code>BlameAnalyzer</code>","text":"<p>Analyzes git blame to determine target commits for hunks.</p> Source code in <code>src/git_autosquash/blame_analyzer.py</code> <pre><code>class BlameAnalyzer:\n    \"\"\"Analyzes git blame to determine target commits for hunks.\"\"\"\n\n    def __init__(self, git_ops: GitOps, merge_base: str) -&gt; None:\n        \"\"\"Initialize BlameAnalyzer.\n\n        Args:\n            git_ops: GitOps instance for running git commands\n            merge_base: Merge base commit hash to limit scope\n        \"\"\"\n        self.git_ops = git_ops\n        self.merge_base = merge_base\n        self._branch_commits_cache: Optional[Set[str]] = None\n        self._commit_timestamp_cache: Dict[str, int] = {}\n\n    def analyze_hunks(self, hunks: List[DiffHunk]) -&gt; List[HunkTargetMapping]:\n        \"\"\"Analyze hunks and determine target commits for each.\n\n        Args:\n            hunks: List of DiffHunk objects to analyze\n\n        Returns:\n            List of HunkTargetMapping objects with target commit information\n        \"\"\"\n        mappings = []\n\n        for hunk in hunks:\n            mapping = self._analyze_single_hunk(hunk)\n            mappings.append(mapping)\n\n        return mappings\n\n    def _analyze_single_hunk(self, hunk: DiffHunk) -&gt; HunkTargetMapping:\n        \"\"\"Analyze a single hunk to determine its target commit.\n\n        Args:\n            hunk: DiffHunk to analyze\n\n        Returns:\n            HunkTargetMapping with target commit information\n        \"\"\"\n        # For additions, we need to look at surrounding context\n        # For deletions/modifications, we look at the deleted lines\n        if hunk.has_deletions:\n            # Get blame for the old lines being modified/deleted\n            blame_info = self._get_blame_for_old_lines(hunk)\n        else:\n            # Pure addition, look at surrounding context\n            blame_info = self._get_blame_for_context(hunk)\n\n        if not blame_info:\n            return HunkTargetMapping(\n                hunk=hunk, target_commit=None, confidence=\"low\", blame_info=[]\n            )\n\n        # Filter commits to only those within our branch scope\n        branch_commits = self._get_branch_commits()\n        relevant_blame = [\n            info for info in blame_info if info.commit_hash in branch_commits\n        ]\n\n        if not relevant_blame:\n            return HunkTargetMapping(\n                hunk=hunk, target_commit=None, confidence=\"low\", blame_info=blame_info\n            )\n\n        # Group by commit and count occurrences\n        commit_counts: Dict[str, int] = {}\n        for info in relevant_blame:\n            commit_counts[info.commit_hash] = commit_counts.get(info.commit_hash, 0) + 1\n\n        # Find most frequent commit, break ties by recency (requirement: take most recent)\n        most_frequent_commit, max_count = max(\n            commit_counts.items(),\n            key=lambda x: (x[1], self._get_commit_timestamp(x[0])),\n        )\n\n        total_lines = len(relevant_blame)\n        confidence_ratio = max_count / total_lines\n\n        if confidence_ratio &gt;= 0.8:\n            confidence = \"high\"\n        elif confidence_ratio &gt;= 0.5:\n            confidence = \"medium\"\n        else:\n            confidence = \"low\"\n\n        return HunkTargetMapping(\n            hunk=hunk,\n            target_commit=most_frequent_commit,\n            confidence=confidence,\n            blame_info=relevant_blame,\n        )\n\n    def _get_blame_for_old_lines(self, hunk: DiffHunk) -&gt; List[BlameInfo]:\n        \"\"\"Get blame information for lines being deleted/modified.\n\n        Args:\n            hunk: DiffHunk with deletions\n\n        Returns:\n            List of BlameInfo objects for the deleted lines\n        \"\"\"\n        # Run blame on the file at HEAD (before changes)\n        success, blame_output = self.git_ops._run_git_command(\n            \"blame\",\n            f\"-L{hunk.old_start},{hunk.old_start + hunk.old_count - 1}\",\n            \"HEAD\",\n            \"--\",\n            hunk.file_path,\n        )\n\n        if not success:\n            return []\n\n        return self._parse_blame_output(blame_output)\n\n    def _get_blame_for_context(self, hunk: DiffHunk) -&gt; List[BlameInfo]:\n        \"\"\"Get blame information for context around an addition.\n\n        Args:\n            hunk: DiffHunk with additions\n\n        Returns:\n            List of BlameInfo objects for surrounding context\n        \"\"\"\n        # For additions, look at a few lines before and after\n        context_lines = 3\n        start_line = max(1, hunk.new_start - context_lines)\n        end_line = hunk.new_start + context_lines\n\n        success, blame_output = self.git_ops._run_git_command(\n            \"blame\", f\"-L{start_line},{end_line}\", \"HEAD\", \"--\", hunk.file_path\n        )\n\n        if not success:\n            return []\n\n        return self._parse_blame_output(blame_output)\n\n    def _parse_blame_output(self, blame_output: str) -&gt; List[BlameInfo]:\n        \"\"\"Parse git blame output into BlameInfo objects.\n\n        Args:\n            blame_output: Raw git blame output\n\n        Returns:\n            List of parsed BlameInfo objects\n        \"\"\"\n        blame_infos = []\n\n        for line in blame_output.split(\"\\n\"):\n            if not line.strip():\n                continue\n\n            # Parse blame line format:\n            # commit_hash (author timestamp line_num) line_content\n            match = re.match(\n                r\"^([a-f0-9]+)\\s+\\(([^)]+)\\s+(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2} [+-]\\d{4})\\s+(\\d+)\\)\\s*(.*)\",\n                line,\n            )\n            if match:\n                commit_hash = match.group(1)\n                author = match.group(2).strip()\n                timestamp = match.group(3)\n                line_number = int(match.group(4))\n                line_content = match.group(5)\n\n                blame_info = BlameInfo(\n                    commit_hash=commit_hash,\n                    author=author,\n                    timestamp=timestamp,\n                    line_number=line_number,\n                    line_content=line_content,\n                )\n                blame_infos.append(blame_info)\n\n        return blame_infos\n\n    def _get_branch_commits(self) -&gt; Set[str]:\n        \"\"\"Get all commits on current branch since merge base.\n\n        Returns:\n            Set of commit hashes within branch scope\n        \"\"\"\n        if self._branch_commits_cache is not None:\n            return self._branch_commits_cache\n\n        success, output = self.git_ops._run_git_command(\n            \"rev-list\", f\"{self.merge_base}..HEAD\"\n        )\n\n        if not success:\n            self._branch_commits_cache = set()\n        else:\n            self._branch_commits_cache = (\n                set(output.strip().split(\"\\n\")) if output.strip() else set()\n            )\n\n        return self._branch_commits_cache\n\n    def _get_commit_timestamp(self, commit_hash: str) -&gt; int:\n        \"\"\"Get timestamp of a commit for recency comparison.\n\n        Args:\n            commit_hash: Commit hash to get timestamp for\n\n        Returns:\n            Unix timestamp of the commit\n        \"\"\"\n        # Use cache for performance\n        if commit_hash in self._commit_timestamp_cache:\n            return self._commit_timestamp_cache[commit_hash]\n\n        success, output = self.git_ops._run_git_command(\n            \"show\", \"-s\", \"--format=%ct\", commit_hash\n        )\n\n        timestamp = 0\n        if success:\n            try:\n                timestamp = int(output.strip())\n            except ValueError:\n                timestamp = 0\n\n        self._commit_timestamp_cache[commit_hash] = timestamp\n        return timestamp\n\n    def get_commit_summary(self, commit_hash: str) -&gt; str:\n        \"\"\"Get a short summary of a commit for display.\n\n        Args:\n            commit_hash: Commit hash to summarize\n\n        Returns:\n            Short commit summary (hash + subject)\n        \"\"\"\n        success, output = self.git_ops._run_git_command(\n            \"show\", \"-s\", \"--format=%h %s\", commit_hash\n        )\n\n        if not success:\n            return commit_hash[:8]\n\n        return output.strip()\n</code></pre> Functions\u00b6 <code>__init__(git_ops: GitOps, merge_base: str) -&gt; None</code> \u00b6 <p>Initialize BlameAnalyzer.</p> <p>Parameters:</p> Name Type Description Default <code>git_ops</code> <code>GitOps</code> <p>GitOps instance for running git commands</p> required <code>merge_base</code> <code>str</code> <p>Merge base commit hash to limit scope</p> required Source code in <code>src/git_autosquash/blame_analyzer.py</code> <pre><code>def __init__(self, git_ops: GitOps, merge_base: str) -&gt; None:\n    \"\"\"Initialize BlameAnalyzer.\n\n    Args:\n        git_ops: GitOps instance for running git commands\n        merge_base: Merge base commit hash to limit scope\n    \"\"\"\n    self.git_ops = git_ops\n    self.merge_base = merge_base\n    self._branch_commits_cache: Optional[Set[str]] = None\n    self._commit_timestamp_cache: Dict[str, int] = {}\n</code></pre> <code>analyze_hunks(hunks: List[DiffHunk]) -&gt; List[HunkTargetMapping]</code> \u00b6 <p>Analyze hunks and determine target commits for each.</p> <p>Parameters:</p> Name Type Description Default <code>hunks</code> <code>List[DiffHunk]</code> <p>List of DiffHunk objects to analyze</p> required <p>Returns:</p> Type Description <code>List[HunkTargetMapping]</code> <p>List of HunkTargetMapping objects with target commit information</p> Source code in <code>src/git_autosquash/blame_analyzer.py</code> <pre><code>def analyze_hunks(self, hunks: List[DiffHunk]) -&gt; List[HunkTargetMapping]:\n    \"\"\"Analyze hunks and determine target commits for each.\n\n    Args:\n        hunks: List of DiffHunk objects to analyze\n\n    Returns:\n        List of HunkTargetMapping objects with target commit information\n    \"\"\"\n    mappings = []\n\n    for hunk in hunks:\n        mapping = self._analyze_single_hunk(hunk)\n        mappings.append(mapping)\n\n    return mappings\n</code></pre> <code>get_commit_summary(commit_hash: str) -&gt; str</code> \u00b6 <p>Get a short summary of a commit for display.</p> <p>Parameters:</p> Name Type Description Default <code>commit_hash</code> <code>str</code> <p>Commit hash to summarize</p> required <p>Returns:</p> Type Description <code>str</code> <p>Short commit summary (hash + subject)</p> Source code in <code>src/git_autosquash/blame_analyzer.py</code> <pre><code>def get_commit_summary(self, commit_hash: str) -&gt; str:\n    \"\"\"Get a short summary of a commit for display.\n\n    Args:\n        commit_hash: Commit hash to summarize\n\n    Returns:\n        Short commit summary (hash + subject)\n    \"\"\"\n    success, output = self.git_ops._run_git_command(\n        \"show\", \"-s\", \"--format=%h %s\", commit_hash\n    )\n\n    if not success:\n        return commit_hash[:8]\n\n    return output.strip()\n</code></pre>"},{"location":"technical/api-reference/#rebasemanager","title":"RebaseManager","text":"<p>Orchestrates interactive rebase operations to apply approved hunks.</p>"},{"location":"technical/api-reference/#git_autosquash.rebase_manager","title":"<code>git_autosquash.rebase_manager</code>","text":"<p>Interactive rebase manager for applying hunk mappings to historical commits.</p>"},{"location":"technical/api-reference/#git_autosquash.rebase_manager-classes","title":"Classes","text":""},{"location":"technical/api-reference/#git_autosquash.rebase_manager.RebaseConflictError","title":"<code>RebaseConflictError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when rebase encounters conflicts that need user resolution.</p> Source code in <code>src/git_autosquash/rebase_manager.py</code> <pre><code>class RebaseConflictError(Exception):\n    \"\"\"Raised when rebase encounters conflicts that need user resolution.\"\"\"\n\n    def __init__(self, message: str, conflicted_files: List[str]) -&gt; None:\n        \"\"\"Initialize conflict error.\n\n        Args:\n            message: Error message\n            conflicted_files: List of files with conflicts\n        \"\"\"\n        super().__init__(message)\n        self.conflicted_files = conflicted_files\n</code></pre> Functions\u00b6 <code>__init__(message: str, conflicted_files: List[str]) -&gt; None</code> \u00b6 <p>Initialize conflict error.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message</p> required <code>conflicted_files</code> <code>List[str]</code> <p>List of files with conflicts</p> required Source code in <code>src/git_autosquash/rebase_manager.py</code> <pre><code>def __init__(self, message: str, conflicted_files: List[str]) -&gt; None:\n    \"\"\"Initialize conflict error.\n\n    Args:\n        message: Error message\n        conflicted_files: List of files with conflicts\n    \"\"\"\n    super().__init__(message)\n    self.conflicted_files = conflicted_files\n</code></pre>"},{"location":"technical/api-reference/#git_autosquash.rebase_manager.RebaseManager","title":"<code>RebaseManager</code>","text":"<p>Manages interactive rebase operations for squashing hunks to commits.</p> Source code in <code>src/git_autosquash/rebase_manager.py</code> <pre><code>class RebaseManager:\n    \"\"\"Manages interactive rebase operations for squashing hunks to commits.\"\"\"\n\n    def __init__(self, git_ops: GitOps, merge_base: str) -&gt; None:\n        \"\"\"Initialize rebase manager.\n\n        Args:\n            git_ops: Git operations handler\n            merge_base: Merge base commit hash\n        \"\"\"\n        self.git_ops = git_ops\n        self.merge_base = merge_base\n        self._stash_ref: Optional[str] = None\n        self._original_branch: Optional[str] = None\n\n    def execute_squash(self, mappings: List[HunkTargetMapping]) -&gt; bool:\n        \"\"\"Execute the squash operation for approved mappings.\n\n        Args:\n            mappings: List of approved hunk to commit mappings\n\n        Returns:\n            True if successful, False if user aborted\n\n        Raises:\n            RebaseConflictError: If conflicts occur during rebase\n            subprocess.SubprocessError: If git operations fail\n        \"\"\"\n        if not mappings:\n            return True\n\n        # Store original branch for cleanup\n        self._original_branch = self.git_ops.get_current_branch()\n        if not self._original_branch:\n            raise ValueError(\"Cannot determine current branch\")\n\n        try:\n            # Group hunks by target commit\n            commit_hunks = self._group_hunks_by_commit(mappings)\n\n            # Check working tree state and handle stashing if needed\n            self._handle_working_tree_state()\n\n            # Execute rebase for each target commit\n            for target_commit in self._get_commit_order(set(commit_hunks.keys())):\n                hunks = commit_hunks[target_commit]\n                success = self._apply_hunks_to_commit(target_commit, hunks)\n                if not success:\n                    return False\n\n            return True\n\n        except Exception:\n            # Cleanup on any error\n            self._cleanup_on_error()\n            raise\n\n    def _group_hunks_by_commit(\n        self, mappings: List[HunkTargetMapping]\n    ) -&gt; Dict[str, List[DiffHunk]]:\n        \"\"\"Group hunks by their target commit.\n\n        Args:\n            mappings: List of hunk to commit mappings\n\n        Returns:\n            Dictionary mapping commit hash to list of hunks\n        \"\"\"\n        commit_hunks: Dict[str, List[DiffHunk]] = {}\n\n        for mapping in mappings:\n            if mapping.target_commit:\n                commit_hash = mapping.target_commit\n                if commit_hash not in commit_hunks:\n                    commit_hunks[commit_hash] = []\n                commit_hunks[commit_hash].append(mapping.hunk)\n\n        return commit_hunks\n\n    def _get_commit_order(self, commit_hashes: Set[str]) -&gt; List[str]:\n        \"\"\"Get commits in chronological order (oldest first).\n\n        Args:\n            commit_hashes: Set of commit hashes to order\n\n        Returns:\n            List of commit hashes in chronological order\n        \"\"\"\n        # Get commit timestamps for ordering\n        commits_with_timestamps = []\n        for commit_hash in commit_hashes:\n            try:\n                result = self.git_ops.run_git_command(\n                    [\"show\", \"-s\", \"--format=%ct\", commit_hash]\n                )\n                if result.returncode == 0:\n                    timestamp = int(result.stdout.strip())\n                    commits_with_timestamps.append((float(timestamp), commit_hash))\n            except (ValueError, subprocess.SubprocessError):\n                # If we can't get timestamp, put it at the end\n                commits_with_timestamps.append((float(\"inf\"), commit_hash))\n\n        # Sort by timestamp (oldest first)\n        commits_with_timestamps.sort(key=lambda x: x[0])\n        return [commit_hash for _, commit_hash in commits_with_timestamps]\n\n    def _handle_working_tree_state(self) -&gt; None:\n        \"\"\"Handle working tree state before rebase.\"\"\"\n        status = self.git_ops.get_working_tree_status()\n\n        if not status[\"is_clean\"]:\n            # Stash any uncommitted changes\n            result = self.git_ops.run_git_command(\n                [\"stash\", \"push\", \"-m\", \"git-autosquash temp stash\"]\n            )\n            if result.returncode == 0:\n                self._stash_ref = \"stash@{0}\"\n            else:\n                raise subprocess.SubprocessError(\n                    f\"Failed to stash changes: {result.stderr}\"\n                )\n\n    def _apply_hunks_to_commit(self, target_commit: str, hunks: List[DiffHunk]) -&gt; bool:\n        \"\"\"Apply hunks to a specific commit via interactive rebase.\n\n        Args:\n            target_commit: Target commit hash\n            hunks: List of hunks to apply to this commit\n\n        Returns:\n            True if successful, False if user aborted\n        \"\"\"\n        # Create patch for the hunks\n        patch_content = self._create_patch_for_hunks(hunks)\n\n        # Start interactive rebase to edit the target commit\n        if not self._start_rebase_edit(target_commit):\n            return False\n\n        try:\n            # Apply the patch\n            self._apply_patch(patch_content)\n\n            # Amend the commit\n            self._amend_commit()\n\n            # Continue the rebase\n            self._continue_rebase()\n\n            return True\n\n        except RebaseConflictError:\n            # Let the exception propagate for user handling\n            raise\n        except Exception as e:\n            # Abort rebase on unexpected errors\n            self._abort_rebase()\n            raise subprocess.SubprocessError(f\"Failed to apply patch: {e}\")\n\n    def _create_patch_for_hunks(self, hunks: List[DiffHunk]) -&gt; str:\n        \"\"\"Create a patch string from a list of hunks.\n\n        Args:\n            hunks: List of hunks to include in patch\n\n        Returns:\n            Patch content as string\n        \"\"\"\n        patch_lines = []\n        current_file = None\n\n        for hunk in hunks:\n            # Add file header if this is a new file\n            if hunk.file_path != current_file:\n                current_file = hunk.file_path\n                patch_lines.extend(\n                    [f\"--- a/{hunk.file_path}\", f\"+++ b/{hunk.file_path}\"]\n                )\n\n            # Add hunk content\n            patch_lines.extend(hunk.lines)\n\n        return \"\\n\".join(patch_lines) + \"\\n\"\n\n    def _start_rebase_edit(self, target_commit: str) -&gt; bool:\n        \"\"\"Start interactive rebase to edit target commit.\n\n        Args:\n            target_commit: Commit to edit\n\n        Returns:\n            True if rebase started successfully\n        \"\"\"\n        # Create rebase todo that marks target commit for editing\n        todo_content = f\"edit {target_commit}\\n\"\n\n        # Write todo to temporary file\n        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".txt\", delete=False) as f:\n            f.write(todo_content)\n            todo_file = f.name\n\n        try:\n            # Set git editor to use our todo file\n            env = os.environ.copy()\n            env[\"GIT_SEQUENCE_EDITOR\"] = f\"cp {todo_file}\"\n\n            # Start interactive rebase\n            result = self.git_ops.run_git_command(\n                [\"rebase\", \"-i\", f\"{target_commit}^\"], env=env\n            )\n\n            if result.returncode != 0:\n                # Rebase failed to start\n                return False\n\n            return True\n\n        finally:\n            # Clean up temp file\n            try:\n                os.unlink(todo_file)\n            except OSError:\n                pass\n\n    def _apply_patch(self, patch_content: str) -&gt; None:\n        \"\"\"Apply patch content to working directory.\n\n        Args:\n            patch_content: Patch content to apply\n        \"\"\"\n        # Write patch to temporary file\n        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".patch\", delete=False) as f:\n            f.write(patch_content)\n            patch_file = f.name\n\n        try:\n            # Apply patch using git apply\n            result = self.git_ops.run_git_command(\n                [\"apply\", \"--whitespace=nowarn\", patch_file]\n            )\n\n            if result.returncode != 0:\n                # Check if there are conflicts\n                conflicted_files = self._get_conflicted_files()\n                if conflicted_files:\n                    raise RebaseConflictError(\n                        f\"Patch application failed with conflicts: {result.stderr}\",\n                        conflicted_files,\n                    )\n                else:\n                    raise subprocess.SubprocessError(\n                        f\"Patch application failed: {result.stderr}\"\n                    )\n\n        finally:\n            # Clean up temp file\n            try:\n                os.unlink(patch_file)\n            except OSError:\n                pass\n\n    def _amend_commit(self) -&gt; None:\n        \"\"\"Amend the current commit with changes.\"\"\"\n        # Stage all changes\n        result = self.git_ops.run_git_command([\"add\", \".\"])\n        if result.returncode != 0:\n            raise subprocess.SubprocessError(\n                f\"Failed to stage changes: {result.stderr}\"\n            )\n\n        # Amend commit (keep original message)\n        result = self.git_ops.run_git_command([\"commit\", \"--amend\", \"--no-edit\"])\n        if result.returncode != 0:\n            raise subprocess.SubprocessError(f\"Failed to amend commit: {result.stderr}\")\n\n    def _continue_rebase(self) -&gt; None:\n        \"\"\"Continue the interactive rebase.\"\"\"\n        result = self.git_ops.run_git_command([\"rebase\", \"--continue\"])\n        if result.returncode != 0:\n            # Check for conflicts\n            conflicted_files = self._get_conflicted_files()\n            if conflicted_files:\n                raise RebaseConflictError(\n                    f\"Rebase conflicts detected: {result.stderr}\", conflicted_files\n                )\n            else:\n                raise subprocess.SubprocessError(\n                    f\"Failed to continue rebase: {result.stderr}\"\n                )\n\n    def _abort_rebase(self) -&gt; None:\n        \"\"\"Abort the current rebase.\"\"\"\n        try:\n            self.git_ops.run_git_command([\"rebase\", \"--abort\"])\n        except subprocess.SubprocessError:\n            # Ignore errors during abort\n            pass\n\n    def _get_conflicted_files(self) -&gt; List[str]:\n        \"\"\"Get list of files with merge conflicts.\n\n        Returns:\n            List of file paths with conflicts\n        \"\"\"\n        try:\n            result = self.git_ops.run_git_command(\n                [\"diff\", \"--name-only\", \"--diff-filter=U\"]\n            )\n            if result.returncode == 0:\n                return [\n                    line.strip() for line in result.stdout.split(\"\\n\") if line.strip()\n                ]\n        except subprocess.SubprocessError:\n            pass\n\n        return []\n\n    def _cleanup_on_error(self) -&gt; None:\n        \"\"\"Cleanup state after error.\"\"\"\n        # Abort any active rebase\n        self._abort_rebase()\n\n        # Restore stash if we created one\n        if self._stash_ref:\n            try:\n                self.git_ops.run_git_command([\"stash\", \"pop\", self._stash_ref])\n            except subprocess.SubprocessError:\n                # Stash pop failed, but don't raise - user can manually recover\n                pass\n            finally:\n                self._stash_ref = None\n\n    def abort_operation(self) -&gt; None:\n        \"\"\"Abort the current squash operation and restore original state.\"\"\"\n        self._cleanup_on_error()\n\n    def is_rebase_in_progress(self) -&gt; bool:\n        \"\"\"Check if a rebase is currently in progress.\n\n        Returns:\n            True if rebase is active\n        \"\"\"\n        try:\n            result = self.git_ops.run_git_command([\"status\", \"--porcelain=v2\"])\n            if result.returncode == 0:\n                # Look for rebase status indicators\n                lines = result.stdout.split(\"\\n\")\n                for line in lines:\n                    if line.startswith(\"# rebase\"):\n                        return True\n        except subprocess.SubprocessError:\n            pass\n\n        return False\n\n    def get_rebase_status(self) -&gt; Dict[str, Any]:\n        \"\"\"Get current rebase status information.\n\n        Returns:\n            Dictionary with rebase status details\n        \"\"\"\n        status: Dict[str, Any] = {\n            \"in_progress\": False,\n            \"current_commit\": None,\n            \"conflicted_files\": [],\n            \"step\": None,\n            \"total_steps\": None,\n        }\n\n        if not self.is_rebase_in_progress():\n            return status\n\n        status[\"in_progress\"] = True\n        status[\"conflicted_files\"] = self._get_conflicted_files()\n\n        # Try to get rebase step info\n        try:\n            rebase_dir = os.path.join(self.git_ops.repo_path, \".git\", \"rebase-merge\")\n            if os.path.exists(rebase_dir):\n                # Read step info\n                msgnum_file = os.path.join(rebase_dir, \"msgnum\")\n                end_file = os.path.join(rebase_dir, \"end\")\n\n                if os.path.exists(msgnum_file) and os.path.exists(end_file):\n                    with open(msgnum_file, \"r\") as f:\n                        status[\"step\"] = int(f.read().strip())\n                    with open(end_file, \"r\") as f:\n                        status[\"total_steps\"] = int(f.read().strip())\n        except (OSError, ValueError):\n            pass\n\n        return status\n</code></pre> Functions\u00b6 <code>__init__(git_ops: GitOps, merge_base: str) -&gt; None</code> \u00b6 <p>Initialize rebase manager.</p> <p>Parameters:</p> Name Type Description Default <code>git_ops</code> <code>GitOps</code> <p>Git operations handler</p> required <code>merge_base</code> <code>str</code> <p>Merge base commit hash</p> required Source code in <code>src/git_autosquash/rebase_manager.py</code> <pre><code>def __init__(self, git_ops: GitOps, merge_base: str) -&gt; None:\n    \"\"\"Initialize rebase manager.\n\n    Args:\n        git_ops: Git operations handler\n        merge_base: Merge base commit hash\n    \"\"\"\n    self.git_ops = git_ops\n    self.merge_base = merge_base\n    self._stash_ref: Optional[str] = None\n    self._original_branch: Optional[str] = None\n</code></pre> <code>execute_squash(mappings: List[HunkTargetMapping]) -&gt; bool</code> \u00b6 <p>Execute the squash operation for approved mappings.</p> <p>Parameters:</p> Name Type Description Default <code>mappings</code> <code>List[HunkTargetMapping]</code> <p>List of approved hunk to commit mappings</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False if user aborted</p> <p>Raises:</p> Type Description <code>RebaseConflictError</code> <p>If conflicts occur during rebase</p> <code>SubprocessError</code> <p>If git operations fail</p> Source code in <code>src/git_autosquash/rebase_manager.py</code> <pre><code>def execute_squash(self, mappings: List[HunkTargetMapping]) -&gt; bool:\n    \"\"\"Execute the squash operation for approved mappings.\n\n    Args:\n        mappings: List of approved hunk to commit mappings\n\n    Returns:\n        True if successful, False if user aborted\n\n    Raises:\n        RebaseConflictError: If conflicts occur during rebase\n        subprocess.SubprocessError: If git operations fail\n    \"\"\"\n    if not mappings:\n        return True\n\n    # Store original branch for cleanup\n    self._original_branch = self.git_ops.get_current_branch()\n    if not self._original_branch:\n        raise ValueError(\"Cannot determine current branch\")\n\n    try:\n        # Group hunks by target commit\n        commit_hunks = self._group_hunks_by_commit(mappings)\n\n        # Check working tree state and handle stashing if needed\n        self._handle_working_tree_state()\n\n        # Execute rebase for each target commit\n        for target_commit in self._get_commit_order(set(commit_hunks.keys())):\n            hunks = commit_hunks[target_commit]\n            success = self._apply_hunks_to_commit(target_commit, hunks)\n            if not success:\n                return False\n\n        return True\n\n    except Exception:\n        # Cleanup on any error\n        self._cleanup_on_error()\n        raise\n</code></pre> <code>abort_operation() -&gt; None</code> \u00b6 <p>Abort the current squash operation and restore original state.</p> Source code in <code>src/git_autosquash/rebase_manager.py</code> <pre><code>def abort_operation(self) -&gt; None:\n    \"\"\"Abort the current squash operation and restore original state.\"\"\"\n    self._cleanup_on_error()\n</code></pre> <code>is_rebase_in_progress() -&gt; bool</code> \u00b6 <p>Check if a rebase is currently in progress.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if rebase is active</p> Source code in <code>src/git_autosquash/rebase_manager.py</code> <pre><code>def is_rebase_in_progress(self) -&gt; bool:\n    \"\"\"Check if a rebase is currently in progress.\n\n    Returns:\n        True if rebase is active\n    \"\"\"\n    try:\n        result = self.git_ops.run_git_command([\"status\", \"--porcelain=v2\"])\n        if result.returncode == 0:\n            # Look for rebase status indicators\n            lines = result.stdout.split(\"\\n\")\n            for line in lines:\n                if line.startswith(\"# rebase\"):\n                    return True\n    except subprocess.SubprocessError:\n        pass\n\n    return False\n</code></pre> <code>get_rebase_status() -&gt; Dict[str, Any]</code> \u00b6 <p>Get current rebase status information.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with rebase status details</p> Source code in <code>src/git_autosquash/rebase_manager.py</code> <pre><code>def get_rebase_status(self) -&gt; Dict[str, Any]:\n    \"\"\"Get current rebase status information.\n\n    Returns:\n        Dictionary with rebase status details\n    \"\"\"\n    status: Dict[str, Any] = {\n        \"in_progress\": False,\n        \"current_commit\": None,\n        \"conflicted_files\": [],\n        \"step\": None,\n        \"total_steps\": None,\n    }\n\n    if not self.is_rebase_in_progress():\n        return status\n\n    status[\"in_progress\"] = True\n    status[\"conflicted_files\"] = self._get_conflicted_files()\n\n    # Try to get rebase step info\n    try:\n        rebase_dir = os.path.join(self.git_ops.repo_path, \".git\", \"rebase-merge\")\n        if os.path.exists(rebase_dir):\n            # Read step info\n            msgnum_file = os.path.join(rebase_dir, \"msgnum\")\n            end_file = os.path.join(rebase_dir, \"end\")\n\n            if os.path.exists(msgnum_file) and os.path.exists(end_file):\n                with open(msgnum_file, \"r\") as f:\n                    status[\"step\"] = int(f.read().strip())\n                with open(end_file, \"r\") as f:\n                    status[\"total_steps\"] = int(f.read().strip())\n    except (OSError, ValueError):\n        pass\n\n    return status\n</code></pre>"},{"location":"technical/api-reference/#cli-entry-point","title":"CLI Entry Point","text":""},{"location":"technical/api-reference/#main","title":"Main","text":"<p>Command-line interface and entry point for git-autosquash.</p>"},{"location":"technical/api-reference/#git_autosquash.main","title":"<code>git_autosquash.main</code>","text":"<p>CLI entry point for git-autosquash.</p>"},{"location":"technical/api-reference/#git_autosquash.main-classes","title":"Classes","text":""},{"location":"technical/api-reference/#git_autosquash.main-functions","title":"Functions","text":""},{"location":"technical/api-reference/#git_autosquash.main.main","title":"<code>main() -&gt; None</code>","text":"<p>Main entry point for git-autosquash command.</p> Source code in <code>src/git_autosquash/main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Main entry point for git-autosquash command.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"git-autosquash\",\n        description=\"Automatically squash changes back into historical commits\",\n    )\n    parser.add_argument(\n        \"--line-by-line\",\n        action=\"store_true\",\n        help=\"Use line-by-line hunk splitting instead of default git hunks\",\n    )\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version=f\"%(prog)s {__version__}\",\n    )\n\n    args = parser.parse_args()\n\n    try:\n        git_ops = GitOps()\n\n        # Phase 1: Validate git repository\n        if not git_ops.is_git_repo():\n            print(\"Error: Not in a git repository\", file=sys.stderr)\n            sys.exit(1)\n\n        current_branch = git_ops.get_current_branch()\n        if not current_branch:\n            print(\"Error: Not on a branch (detached HEAD)\", file=sys.stderr)\n            sys.exit(1)\n\n        merge_base = git_ops.get_merge_base_with_main(current_branch)\n        if not merge_base:\n            print(\"Error: Could not find merge base with main/master\", file=sys.stderr)\n            sys.exit(1)\n\n        # Check if there are commits to work with\n        if not git_ops.has_commits_since_merge_base(merge_base):\n            print(\n                \"Error: No commits found on current branch since merge base\",\n                file=sys.stderr,\n            )\n            sys.exit(1)\n\n        # Analyze working tree status\n        status = git_ops.get_working_tree_status()\n        print(f\"Current branch: {current_branch}\")\n        print(f\"Merge base: {merge_base}\")\n        print(\n            f\"Working tree status: staged={status['has_staged']}, unstaged={status['has_unstaged']}, clean={status['is_clean']}\"\n        )\n\n        # Handle mixed staged/unstaged state\n        if status[\"has_staged\"] and status[\"has_unstaged\"]:\n            print(\"\\nMixed staged and unstaged changes detected.\")\n            print(\"Choose an option:\")\n            print(\"  a) Process all changes (staged + unstaged)\")\n            print(\"  s) Stash unstaged changes and process only staged\")\n            print(\"  q) Quit\")\n\n            choice = input(\"Your choice [a/s/q]: \").lower().strip()\n            if choice == \"q\":\n                print(\"Operation cancelled\")\n                sys.exit(0)\n            elif choice == \"s\":\n                print(\"Stash-only mode selected (not yet implemented)\")\n            elif choice == \"a\":\n                print(\"Process-all mode selected\")\n            else:\n                print(\"Invalid choice, defaulting to process all\")\n        elif status[\"is_clean\"]:\n            print(\"Working tree is clean, will reset HEAD~1 and process those changes\")\n        elif status[\"has_staged\"]:\n            print(\"Processing staged changes\")\n        else:\n            print(\"Processing unstaged changes\")\n\n        # Phase 2: Parse hunks and analyze blame\n        print(\"\\nAnalyzing changes and finding target commits...\")\n\n        hunk_parser = HunkParser(git_ops)\n        hunks = hunk_parser.get_diff_hunks(line_by_line=args.line_by_line)\n\n        if not hunks:\n            print(\"No changes found to process\", file=sys.stderr)\n            sys.exit(1)\n\n        print(f\"Found {len(hunks)} hunks to process\")\n\n        # Analyze hunks with blame to find target commits\n        blame_analyzer = BlameAnalyzer(git_ops, merge_base)\n        mappings = blame_analyzer.analyze_hunks(hunks)\n\n        # Filter out mappings without target commits\n        valid_mappings = [m for m in mappings if m.target_commit is not None]\n\n        if not valid_mappings:\n            print(\"No valid target commits found for any hunks\", file=sys.stderr)\n            print(\n                \"This may happen if all changes are in new files or outside branch scope\"\n            )\n            sys.exit(1)\n\n        print(f\"Found target commits for {len(valid_mappings)} hunks\")\n\n        # Phase 3: Show TUI for user approval\n        print(\"\\nLaunching interactive approval interface...\")\n\n        try:\n            app = AutoSquashApp(valid_mappings)\n            approved = app.run()\n\n            if approved and app.approved_mappings:\n                approved_mappings = app.approved_mappings\n                print(f\"\\nUser approved {len(approved_mappings)} hunks for squashing\")\n\n                # Phase 4 - Execute the interactive rebase\n                print(\"\\nExecuting interactive rebase...\")\n                success = _execute_rebase(\n                    approved_mappings, git_ops, merge_base, blame_analyzer\n                )\n\n                if success:\n                    print(\"\u2713 Squash operation completed successfully!\")\n                    print(\"Your changes have been distributed to their target commits.\")\n                else:\n                    print(\"\u2717 Squash operation was aborted or failed.\")\n\n            else:\n                print(\"\\nOperation cancelled by user or no hunks approved\")\n\n        except ImportError as e:\n            print(f\"\\nTextual TUI not available: {e}\")\n            print(\"Falling back to simple text-based approval...\")\n            approved_mappings = _simple_approval_fallback(\n                valid_mappings, blame_analyzer\n            )\n\n            if approved_mappings:\n                print(f\"\\nApproved {len(approved_mappings)} hunks for squashing\")\n                # Phase 4 - Execute the interactive rebase\n                print(\"\\nExecuting interactive rebase...\")\n                success = _execute_rebase(\n                    approved_mappings, git_ops, merge_base, blame_analyzer\n                )\n\n                if success:\n                    print(\"\u2713 Squash operation completed successfully!\")\n                    print(\"Your changes have been distributed to their target commits.\")\n                else:\n                    print(\"\u2717 Squash operation was aborted or failed.\")\n            else:\n                print(\"\\nOperation cancelled\")\n\n        except Exception as e:\n            print(f\"\\nTUI encountered an error: {e}\")\n            print(\"Falling back to simple text-based approval...\")\n            approved_mappings = _simple_approval_fallback(\n                valid_mappings, blame_analyzer\n            )\n\n            if approved_mappings:\n                print(f\"\\nApproved {len(approved_mappings)} hunks for squashing\")\n                # Phase 4 - Execute the interactive rebase\n                print(\"\\nExecuting interactive rebase...\")\n                success = _execute_rebase(\n                    approved_mappings, git_ops, merge_base, blame_analyzer\n                )\n\n                if success:\n                    print(\"\u2713 Squash operation completed successfully!\")\n                    print(\"Your changes have been distributed to their target commits.\")\n                else:\n                    print(\"\u2717 Squash operation was aborted or failed.\")\n            else:\n                print(\"\\nOperation cancelled\")\n\n    except (subprocess.SubprocessError, FileNotFoundError) as e:\n        print(f\"Git operation failed: {e}\", file=sys.stderr)\n        sys.exit(1)\n    except KeyboardInterrupt:\n        print(\"\\nOperation cancelled by user\", file=sys.stderr)\n        sys.exit(130)\n</code></pre>"},{"location":"technical/api-reference/#tui-components","title":"TUI Components","text":""},{"location":"technical/api-reference/#autosquashapp","title":"AutoSquashApp","text":"<p>Main Textual application for the interactive approval workflow.</p>"},{"location":"technical/api-reference/#git_autosquash.tui.app","title":"<code>git_autosquash.tui.app</code>","text":"<p>Main Textual application for hunk approval workflow.</p>"},{"location":"technical/api-reference/#git_autosquash.tui.app-classes","title":"Classes","text":""},{"location":"technical/api-reference/#git_autosquash.tui.app.AutoSquashApp","title":"<code>AutoSquashApp</code>","text":"<p>               Bases: <code>App[bool]</code></p> <p>Main application for git-autosquash TUI.</p> Source code in <code>src/git_autosquash/tui/app.py</code> <pre><code>class AutoSquashApp(App[bool]):\n    \"\"\"Main application for git-autosquash TUI.\"\"\"\n\n    TITLE = \"git-autosquash\"\n    SUB_TITLE = \"Interactive hunk approval\"\n\n    BINDINGS = [\n        Binding(\"q\", \"quit\", \"Quit\", priority=True),\n        Binding(\"ctrl+c\", \"quit\", \"Quit\", show=False),\n    ]\n\n    def __init__(self, mappings: List[HunkTargetMapping]) -&gt; None:\n        \"\"\"Initialize the application.\n\n        Args:\n            mappings: List of hunk to target commit mappings to review\n        \"\"\"\n        super().__init__()\n        self.mappings = mappings\n        self.approved_mappings: List[HunkTargetMapping] = []\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compose the application layout.\"\"\"\n        yield Header()\n        yield Footer()\n\n    def on_mount(self) -&gt; None:\n        \"\"\"Handle application startup.\"\"\"\n        if not self.mappings:\n            # No mappings to review, exit immediately\n            self.exit(False)\n            return\n\n        # Push approval screen with mappings\n        self.push_screen(ApprovalScreen(self.mappings), self._handle_approval_result)\n\n    def _handle_approval_result(\n        self, result: bool | List[HunkTargetMapping] | None\n    ) -&gt; None:\n        \"\"\"Handle result from approval screen.\n\n        Args:\n            result: True if user approved with mappings passed separately,\n                   List of approved mappings if user approved,\n                   False if cancelled\n        \"\"\"\n        if isinstance(result, list):\n            # Result contains the approved mappings directly\n            self.approved_mappings = result\n            self.exit(True)\n        elif result:\n            # Boolean True (should not happen with new implementation)\n            self.exit(True)\n        else:\n            # User cancelled\n            self.exit(False)\n\n    async def action_quit(self) -&gt; None:\n        \"\"\"Handle quit action.\"\"\"\n        self.exit(False)\n</code></pre> Functions\u00b6 <code>__init__(mappings: List[HunkTargetMapping]) -&gt; None</code> \u00b6 <p>Initialize the application.</p> <p>Parameters:</p> Name Type Description Default <code>mappings</code> <code>List[HunkTargetMapping]</code> <p>List of hunk to target commit mappings to review</p> required Source code in <code>src/git_autosquash/tui/app.py</code> <pre><code>def __init__(self, mappings: List[HunkTargetMapping]) -&gt; None:\n    \"\"\"Initialize the application.\n\n    Args:\n        mappings: List of hunk to target commit mappings to review\n    \"\"\"\n    super().__init__()\n    self.mappings = mappings\n    self.approved_mappings: List[HunkTargetMapping] = []\n</code></pre> <code>compose() -&gt; ComposeResult</code> \u00b6 <p>Compose the application layout.</p> Source code in <code>src/git_autosquash/tui/app.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compose the application layout.\"\"\"\n    yield Header()\n    yield Footer()\n</code></pre> <code>on_mount() -&gt; None</code> \u00b6 <p>Handle application startup.</p> Source code in <code>src/git_autosquash/tui/app.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"Handle application startup.\"\"\"\n    if not self.mappings:\n        # No mappings to review, exit immediately\n        self.exit(False)\n        return\n\n    # Push approval screen with mappings\n    self.push_screen(ApprovalScreen(self.mappings), self._handle_approval_result)\n</code></pre> <code>action_quit() -&gt; None</code> <code>async</code> \u00b6 <p>Handle quit action.</p> Source code in <code>src/git_autosquash/tui/app.py</code> <pre><code>async def action_quit(self) -&gt; None:\n    \"\"\"Handle quit action.\"\"\"\n    self.exit(False)\n</code></pre>"},{"location":"technical/api-reference/#git_autosquash.tui.app.WelcomeScreen","title":"<code>WelcomeScreen</code>","text":"<p>               Bases: <code>Screen[None]</code></p> <p>Welcome screen showing project information.</p> Source code in <code>src/git_autosquash/tui/app.py</code> <pre><code>class WelcomeScreen(Screen[None]):\n    \"\"\"Welcome screen showing project information.\"\"\"\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compose the welcome screen.\"\"\"\n        with Container():\n            yield Static(\"Welcome to git-autosquash\", id=\"title\")\n            yield Static(\n                \"This tool will help you automatically distribute changes \"\n                \"back to the commits where they belong.\",\n                id=\"description\",\n            )\n            with Horizontal():\n                yield Button(\"Continue\", variant=\"primary\", id=\"continue\")\n                yield Button(\"Cancel\", id=\"cancel\")\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"Handle button presses.\"\"\"\n        if event.button.id == \"continue\":\n            self.dismiss(None)\n        else:\n            self.dismiss(None)\n</code></pre> Functions\u00b6 <code>compose() -&gt; ComposeResult</code> \u00b6 <p>Compose the welcome screen.</p> Source code in <code>src/git_autosquash/tui/app.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compose the welcome screen.\"\"\"\n    with Container():\n        yield Static(\"Welcome to git-autosquash\", id=\"title\")\n        yield Static(\n            \"This tool will help you automatically distribute changes \"\n            \"back to the commits where they belong.\",\n            id=\"description\",\n        )\n        with Horizontal():\n            yield Button(\"Continue\", variant=\"primary\", id=\"continue\")\n            yield Button(\"Cancel\", id=\"cancel\")\n</code></pre> <code>on_button_pressed(event: Button.Pressed) -&gt; None</code> \u00b6 <p>Handle button presses.</p> Source code in <code>src/git_autosquash/tui/app.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"continue\":\n        self.dismiss(None)\n    else:\n        self.dismiss(None)\n</code></pre>"},{"location":"technical/api-reference/#approvalscreen","title":"ApprovalScreen","text":"<p>Interactive screen for reviewing and approving hunk to commit mappings.</p>"},{"location":"technical/api-reference/#git_autosquash.tui.screens","title":"<code>git_autosquash.tui.screens</code>","text":"<p>Screen implementations for git-autosquash TUI.</p>"},{"location":"technical/api-reference/#git_autosquash.tui.screens-classes","title":"Classes","text":""},{"location":"technical/api-reference/#git_autosquash.tui.screens.ApprovalScreen","title":"<code>ApprovalScreen</code>","text":"<p>               Bases: <code>Screen[Union[bool, List[HunkTargetMapping]]]</code></p> <p>Screen for approving hunk to commit mappings.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>class ApprovalScreen(Screen[Union[bool, List[HunkTargetMapping]]]):\n    \"\"\"Screen for approving hunk to commit mappings.\"\"\"\n\n    BINDINGS = [\n        Binding(\"enter\", \"approve_all\", \"Approve &amp; Continue\", priority=True),\n        Binding(\"escape\", \"cancel\", \"Cancel\", priority=True),\n        Binding(\"a\", \"approve_all_toggle\", \"Toggle All\", priority=False),\n        Binding(\"j\", \"next_hunk\", \"Next Hunk\", show=False),\n        Binding(\"k\", \"prev_hunk\", \"Prev Hunk\", show=False),\n        Binding(\"down\", \"next_hunk\", \"Next Hunk\", show=False),\n        Binding(\"up\", \"prev_hunk\", \"Prev Hunk\", show=False),\n    ]\n\n    def __init__(self, mappings: List[HunkTargetMapping], **kwargs) -&gt; None:\n        \"\"\"Initialize approval screen.\n\n        Args:\n            mappings: List of hunk to commit mappings to review\n        \"\"\"\n        super().__init__(**kwargs)\n        self.mappings = mappings\n        self.current_hunk_index = 0\n        self.hunk_widgets: List[HunkMappingWidget] = []\n        self._selected_widget: HunkMappingWidget | None = None\n        self._diff_viewer: DiffViewer | None = None\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compose the screen layout.\"\"\"\n        yield Header()\n\n        with Container(id=\"main-container\"):\n            # Title and summary\n            yield Static(\"Hunk to Commit Mapping Review\", id=\"screen-title\")\n            yield Static(\n                f\"Review {len(self.mappings)} hunks and their target commits. \"\n                \"Use checkboxes to approve/reject individual hunks.\",\n                id=\"screen-description\",\n            )\n\n            # Progress indicator\n            yield ProgressIndicator(len(self.mappings), id=\"progress\")\n\n            # Main content area\n            with Horizontal(id=\"content-area\"):\n                # Left panel: Hunk list\n                with Vertical(id=\"hunk-list-panel\"):\n                    yield Static(\"Hunks\", id=\"hunk-list-title\")\n                    with VerticalScroll(id=\"hunk-list\"):\n                        for mapping in self.mappings:\n                            hunk_widget = HunkMappingWidget(mapping)\n                            self.hunk_widgets.append(hunk_widget)\n                            yield hunk_widget\n\n                # Right panel: Diff viewer\n                with Vertical(id=\"diff-panel\"):\n                    yield Static(\"Diff Preview\", id=\"diff-title\")\n                    yield DiffViewer(id=\"diff-viewer\")\n\n            # Action buttons\n            with Horizontal(id=\"action-buttons\"):\n                yield Button(\n                    \"Approve All &amp; Continue\", variant=\"success\", id=\"approve-all\"\n                )\n                yield Button(\"Continue with Selected\", variant=\"primary\", id=\"continue\")\n                yield Button(\"Cancel\", variant=\"default\", id=\"cancel\")\n\n        yield Footer()\n\n    def on_mount(self) -&gt; None:\n        \"\"\"Handle screen mounting.\"\"\"\n        # Cache diff viewer reference\n        self._diff_viewer = self.query_one(\"#diff-viewer\", DiffViewer)\n\n        # Select first hunk if available\n        if self.hunk_widgets:\n            self._select_widget(self.hunk_widgets[0])\n\n        # Update progress\n        self._update_progress()\n\n    @on(HunkMappingWidget.Selected)\n    def on_hunk_selected(self, message: HunkMappingWidget.Selected) -&gt; None:\n        \"\"\"Handle hunk selection.\"\"\"\n        # Find the clicked widget (optimized: avoid full iteration when possible)\n        target_widget = None\n        for i, widget in enumerate(self.hunk_widgets):\n            if widget.mapping == message.mapping:\n                target_widget = widget\n                self.current_hunk_index = i\n                break\n\n        if target_widget:\n            self._select_widget(target_widget)\n\n    @on(HunkMappingWidget.ApprovalChanged)\n    def on_approval_changed(self, message: HunkMappingWidget.ApprovalChanged) -&gt; None:\n        \"\"\"Handle approval status changes.\"\"\"\n        self._update_progress()\n\n    @on(Button.Pressed)\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"Handle button presses.\"\"\"\n        if event.button.id == \"approve-all\":\n            self.action_approve_all()\n        elif event.button.id == \"continue\":\n            self.action_continue()\n        elif event.button.id == \"cancel\":\n            self.action_cancel()\n\n    def action_approve_all(self) -&gt; None:\n        \"\"\"Approve all hunks and continue.\"\"\"\n        for widget in self.hunk_widgets:\n            widget.approved = True\n            checkbox = widget.query_one(\"#approval\", Checkbox)\n            checkbox.value = True\n\n        self._update_progress()\n        approved_mappings = self.get_approved_mappings()\n        self.dismiss(approved_mappings)\n\n    def action_approve_all_toggle(self) -&gt; None:\n        \"\"\"Toggle approval status of all hunks.\"\"\"\n        # Check if all are currently approved\n        all_approved = all(widget.approved for widget in self.hunk_widgets)\n        new_state = not all_approved\n\n        for widget in self.hunk_widgets:\n            widget.approved = new_state\n            checkbox = widget.query_one(\"#approval\", Checkbox)\n            checkbox.value = new_state\n\n        self._update_progress()\n\n    def action_continue(self) -&gt; None:\n        \"\"\"Continue with currently selected hunks.\"\"\"\n        approved_mappings = self.get_approved_mappings()\n        if not approved_mappings:\n            # No hunks approved, cannot continue\n            return\n\n        self.dismiss(approved_mappings)\n\n    def action_cancel(self) -&gt; None:\n        \"\"\"Cancel the approval process.\"\"\"\n        self.dismiss(False)\n\n    def action_next_hunk(self) -&gt; None:\n        \"\"\"Select next hunk.\"\"\"\n        if self.current_hunk_index &lt; len(self.hunk_widgets) - 1:\n            self.current_hunk_index += 1\n            self._select_hunk_by_index(self.current_hunk_index)\n\n    def action_prev_hunk(self) -&gt; None:\n        \"\"\"Select previous hunk.\"\"\"\n        if self.current_hunk_index &gt; 0:\n            self.current_hunk_index -= 1\n            self._select_hunk_by_index(self.current_hunk_index)\n\n    def _select_widget(self, widget: HunkMappingWidget) -&gt; None:\n        \"\"\"Select a specific widget, optimized to avoid O(n) operations.\n\n        Args:\n            widget: The widget to select\n        \"\"\"\n        # Deselect previous widget (O(1) operation)\n        if self._selected_widget and self._selected_widget != widget:\n            self._selected_widget.selected = False\n\n        # Select new widget\n        widget.selected = True\n        self._selected_widget = widget\n\n        # Update diff viewer (cached reference)\n        if self._diff_viewer:\n            self._diff_viewer.show_hunk(widget.mapping.hunk)\n\n        # Scroll to selected widget\n        widget.scroll_visible()\n\n    def _select_hunk_by_index(self, index: int) -&gt; None:\n        \"\"\"Select hunk by index.\"\"\"\n        if 0 &lt;= index &lt; len(self.hunk_widgets):\n            self.current_hunk_index = index\n            self._select_widget(self.hunk_widgets[index])\n\n    def _update_progress(self) -&gt; None:\n        \"\"\"Update the progress indicator.\"\"\"\n        approved_count = sum(1 for widget in self.hunk_widgets if widget.approved)\n        progress = self.query_one(\"#progress\", ProgressIndicator)\n        progress.update_progress(approved_count)\n\n    def get_approved_mappings(self) -&gt; List[HunkTargetMapping]:\n        \"\"\"Get list of approved mappings.\n\n        Returns:\n            List of mappings that user approved\n        \"\"\"\n        return [widget.mapping for widget in self.hunk_widgets if widget.approved]\n</code></pre> Functions\u00b6 <code>__init__(mappings: List[HunkTargetMapping], **kwargs) -&gt; None</code> \u00b6 <p>Initialize approval screen.</p> <p>Parameters:</p> Name Type Description Default <code>mappings</code> <code>List[HunkTargetMapping]</code> <p>List of hunk to commit mappings to review</p> required Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def __init__(self, mappings: List[HunkTargetMapping], **kwargs) -&gt; None:\n    \"\"\"Initialize approval screen.\n\n    Args:\n        mappings: List of hunk to commit mappings to review\n    \"\"\"\n    super().__init__(**kwargs)\n    self.mappings = mappings\n    self.current_hunk_index = 0\n    self.hunk_widgets: List[HunkMappingWidget] = []\n    self._selected_widget: HunkMappingWidget | None = None\n    self._diff_viewer: DiffViewer | None = None\n</code></pre> <code>compose() -&gt; ComposeResult</code> \u00b6 <p>Compose the screen layout.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compose the screen layout.\"\"\"\n    yield Header()\n\n    with Container(id=\"main-container\"):\n        # Title and summary\n        yield Static(\"Hunk to Commit Mapping Review\", id=\"screen-title\")\n        yield Static(\n            f\"Review {len(self.mappings)} hunks and their target commits. \"\n            \"Use checkboxes to approve/reject individual hunks.\",\n            id=\"screen-description\",\n        )\n\n        # Progress indicator\n        yield ProgressIndicator(len(self.mappings), id=\"progress\")\n\n        # Main content area\n        with Horizontal(id=\"content-area\"):\n            # Left panel: Hunk list\n            with Vertical(id=\"hunk-list-panel\"):\n                yield Static(\"Hunks\", id=\"hunk-list-title\")\n                with VerticalScroll(id=\"hunk-list\"):\n                    for mapping in self.mappings:\n                        hunk_widget = HunkMappingWidget(mapping)\n                        self.hunk_widgets.append(hunk_widget)\n                        yield hunk_widget\n\n            # Right panel: Diff viewer\n            with Vertical(id=\"diff-panel\"):\n                yield Static(\"Diff Preview\", id=\"diff-title\")\n                yield DiffViewer(id=\"diff-viewer\")\n\n        # Action buttons\n        with Horizontal(id=\"action-buttons\"):\n            yield Button(\n                \"Approve All &amp; Continue\", variant=\"success\", id=\"approve-all\"\n            )\n            yield Button(\"Continue with Selected\", variant=\"primary\", id=\"continue\")\n            yield Button(\"Cancel\", variant=\"default\", id=\"cancel\")\n\n    yield Footer()\n</code></pre> <code>on_mount() -&gt; None</code> \u00b6 <p>Handle screen mounting.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"Handle screen mounting.\"\"\"\n    # Cache diff viewer reference\n    self._diff_viewer = self.query_one(\"#diff-viewer\", DiffViewer)\n\n    # Select first hunk if available\n    if self.hunk_widgets:\n        self._select_widget(self.hunk_widgets[0])\n\n    # Update progress\n    self._update_progress()\n</code></pre> <code>on_hunk_selected(message: HunkMappingWidget.Selected) -&gt; None</code> \u00b6 <p>Handle hunk selection.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>@on(HunkMappingWidget.Selected)\ndef on_hunk_selected(self, message: HunkMappingWidget.Selected) -&gt; None:\n    \"\"\"Handle hunk selection.\"\"\"\n    # Find the clicked widget (optimized: avoid full iteration when possible)\n    target_widget = None\n    for i, widget in enumerate(self.hunk_widgets):\n        if widget.mapping == message.mapping:\n            target_widget = widget\n            self.current_hunk_index = i\n            break\n\n    if target_widget:\n        self._select_widget(target_widget)\n</code></pre> <code>on_approval_changed(message: HunkMappingWidget.ApprovalChanged) -&gt; None</code> \u00b6 <p>Handle approval status changes.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>@on(HunkMappingWidget.ApprovalChanged)\ndef on_approval_changed(self, message: HunkMappingWidget.ApprovalChanged) -&gt; None:\n    \"\"\"Handle approval status changes.\"\"\"\n    self._update_progress()\n</code></pre> <code>on_button_pressed(event: Button.Pressed) -&gt; None</code> \u00b6 <p>Handle button presses.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>@on(Button.Pressed)\ndef on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"approve-all\":\n        self.action_approve_all()\n    elif event.button.id == \"continue\":\n        self.action_continue()\n    elif event.button.id == \"cancel\":\n        self.action_cancel()\n</code></pre> <code>action_approve_all() -&gt; None</code> \u00b6 <p>Approve all hunks and continue.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def action_approve_all(self) -&gt; None:\n    \"\"\"Approve all hunks and continue.\"\"\"\n    for widget in self.hunk_widgets:\n        widget.approved = True\n        checkbox = widget.query_one(\"#approval\", Checkbox)\n        checkbox.value = True\n\n    self._update_progress()\n    approved_mappings = self.get_approved_mappings()\n    self.dismiss(approved_mappings)\n</code></pre> <code>action_approve_all_toggle() -&gt; None</code> \u00b6 <p>Toggle approval status of all hunks.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def action_approve_all_toggle(self) -&gt; None:\n    \"\"\"Toggle approval status of all hunks.\"\"\"\n    # Check if all are currently approved\n    all_approved = all(widget.approved for widget in self.hunk_widgets)\n    new_state = not all_approved\n\n    for widget in self.hunk_widgets:\n        widget.approved = new_state\n        checkbox = widget.query_one(\"#approval\", Checkbox)\n        checkbox.value = new_state\n\n    self._update_progress()\n</code></pre> <code>action_continue() -&gt; None</code> \u00b6 <p>Continue with currently selected hunks.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def action_continue(self) -&gt; None:\n    \"\"\"Continue with currently selected hunks.\"\"\"\n    approved_mappings = self.get_approved_mappings()\n    if not approved_mappings:\n        # No hunks approved, cannot continue\n        return\n\n    self.dismiss(approved_mappings)\n</code></pre> <code>action_cancel() -&gt; None</code> \u00b6 <p>Cancel the approval process.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def action_cancel(self) -&gt; None:\n    \"\"\"Cancel the approval process.\"\"\"\n    self.dismiss(False)\n</code></pre> <code>action_next_hunk() -&gt; None</code> \u00b6 <p>Select next hunk.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def action_next_hunk(self) -&gt; None:\n    \"\"\"Select next hunk.\"\"\"\n    if self.current_hunk_index &lt; len(self.hunk_widgets) - 1:\n        self.current_hunk_index += 1\n        self._select_hunk_by_index(self.current_hunk_index)\n</code></pre> <code>action_prev_hunk() -&gt; None</code> \u00b6 <p>Select previous hunk.</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def action_prev_hunk(self) -&gt; None:\n    \"\"\"Select previous hunk.\"\"\"\n    if self.current_hunk_index &gt; 0:\n        self.current_hunk_index -= 1\n        self._select_hunk_by_index(self.current_hunk_index)\n</code></pre> <code>get_approved_mappings() -&gt; List[HunkTargetMapping]</code> \u00b6 <p>Get list of approved mappings.</p> <p>Returns:</p> Type Description <code>List[HunkTargetMapping]</code> <p>List of mappings that user approved</p> Source code in <code>src/git_autosquash/tui/screens.py</code> <pre><code>def get_approved_mappings(self) -&gt; List[HunkTargetMapping]:\n    \"\"\"Get list of approved mappings.\n\n    Returns:\n        List of mappings that user approved\n    \"\"\"\n    return [widget.mapping for widget in self.hunk_widgets if widget.approved]\n</code></pre>"},{"location":"technical/api-reference/#widgets","title":"Widgets","text":"<p>Custom widgets for the TUI interface.</p>"},{"location":"technical/api-reference/#git_autosquash.tui.widgets","title":"<code>git_autosquash.tui.widgets</code>","text":"<p>Custom widgets for git-autosquash TUI.</p>"},{"location":"technical/api-reference/#git_autosquash.tui.widgets-classes","title":"Classes","text":""},{"location":"technical/api-reference/#git_autosquash.tui.widgets.HunkMappingWidget","title":"<code>HunkMappingWidget</code>","text":"<p>               Bases: <code>Widget</code></p> <p>Widget displaying a single hunk to commit mapping.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>class HunkMappingWidget(Widget):\n    \"\"\"Widget displaying a single hunk to commit mapping.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    HunkMappingWidget {\n        height: auto;\n        margin: 1 0;\n        border: round $primary;\n    }\n\n    HunkMappingWidget.selected {\n        border: thick $accent;\n    }\n\n    HunkMappingWidget .hunk-header {\n        background: $primary-background;\n        color: $primary;\n        text-style: bold;\n        padding: 0 1;\n    }\n\n    HunkMappingWidget .commit-info {\n        background: $secondary-background;\n        color: $text;\n        padding: 0 1;\n    }\n\n    HunkMappingWidget .confidence-high {\n        color: $success;\n    }\n\n    HunkMappingWidget .confidence-medium {\n        color: $warning;\n    }\n\n    HunkMappingWidget .confidence-low {\n        color: $error;\n    }\n    \"\"\"\n\n    selected = reactive(False)\n    approved = reactive(False)  # Default to unapproved for safety\n\n    class Selected(Message):\n        \"\"\"Message sent when hunk is selected.\"\"\"\n\n        def __init__(self, mapping: HunkTargetMapping) -&gt; None:\n            self.mapping = mapping\n            super().__init__()\n\n    class ApprovalChanged(Message):\n        \"\"\"Message sent when approval status changes.\"\"\"\n\n        def __init__(self, mapping: HunkTargetMapping, approved: bool) -&gt; None:\n            self.mapping = mapping\n            self.approved = approved\n            super().__init__()\n\n    def __init__(self, mapping: HunkTargetMapping, **kwargs) -&gt; None:\n        \"\"\"Initialize hunk mapping widget.\n\n        Args:\n            mapping: The hunk to commit mapping to display\n        \"\"\"\n        super().__init__(**kwargs)\n        self.mapping = mapping\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compose the widget layout.\"\"\"\n        with Vertical():\n            # Header with file and hunk info\n            hunk_info = f\"{self.mapping.hunk.file_path} @@ {self._format_hunk_range()}\"\n            yield Static(hunk_info, classes=\"hunk-header\")\n\n            # Target commit info\n            if self.mapping.target_commit:\n                commit_summary = f\"\u2192 {self.mapping.target_commit[:8]} \"\n                confidence_class = f\"confidence-{self.mapping.confidence}\"\n                commit_info = f\"{commit_summary} ({self.mapping.confidence} confidence)\"\n            else:\n                commit_info = \"\u2192 No target commit found\"\n                confidence_class = \"confidence-low\"\n\n            yield Static(commit_info, classes=f\"commit-info {confidence_class}\")\n\n            # Approval checkbox\n            with Horizontal():\n                yield Checkbox(\"Include in squash\", value=self.approved, id=\"approval\")\n\n    def _format_hunk_range(self) -&gt; str:\n        \"\"\"Format hunk line range for display.\"\"\"\n        hunk = self.mapping.hunk\n        return f\"-{hunk.old_start},{hunk.old_count} +{hunk.new_start},{hunk.new_count}\"\n\n    def on_click(self, event: events.Click) -&gt; None:\n        \"\"\"Handle click events.\"\"\"\n        self.selected = True\n        self.post_message(self.Selected(self.mapping))\n\n    def on_checkbox_changed(self, event: Checkbox.Changed) -&gt; None:\n        \"\"\"Handle checkbox changes.\"\"\"\n        self.approved = event.value\n        self.post_message(self.ApprovalChanged(self.mapping, event.value))\n\n    def watch_selected(self, selected: bool) -&gt; None:\n        \"\"\"React to selection changes.\"\"\"\n        self.set_class(selected, \"selected\")\n</code></pre> Classes\u00b6 <code>Selected</code> \u00b6 <p>               Bases: <code>Message</code></p> <p>Message sent when hunk is selected.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>class Selected(Message):\n    \"\"\"Message sent when hunk is selected.\"\"\"\n\n    def __init__(self, mapping: HunkTargetMapping) -&gt; None:\n        self.mapping = mapping\n        super().__init__()\n</code></pre> <code>ApprovalChanged</code> \u00b6 <p>               Bases: <code>Message</code></p> <p>Message sent when approval status changes.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>class ApprovalChanged(Message):\n    \"\"\"Message sent when approval status changes.\"\"\"\n\n    def __init__(self, mapping: HunkTargetMapping, approved: bool) -&gt; None:\n        self.mapping = mapping\n        self.approved = approved\n        super().__init__()\n</code></pre> Functions\u00b6 <code>__init__(mapping: HunkTargetMapping, **kwargs) -&gt; None</code> \u00b6 <p>Initialize hunk mapping widget.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>HunkTargetMapping</code> <p>The hunk to commit mapping to display</p> required Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def __init__(self, mapping: HunkTargetMapping, **kwargs) -&gt; None:\n    \"\"\"Initialize hunk mapping widget.\n\n    Args:\n        mapping: The hunk to commit mapping to display\n    \"\"\"\n    super().__init__(**kwargs)\n    self.mapping = mapping\n</code></pre> <code>compose() -&gt; ComposeResult</code> \u00b6 <p>Compose the widget layout.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compose the widget layout.\"\"\"\n    with Vertical():\n        # Header with file and hunk info\n        hunk_info = f\"{self.mapping.hunk.file_path} @@ {self._format_hunk_range()}\"\n        yield Static(hunk_info, classes=\"hunk-header\")\n\n        # Target commit info\n        if self.mapping.target_commit:\n            commit_summary = f\"\u2192 {self.mapping.target_commit[:8]} \"\n            confidence_class = f\"confidence-{self.mapping.confidence}\"\n            commit_info = f\"{commit_summary} ({self.mapping.confidence} confidence)\"\n        else:\n            commit_info = \"\u2192 No target commit found\"\n            confidence_class = \"confidence-low\"\n\n        yield Static(commit_info, classes=f\"commit-info {confidence_class}\")\n\n        # Approval checkbox\n        with Horizontal():\n            yield Checkbox(\"Include in squash\", value=self.approved, id=\"approval\")\n</code></pre> <code>on_click(event: events.Click) -&gt; None</code> \u00b6 <p>Handle click events.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def on_click(self, event: events.Click) -&gt; None:\n    \"\"\"Handle click events.\"\"\"\n    self.selected = True\n    self.post_message(self.Selected(self.mapping))\n</code></pre> <code>on_checkbox_changed(event: Checkbox.Changed) -&gt; None</code> \u00b6 <p>Handle checkbox changes.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def on_checkbox_changed(self, event: Checkbox.Changed) -&gt; None:\n    \"\"\"Handle checkbox changes.\"\"\"\n    self.approved = event.value\n    self.post_message(self.ApprovalChanged(self.mapping, event.value))\n</code></pre> <code>watch_selected(selected: bool) -&gt; None</code> \u00b6 <p>React to selection changes.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def watch_selected(self, selected: bool) -&gt; None:\n    \"\"\"React to selection changes.\"\"\"\n    self.set_class(selected, \"selected\")\n</code></pre>"},{"location":"technical/api-reference/#git_autosquash.tui.widgets.DiffViewer","title":"<code>DiffViewer</code>","text":"<p>               Bases: <code>Widget</code></p> <p>Widget for displaying diff content with syntax highlighting.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>class DiffViewer(Widget):\n    \"\"\"Widget for displaying diff content with syntax highlighting.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    DiffViewer {\n        border: round $primary;\n        padding: 1;\n    }\n\n    DiffViewer .diff-header {\n        color: $text-muted;\n        text-style: bold;\n    }\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        \"\"\"Initialize diff viewer.\"\"\"\n        super().__init__(**kwargs)\n        self._current_hunk: Optional[DiffHunk] = None\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compose the widget layout.\"\"\"\n        yield Static(\"Select a hunk to view diff\", id=\"diff-content\")\n\n    def show_hunk(self, hunk: DiffHunk) -&gt; None:\n        \"\"\"Display diff content for a hunk.\n\n        Args:\n            hunk: The hunk to display\n        \"\"\"\n        self._current_hunk = hunk\n\n        # Format diff content\n        diff_lines = []\n        for line in hunk.lines:\n            diff_lines.append(line)\n\n        diff_text = \"\\n\".join(diff_lines)\n\n        # Create syntax highlighted content\n        try:\n            # Use diff syntax highlighting regardless of file extension\n            # since we're showing diff output, not the original file\n            syntax = Syntax(diff_text, \"diff\", theme=\"monokai\", line_numbers=False)\n            content: Union[Syntax, Text] = syntax\n        except Exception:\n            # Fallback to plain text if syntax highlighting fails\n            content = Text(diff_text)\n\n        # Update the display\n        diff_widget = self.query_one(\"#diff-content\", Static)\n        diff_widget.update(content)\n\n    def _get_language_from_file(self, file_path: str) -&gt; str:\n        \"\"\"Get language identifier from file extension.\n\n        Args:\n            file_path: Path to the file\n\n        Returns:\n            Language identifier for syntax highlighting\n        \"\"\"\n        extension = file_path.split(\".\")[-1].lower()\n\n        language_map = {\n            \"py\": \"python\",\n            \"js\": \"javascript\",\n            \"ts\": \"typescript\",\n            \"jsx\": \"jsx\",\n            \"tsx\": \"tsx\",\n            \"java\": \"java\",\n            \"c\": \"c\",\n            \"cpp\": \"cpp\",\n            \"cc\": \"cpp\",\n            \"h\": \"c\",\n            \"hpp\": \"cpp\",\n            \"rs\": \"rust\",\n            \"go\": \"go\",\n            \"rb\": \"ruby\",\n            \"php\": \"php\",\n            \"sh\": \"bash\",\n            \"bash\": \"bash\",\n            \"zsh\": \"bash\",\n            \"fish\": \"bash\",\n            \"ps1\": \"powershell\",\n            \"html\": \"html\",\n            \"css\": \"css\",\n            \"scss\": \"scss\",\n            \"sass\": \"sass\",\n            \"less\": \"less\",\n            \"json\": \"json\",\n            \"yaml\": \"yaml\",\n            \"yml\": \"yaml\",\n            \"xml\": \"xml\",\n            \"md\": \"markdown\",\n            \"sql\": \"sql\",\n        }\n\n        return language_map.get(extension, \"text\")\n</code></pre> Functions\u00b6 <code>__init__(**kwargs) -&gt; None</code> \u00b6 <p>Initialize diff viewer.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"Initialize diff viewer.\"\"\"\n    super().__init__(**kwargs)\n    self._current_hunk: Optional[DiffHunk] = None\n</code></pre> <code>compose() -&gt; ComposeResult</code> \u00b6 <p>Compose the widget layout.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compose the widget layout.\"\"\"\n    yield Static(\"Select a hunk to view diff\", id=\"diff-content\")\n</code></pre> <code>show_hunk(hunk: DiffHunk) -&gt; None</code> \u00b6 <p>Display diff content for a hunk.</p> <p>Parameters:</p> Name Type Description Default <code>hunk</code> <code>DiffHunk</code> <p>The hunk to display</p> required Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def show_hunk(self, hunk: DiffHunk) -&gt; None:\n    \"\"\"Display diff content for a hunk.\n\n    Args:\n        hunk: The hunk to display\n    \"\"\"\n    self._current_hunk = hunk\n\n    # Format diff content\n    diff_lines = []\n    for line in hunk.lines:\n        diff_lines.append(line)\n\n    diff_text = \"\\n\".join(diff_lines)\n\n    # Create syntax highlighted content\n    try:\n        # Use diff syntax highlighting regardless of file extension\n        # since we're showing diff output, not the original file\n        syntax = Syntax(diff_text, \"diff\", theme=\"monokai\", line_numbers=False)\n        content: Union[Syntax, Text] = syntax\n    except Exception:\n        # Fallback to plain text if syntax highlighting fails\n        content = Text(diff_text)\n\n    # Update the display\n    diff_widget = self.query_one(\"#diff-content\", Static)\n    diff_widget.update(content)\n</code></pre>"},{"location":"technical/api-reference/#git_autosquash.tui.widgets.ProgressIndicator","title":"<code>ProgressIndicator</code>","text":"<p>               Bases: <code>Widget</code></p> <p>Widget showing progress through hunk approvals.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>class ProgressIndicator(Widget):\n    \"\"\"Widget showing progress through hunk approvals.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    ProgressIndicator {\n        height: 1;\n        background: $panel;\n        color: $text;\n        text-align: center;\n    }\n    \"\"\"\n\n    def __init__(self, total_hunks: int, **kwargs) -&gt; None:\n        \"\"\"Initialize progress indicator.\n\n        Args:\n            total_hunks: Total number of hunks to process\n        \"\"\"\n        super().__init__(**kwargs)\n        self.total_hunks = total_hunks\n        self.approved_count = 0\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compose the widget layout.\"\"\"\n        yield Static(self._format_progress(), id=\"progress-text\")\n\n    def update_progress(self, approved_count: int) -&gt; None:\n        \"\"\"Update the progress display.\n\n        Args:\n            approved_count: Number of hunks approved so far\n        \"\"\"\n        self.approved_count = approved_count\n        progress_widget = self.query_one(\"#progress-text\", Static)\n        progress_widget.update(self._format_progress())\n\n    def _format_progress(self) -&gt; str:\n        \"\"\"Format progress text.\"\"\"\n        percentage = (\n            (self.approved_count / self.total_hunks * 100)\n            if self.total_hunks &gt; 0\n            else 0\n        )\n        return f\"Progress: {self.approved_count}/{self.total_hunks} approved ({percentage:.0f}%)\"\n</code></pre> Functions\u00b6 <code>__init__(total_hunks: int, **kwargs) -&gt; None</code> \u00b6 <p>Initialize progress indicator.</p> <p>Parameters:</p> Name Type Description Default <code>total_hunks</code> <code>int</code> <p>Total number of hunks to process</p> required Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def __init__(self, total_hunks: int, **kwargs) -&gt; None:\n    \"\"\"Initialize progress indicator.\n\n    Args:\n        total_hunks: Total number of hunks to process\n    \"\"\"\n    super().__init__(**kwargs)\n    self.total_hunks = total_hunks\n    self.approved_count = 0\n</code></pre> <code>compose() -&gt; ComposeResult</code> \u00b6 <p>Compose the widget layout.</p> Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compose the widget layout.\"\"\"\n    yield Static(self._format_progress(), id=\"progress-text\")\n</code></pre> <code>update_progress(approved_count: int) -&gt; None</code> \u00b6 <p>Update the progress display.</p> <p>Parameters:</p> Name Type Description Default <code>approved_count</code> <code>int</code> <p>Number of hunks approved so far</p> required Source code in <code>src/git_autosquash/tui/widgets.py</code> <pre><code>def update_progress(self, approved_count: int) -&gt; None:\n    \"\"\"Update the progress display.\n\n    Args:\n        approved_count: Number of hunks approved so far\n    \"\"\"\n    self.approved_count = approved_count\n    progress_widget = self.query_one(\"#progress-text\", Static)\n    progress_widget.update(self._format_progress())\n</code></pre>"},{"location":"technical/api-reference/#usage-examples","title":"Usage Examples","text":""},{"location":"technical/api-reference/#basic-api-usage","title":"Basic API Usage","text":"<p>Here's how to use the core components programmatically:</p> <pre><code>from git_autosquash.git_ops import GitOps\nfrom git_autosquash.hunk_parser import HunkParser\nfrom git_autosquash.blame_analyzer import BlameAnalyzer\n\n# Initialize components\ngit_ops = GitOps(\".\")\nhunk_parser = HunkParser(git_ops)\nblame_analyzer = BlameAnalyzer(git_ops, \"main\")\n\n# Get diff hunks\nhunks = hunk_parser.get_diff_hunks()\n\n# Analyze hunks to find target commits\nmappings = blame_analyzer.analyze_hunks(hunks)\n\n# Print results\nfor mapping in mappings:\n    print(f\"{mapping.hunk.file_path}: {mapping.target_commit} ({mapping.confidence})\")\n</code></pre>"},{"location":"technical/api-reference/#custom-tui-integration","title":"Custom TUI Integration","text":"<pre><code>from git_autosquash.tui.app import AutoSquashApp\n\n# Create custom TUI with your mappings\napp = AutoSquashApp(mappings)\napproved = app.run()\n\nif approved and app.approved_mappings:\n    print(f\"User approved {len(app.approved_mappings)} hunks\")\n    # Process approved mappings...\n</code></pre>"},{"location":"technical/api-reference/#rebase-execution","title":"Rebase Execution","text":"<pre><code>from git_autosquash.rebase_manager import RebaseManager, RebaseConflictError\n\ntry:\n    rebase_manager = RebaseManager(git_ops, merge_base)\n    success = rebase_manager.execute_squash(approved_mappings)\n\n    if success:\n        print(\"Squash operation completed successfully!\")\n    else:\n        print(\"Operation was cancelled by user\")\n\nexcept RebaseConflictError as e:\n    print(f\"Conflicts in: {', '.join(e.conflicted_files)}\")\n    # Handle conflicts...\n</code></pre>"},{"location":"technical/api-reference/#type-definitions","title":"Type Definitions","text":""},{"location":"technical/api-reference/#common-types","title":"Common Types","text":"<pre><code>from typing import List, Dict, Optional, Set\n\n# Confidence levels\nConfidenceLevel = Literal[\"high\", \"medium\", \"low\"]\n\n# Working tree status\nWorkingTreeStatus = Dict[str, bool]  # {\"is_clean\": bool, \"has_staged\": bool, \"has_unstaged\": bool}\n\n# Rebase status information\nRebaseStatus = Dict[str, Any]  # {\"in_progress\": bool, \"conflicted_files\": List[str], ...}\n</code></pre>"},{"location":"technical/api-reference/#error-types","title":"Error Types","text":"<p>All components raise specific exception types for different error conditions:</p> <ul> <li>GitOps: <code>subprocess.SubprocessError</code> for Git command failures</li> <li>HunkParser: <code>ValueError</code> for parsing errors</li> <li>BlameAnalyzer: <code>subprocess.SubprocessError</code> for blame failures  </li> <li>RebaseManager: <code>RebaseConflictError</code> for merge conflicts</li> <li>TUI: Standard Textual exceptions for interface errors</li> </ul>"},{"location":"technical/api-reference/#configuration-options","title":"Configuration Options","text":""},{"location":"technical/api-reference/#environment-variables","title":"Environment Variables","text":"<p>git-autosquash respects these environment variables:</p> <ul> <li><code>GIT_SEQUENCE_EDITOR</code>: Custom editor for interactive rebase (automatically managed)</li> <li><code>TERM</code>: Terminal type for TUI rendering</li> <li><code>NO_COLOR</code>: Disable colored output when set</li> </ul>"},{"location":"technical/api-reference/#git-configuration","title":"Git Configuration","text":"<p>The following Git configuration affects git-autosquash behavior:</p> <ul> <li><code>core.editor</code>: Default editor for conflict resolution</li> <li><code>merge.tool</code>: Merge tool for resolving conflicts</li> <li><code>rebase.autoStash</code>: Automatic stashing during rebase (overridden by git-autosquash)</li> </ul>"},{"location":"technical/api-reference/#performance-considerations","title":"Performance Considerations","text":""},{"location":"technical/api-reference/#caching","title":"Caching","text":"<p>Several operations are cached for performance:</p> <ul> <li>Branch commits: Expensive <code>git rev-list</code> operations</li> <li>Commit timestamps: <code>git show</code> calls for chronological ordering</li> <li>Commit summaries: <code>git log</code> output for display</li> </ul>"},{"location":"technical/api-reference/#memory-usage","title":"Memory Usage","text":"<ul> <li>Diff parsing: Streams large diffs to avoid memory issues</li> <li>Blame analysis: Processes hunks individually to limit memory usage</li> <li>TUI rendering: Efficient widget updates and syntax highlighting</li> </ul>"},{"location":"technical/api-reference/#git-operation-optimization","title":"Git Operation Optimization","text":"<ul> <li>Batch operations: Groups related Git commands where possible</li> <li>Subprocess management: Proper timeout and resource cleanup</li> <li>Working directory: Minimal file I/O and temporary file usage</li> </ul>"},{"location":"technical/api-reference/#testing-the-api","title":"Testing the API","text":"<p>The API components are extensively tested. To run tests for specific components:</p> <pre><code># Test specific components\nuv run pytest tests/test_git_ops.py -v\nuv run pytest tests/test_hunk_parser.py -v\nuv run pytest tests/test_blame_analyzer.py -v\nuv run pytest tests/test_rebase_manager.py -v\n\n# Test with coverage\nuv run pytest --cov=git_autosquash tests/\n</code></pre>"},{"location":"technical/api-reference/#contributing-to-the-api","title":"Contributing to the API","text":"<p>When extending the API:</p> <ol> <li>Follow existing patterns: Maintain consistency with current design</li> <li>Add comprehensive docstrings: Use Google style docstrings</li> <li>Include type annotations: Full typing for all public methods</li> <li>Write tests: Unit tests with appropriate mocking</li> <li>Update documentation: This reference updates automatically from docstrings</li> </ol>"},{"location":"technical/architecture/","title":"Architecture Overview","text":"<p>git-autosquash is designed as a modular system with clear separation of concerns. This document provides a comprehensive overview of the system architecture, component interactions, and design decisions.</p>"},{"location":"technical/architecture/#system-overview","title":"System Overview","text":"<pre><code>graph TB\n    subgraph \"CLI Layer\"\n        A[main.py] --&gt; B[Argument Parsing]\n        B --&gt; C[Repository Validation]\n    end\n\n    subgraph \"Core Processing\"\n        C --&gt; D[GitOps]\n        D --&gt; E[HunkParser] \n        E --&gt; F[BlameAnalyzer]\n    end\n\n    subgraph \"User Interface\"\n        F --&gt; G[AutoSquashApp]\n        G --&gt; H[ApprovalScreen]\n        H --&gt; I[Widgets]\n    end\n\n    subgraph \"Execution Layer\"\n        I --&gt; J[RebaseManager]\n        J --&gt; K[Interactive Rebase]\n        K --&gt; L[Conflict Resolution]\n    end\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style J fill:#e8f5e8</code></pre>"},{"location":"technical/architecture/#core-components","title":"Core Components","text":""},{"location":"technical/architecture/#1-gitops-git_opspy","title":"1. GitOps (<code>git_ops.py</code>)","text":"<p>Purpose: Central interface for all Git operations with proper error handling and subprocess management.</p> <p>Key Responsibilities: - Repository validation and branch detection - Working tree status analysis - Git command execution with timeout and error handling - Merge base calculation and commit validation</p> <p>Design Patterns: - Facade Pattern: Simplifies complex Git interactions - Error Handling: Comprehensive subprocess error management - Caching: Intelligent caching of expensive Git operations</p> <pre><code>class GitOps:\n    def __init__(self, repo_path: str = \".\") -&gt; None\n    def is_git_repo(self) -&gt; bool\n    def get_current_branch(self) -&gt; str | None\n    def get_merge_base_with_main(self, current_branch: str) -&gt; str | None\n    def get_working_tree_status(self) -&gt; dict[str, bool]\n    def run_git_command(self, args: list[str], env: dict[str, str] | None = None) -&gt; subprocess.CompletedProcess[str]\n</code></pre>"},{"location":"technical/architecture/#2-hunkparser-hunk_parserpy","title":"2. HunkParser (<code>hunk_parser.py</code>)","text":"<p>Purpose: Parses Git diff output into structured hunk objects for analysis and processing.</p> <p>Key Responsibilities: - Parse <code>git diff</code> output into structured <code>DiffHunk</code> objects - Support both default and line-by-line hunk splitting modes - Extract file context and line range information - Handle various diff formats and edge cases</p> <p>Design Decisions: - Immutable Data Structures: <code>DiffHunk</code> objects are immutable for safety - Flexible Parsing: Supports multiple diff modes and contexts - Line Preservation: Maintains exact line content including whitespace</p> <pre><code>@dataclass(frozen=True)\nclass DiffHunk:\n    file_path: str\n    old_start: int\n    old_count: int  \n    new_start: int\n    new_count: int\n    lines: list[str]\n    context_before: list[str]\n    context_after: list[str]\n</code></pre>"},{"location":"technical/architecture/#3-blameanalyzer-blame_analyzerpy","title":"3. BlameAnalyzer (<code>blame_analyzer.py</code>)","text":"<p>Purpose: Analyzes Git blame information to determine target commits for each hunk with confidence scoring.</p> <p>Key Responsibilities: - Run git blame analysis on hunk line ranges - Determine most frequent commit for each hunk (frequency-first algorithm) - Filter commits to branch scope (merge-base to HEAD) - Calculate confidence levels based on blame consistency - Cache commit metadata for performance</p> <p>Algorithm Design: - Frequency-First Scoring: Prioritizes commits that modified the most lines - Recency Tiebreaking: Uses commit timestamps to break frequency ties - Branch Scoping: Only considers commits on current branch since merge-base</p> <pre><code>class BlameAnalyzer:\n    def analyze_hunks(self, hunks: List[DiffHunk]) -&gt; List[HunkTargetMapping]\n    def _analyze_single_hunk(self, hunk: DiffHunk) -&gt; HunkTargetMapping\n    def _get_branch_commits(self) -&gt; Set[str]  # Cached\n    def _get_commit_timestamp(self, commit_hash: str) -&gt; int  # Cached\n</code></pre>"},{"location":"technical/architecture/#4-tui-system-tui","title":"4. TUI System (<code>tui/</code>)","text":"<p>Purpose: Rich terminal interface using Textual framework for user interaction and approval workflow.</p> <p>Component Structure:</p> <pre><code>graph TD\n    A[AutoSquashApp] --&gt; B[ApprovalScreen]\n    B --&gt; C[HunkMappingWidget]\n    B --&gt; D[DiffViewer] \n    B --&gt; E[ProgressIndicator]\n\n    C --&gt; F[Checkbox]\n    C --&gt; G[Static Text]\n    D --&gt; H[Syntax Highlighting]\n    E --&gt; I[Progress Display]</code></pre> <p>Key Design Principles: - Reactive UI: Real-time updates based on user interactions - Safety Defaults: All hunks start unapproved requiring explicit consent - Keyboard Navigation: Full keyboard control for efficient workflows - Graceful Fallback: Text-based fallback when TUI unavailable</p>"},{"location":"technical/architecture/#5-rebasemanager-rebase_managerpy","title":"5. RebaseManager (<code>rebase_manager.py</code>)","text":"<p>Purpose: Orchestrates interactive rebase operations to apply approved hunks to historical commits.</p> <p>Key Responsibilities: - Group hunks by target commit for batch processing - Execute interactive rebase with chronological ordering - Handle stash/unstash operations for working tree management - Detect and report conflicts with resolution guidance - Provide automatic rollback on errors or interruption</p> <p>Execution Flow: 1. Preparation: Stash uncommitted changes, validate branch state 2. Grouping: Organize hunks by target commit hash 3. Ordering: Sort commits chronologically (oldest first) for history integrity 4. Processing: For each commit:    - Start interactive rebase to edit the commit    - Apply hunk patches using <code>git apply</code>    - Amend the commit with new changes    - Continue rebase to next commit 5. Cleanup: Restore stash, handle any remaining cleanup</p> <p>Error Handling Strategy: - Conflict Detection: Identify merge conflicts and pause with guidance - Automatic Rollback: Restore repository state on errors or cancellation - Resource Cleanup: Ensure temporary files and stashes are properly cleaned up</p>"},{"location":"technical/architecture/#data-flow","title":"Data Flow","text":""},{"location":"technical/architecture/#1-input-processing","title":"1. Input Processing","text":"<pre><code>sequenceDiagram\n    participant CLI as main.py\n    participant Git as GitOps\n    participant Parser as HunkParser\n\n    CLI-&gt;&gt;Git: Validate repository\n    Git-&gt;&gt;CLI: Repository status\n    CLI-&gt;&gt;Git: Get working tree changes\n    Git-&gt;&gt;Parser: Raw diff output\n    Parser-&gt;&gt;CLI: Structured DiffHunk objects</code></pre>"},{"location":"technical/architecture/#2-analysis-phase","title":"2. Analysis Phase","text":"<pre><code>sequenceDiagram\n    participant CLI as main.py\n    participant Blame as BlameAnalyzer\n    participant Git as GitOps\n\n    CLI-&gt;&gt;Blame: analyze_hunks(hunks)\n    loop For each hunk\n        Blame-&gt;&gt;Git: git blame &lt;lines&gt;\n        Git-&gt;&gt;Blame: Blame output\n        Blame-&gt;&gt;Blame: Find target commit\n        Blame-&gt;&gt;Blame: Calculate confidence\n    end\n    Blame-&gt;&gt;CLI: HunkTargetMapping list</code></pre>"},{"location":"technical/architecture/#3-user-approval","title":"3. User Approval","text":"<pre><code>sequenceDiagram\n    participant CLI as main.py\n    participant App as AutoSquashApp\n    participant Screen as ApprovalScreen\n    participant User as User\n\n    CLI-&gt;&gt;App: Launch TUI with mappings\n    App-&gt;&gt;Screen: Create approval screen\n    Screen-&gt;&gt;User: Show hunk mappings\n    User-&gt;&gt;Screen: Review and approve hunks\n    Screen-&gt;&gt;App: Approved mappings\n    App-&gt;&gt;CLI: User decisions</code></pre>"},{"location":"technical/architecture/#4-execution-phase","title":"4. Execution Phase","text":"<pre><code>sequenceDiagram\n    participant CLI as main.py\n    participant Rebase as RebaseManager\n    participant Git as GitOps\n\n    CLI-&gt;&gt;Rebase: execute_squash(mappings)\n    Rebase-&gt;&gt;Rebase: Group hunks by commit\n    Rebase-&gt;&gt;Rebase: Order commits chronologically\n    loop For each target commit\n        Rebase-&gt;&gt;Git: Start interactive rebase\n        Rebase-&gt;&gt;Git: Apply hunk patches\n        Rebase-&gt;&gt;Git: Amend commit\n        Rebase-&gt;&gt;Git: Continue rebase\n    end\n    Rebase-&gt;&gt;CLI: Success/failure result</code></pre>"},{"location":"technical/architecture/#design-patterns-and-principles","title":"Design Patterns and Principles","text":""},{"location":"technical/architecture/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<p>Each component has a single, well-defined responsibility: - GitOps: Git command interface - HunkParser: Diff parsing and structure - BlameAnalyzer: Blame analysis and targeting - TUI Components: User interface and interaction - RebaseManager: Rebase orchestration and execution</p>"},{"location":"technical/architecture/#2-error-handling-strategy","title":"2. Error Handling Strategy","text":"<p>Defensive Programming: - Validate all inputs at component boundaries - Handle subprocess failures gracefully - Provide meaningful error messages to users - Implement automatic rollback mechanisms</p> <p>Error Categories: - User Errors: Invalid repository state, detached HEAD - Git Errors: Command failures, conflicts, repository issues - System Errors: File I/O, permissions, resource constraints - Interruption: User cancellation, keyboard interrupt</p>"},{"location":"technical/architecture/#3-performance-optimizations","title":"3. Performance Optimizations","text":"<p>Caching Strategy: - Commit metadata: Timestamps and summaries cached to avoid repeated Git calls - Branch commits: Expensive commit list operations cached per session - Blame results: Reuse blame data across multiple hunk analyses</p> <p>Resource Management: - Subprocess timeouts: Prevent hanging on Git operations - Temporary file cleanup: Automatic cleanup of patches and todo files - Memory efficiency: Stream processing of large diffs when possible</p>"},{"location":"technical/architecture/#4-testing-architecture","title":"4. Testing Architecture","text":"<p>Test Categories: - Unit Tests: Individual component functionality with mocking - Integration Tests: Component interaction with real Git repositories - TUI Tests: User interface behavior without DOM dependencies - End-to-End Tests: Complete workflow simulation</p> <p>Test Infrastructure: - Mocking Strategy: Mock Git operations for reliable, fast tests - Test Data: Structured test repositories and diff scenarios - Edge Case Coverage: Boundary conditions and error scenarios</p>"},{"location":"technical/architecture/#configuration-and-extensibility","title":"Configuration and Extensibility","text":""},{"location":"technical/architecture/#future-extension-points","title":"Future Extension Points","text":"<ol> <li>Configuration System: </li> <li>User preferences for approval defaults</li> <li>Custom confidence thresholds</li> <li> <p>Blame analysis parameters</p> </li> <li> <p>Plugin Architecture:</p> </li> <li>Custom hunk filtering rules</li> <li>Alternative conflict resolution strategies  </li> <li> <p>Integration with external tools</p> </li> <li> <p>Output Formats:</p> </li> <li>JSON output for tooling integration</li> <li>Structured logging for automation</li> <li>Custom report generation</li> </ol>"},{"location":"technical/architecture/#security-considerations","title":"Security Considerations","text":""},{"location":"technical/architecture/#git-command-safety","title":"Git Command Safety","text":"<ul> <li>Command Injection Prevention: All Git arguments properly escaped</li> <li>Repository Validation: Verify repository integrity before operations</li> <li>Branch Protection: Only operate on feature branches with clear merge-base</li> </ul>"},{"location":"technical/architecture/#data-integrity","title":"Data Integrity","text":"<ul> <li>Atomic Operations: Rebase operations are atomic where possible</li> <li>Backup Strategy: Automatic stashing preserves user work  </li> <li>Rollback Capability: Complete restoration on failure or cancellation</li> </ul>"},{"location":"technical/architecture/#user-safety","title":"User Safety","text":"<ul> <li>Default Deny: All operations require explicit user approval</li> <li>Clear Feedback: Detailed progress and error reporting</li> <li>Escape Mechanisms: Multiple ways to safely abort operations</li> </ul> <p>This architecture provides a robust, maintainable foundation for git-autosquash while supporting future enhancements and ensuring user safety throughout the workflow.</p>"},{"location":"technical/development/","title":"Development Guide","text":"<p>This guide covers the technical aspects of developing and contributing to git-autosquash.</p>"},{"location":"technical/development/#project-architecture","title":"Project Architecture","text":""},{"location":"technical/development/#core-components","title":"Core Components","text":"<pre><code>src/git_autosquash/\n\u251c\u2500\u2500 __init__.py              # Package initialization\n\u251c\u2500\u2500 main.py                  # CLI entry point and argument parsing  \n\u251c\u2500\u2500 git_ops.py              # Git operations facade\n\u251c\u2500\u2500 hunk_parser.py          # Diff parsing and hunk extraction\n\u251c\u2500\u2500 blame_analyzer.py       # Git blame analysis and target resolution\n\u251c\u2500\u2500 rebase_manager.py       # Interactive rebase execution\n\u2514\u2500\u2500 tui/                    # Terminal User Interface\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 app.py              # Main Textual application\n    \u251c\u2500\u2500 screens.py          # Approval screen implementation  \n    \u2514\u2500\u2500 widgets.py          # Custom TUI widgets\n</code></pre>"},{"location":"technical/development/#data-flow-architecture","title":"Data Flow Architecture","text":"<pre><code>graph TD\n    A[CLI Entry Point] --&gt; B[Git Repository Validation]\n    B --&gt; C[Working Tree Analysis]  \n    C --&gt; D[Diff Parsing]\n    D --&gt; E[Hunk Extraction]\n    E --&gt; F[Git Blame Analysis]\n    F --&gt; G[Target Commit Resolution]\n    G --&gt; H[TUI Display]\n    H --&gt; I{User Approval?}\n    I --&gt;|Yes| J[Interactive Rebase]\n    I --&gt;|No| K[Exit]\n    J --&gt; L[Conflict Resolution]\n    L --&gt; M[Completion]</code></pre>"},{"location":"technical/development/#module-responsibilities","title":"Module Responsibilities","text":""},{"location":"technical/development/#git_opspy-git-operations-facade","title":"<code>git_ops.py</code> - Git Operations Facade","text":"<ul> <li>Repository validation and status checking</li> <li>Git command execution with error handling</li> <li>Branch analysis and merge-base calculation</li> <li>Working tree state management</li> </ul>"},{"location":"technical/development/#hunk_parserpy-diff-analysis","title":"<code>hunk_parser.py</code> - Diff Analysis","text":"<ul> <li>Parse <code>git diff</code> output into structured hunks</li> <li>Handle both standard and line-by-line splitting modes</li> <li>Preserve file paths, line numbers, and change content</li> <li>Support various diff formats and edge cases</li> </ul>"},{"location":"technical/development/#blame_analyzerpy-target-resolution","title":"<code>blame_analyzer.py</code> - Target Resolution","text":"<ul> <li>Execute <code>git blame</code> on hunk line ranges</li> <li>Analyze blame results to find target commits</li> <li>Apply frequency-based selection with recency tiebreaker</li> <li>Filter results by branch scope (merge-base to HEAD)</li> </ul>"},{"location":"technical/development/#rebase_managerpy-rebase-orchestration","title":"<code>rebase_manager.py</code> - Rebase Orchestration","text":"<ul> <li>Group approved hunks by target commit</li> <li>Generate interactive rebase todo lists</li> <li>Execute rebase operations with conflict handling</li> <li>Manage stash/unstash for staged-only workflows</li> </ul>"},{"location":"technical/development/#tui-terminal-user-interface","title":"<code>tui/</code> - Terminal User Interface","text":"<ul> <li>Rich terminal interface using Textual framework</li> <li>Interactive approval/rejection of hunk mappings</li> <li>Diff display with syntax highlighting</li> <li>Progress indicators and status updates</li> </ul>"},{"location":"technical/development/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"technical/development/#prerequisites","title":"Prerequisites","text":"<pre><code># Required tools\ngit --version     # 2.25+\npython --version  # 3.9+\nuv --version      # Latest\n\n# Optional but recommended\npre-commit --version\nruff --version\nmypy --version\n</code></pre>"},{"location":"technical/development/#initial-setup","title":"Initial Setup","text":"<pre><code># Clone repository\ngit clone https://github.com/andrewleech/git-autosquash.git\ncd git-autosquash\n\n# Install in development mode with dependencies\nuv pip install -e \".[dev]\"\n\n# Install pre-commit hooks (REQUIRED)\nuv run pre-commit install\n\n# Verify installation\ngit-autosquash --version\nuv run pytest --version\n</code></pre>"},{"location":"technical/development/#development-dependencies","title":"Development Dependencies","text":"<p>Key development dependencies managed in <code>pyproject.toml</code>:</p> <pre><code>[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.0\",\n    \"pytest-cov&gt;=4.0\", \n    \"pytest-mock&gt;=3.10\",\n    \"mypy&gt;=1.0\",\n    \"ruff&gt;=0.1.0\",\n    \"pre-commit&gt;=3.0\",\n    \"textual-dev&gt;=1.2.0\",\n]\n</code></pre>"},{"location":"technical/development/#code-quality-standards","title":"Code Quality Standards","text":""},{"location":"technical/development/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>All commits must pass pre-commit hooks. Never use <code>git commit --no-verify</code>.</p> <pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.1.6\n    hooks:\n      - id: ruff\n        args: [--fix, --exit-non-zero-on-fix]\n      - id: ruff-format\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.7.1\n    hooks:\n      - id: mypy\n        additional_dependencies: [textual]\n</code></pre>"},{"location":"technical/development/#code-style","title":"Code Style","text":"<p>Formatting: Managed by <code>ruff format</code> - Line length: 88 characters - String quotes: Double quotes preferred - Import sorting: Automatic via ruff</p> <p>Linting: Managed by <code>ruff check</code> - Based on flake8, pycodestyle, pyflakes - Additional rules: unused imports, complexity limits - Automatic fixes applied where possible</p> <p>Type Checking: Managed by <code>mypy</code> - Strict mode enabled - All public functions must have type annotations - Generic types properly specified</p>"},{"location":"technical/development/#example-code-standards","title":"Example Code Standards","text":"<pre><code>from __future__ import annotations\n\nfrom typing import List, Optional, Tuple\nimport subprocess\nfrom pathlib import Path\n\nclass GitOps:\n    \"\"\"Git operations facade with comprehensive error handling.\"\"\"\n\n    def __init__(self, repo_path: Path) -&gt; None:\n        \"\"\"Initialize git operations for repository.\n\n        Args:\n            repo_path: Path to git repository root\n\n        Raises:\n            ValueError: If path is not a git repository\n        \"\"\"\n        self._repo_path = repo_path\n        self._validate_repository()\n\n    def get_diff_hunks(\n        self, \n        staged_only: bool = False,\n        line_by_line: bool = False\n    ) -&gt; List[DiffHunk]:\n        \"\"\"Extract diff hunks from working tree or staging area.\n\n        Args:\n            staged_only: Only include staged changes\n            line_by_line: Split hunks into individual lines\n\n        Returns:\n            List of structured diff hunks\n\n        Raises:\n            GitError: If git command fails\n        \"\"\"\n        # Implementation with proper error handling\n        pass\n</code></pre>"},{"location":"technical/development/#testing-strategy","title":"Testing Strategy","text":""},{"location":"technical/development/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Pytest configuration and fixtures\n\u251c\u2500\u2500 test_git_ops.py          # Git operations tests\n\u251c\u2500\u2500 test_hunk_parser.py      # Diff parsing tests\n\u251c\u2500\u2500 test_blame_analyzer.py   # Blame analysis tests\n\u251c\u2500\u2500 test_rebase_manager.py   # Rebase execution tests\n\u251c\u2500\u2500 tui/\n\u2502   \u251c\u2500\u2500 test_app.py          # TUI application tests\n\u2502   \u251c\u2500\u2500 test_screens.py      # Screen interaction tests\n\u2502   \u2514\u2500\u2500 test_widgets.py      # Widget behavior tests\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 test_full_workflow.py # End-to-end workflow tests\n    \u2514\u2500\u2500 test_complex_scenarios.py # Complex scenario tests\n</code></pre>"},{"location":"technical/development/#test-categories","title":"Test Categories","text":""},{"location":"technical/development/#unit-tests","title":"Unit Tests","text":"<p>Focus on individual components in isolation:</p> <pre><code>def test_hunk_parser_basic_diff(mock_git_diff):\n    \"\"\"Test parsing basic git diff output.\"\"\"\n    parser = HunkParser()\n    hunks = parser.parse_diff(mock_git_diff)\n\n    assert len(hunks) == 2\n    assert hunks[0].file_path == \"src/example.py\"\n    assert hunks[0].line_range == (10, 15)\n</code></pre>"},{"location":"technical/development/#integration-tests","title":"Integration Tests","text":"<p>Test component interactions with git repositories:</p> <pre><code>def test_full_workflow_with_real_repo(tmp_git_repo):\n    \"\"\"Test complete workflow on temporary git repository.\"\"\"\n    # Setup repository with commits and changes\n    create_test_commits(tmp_git_repo)\n    make_test_changes(tmp_git_repo)\n\n    # Run git-autosquash workflow\n    result = run_autosquash(tmp_git_repo, approve_all=True)\n\n    # Verify results\n    assert result.success\n    assert len(result.conflicts) == 0\n    verify_commit_organization(tmp_git_repo)\n</code></pre>"},{"location":"technical/development/#tui-tests","title":"TUI Tests","text":"<p>Test terminal interface components:</p> <pre><code>async def test_approval_screen_navigation():\n    \"\"\"Test keyboard navigation in approval screen.\"\"\"\n    app = AutoSquashApp()\n    screen = ApprovalScreen(test_mappings)\n\n    # Simulate user interactions\n    await screen.press(\"j\", \"j\", \"space\", \"enter\")\n\n    # Verify state changes\n    assert len(screen.approved_mappings) == 1\n</code></pre>"},{"location":"technical/development/#test-fixtures","title":"Test Fixtures","text":"<p>Common fixtures in <code>conftest.py</code>:</p> <pre><code>@pytest.fixture\ndef tmp_git_repo(tmp_path):\n    \"\"\"Create temporary git repository for testing.\"\"\"\n    repo_path = tmp_path / \"test_repo\"\n    repo_path.mkdir()\n\n    # Initialize git repository\n    subprocess.run([\"git\", \"init\"], cwd=repo_path, check=True)\n    subprocess.run([\"git\", \"config\", \"user.email\", \"test@example.com\"], \n                   cwd=repo_path, check=True)\n    subprocess.run([\"git\", \"config\", \"user.name\", \"Test User\"], \n                   cwd=repo_path, check=True)\n\n    return repo_path\n\n@pytest.fixture  \ndef mock_git_ops():\n    \"\"\"Mock git operations for isolated testing.\"\"\"\n    with patch('git_autosquash.git_ops.GitOps') as mock:\n        # Configure mock behavior\n        mock.return_value.get_current_branch.return_value = \"feature/test\"\n        mock.return_value.is_clean_working_tree.return_value = False\n        yield mock\n</code></pre>"},{"location":"technical/development/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=src/git_autosquash --cov-report=html\n\n# Run specific test categories\nuv run pytest tests/unit/\nuv run pytest tests/integration/\nuv run pytest tests/tui/\n\n# Run tests with verbose output\nuv run pytest -v\n\n# Run specific test file\nuv run pytest tests/test_hunk_parser.py\n\n# Run tests matching pattern\nuv run pytest -k \"test_blame_analysis\"\n</code></pre>"},{"location":"technical/development/#contributing-guidelines","title":"Contributing Guidelines","text":""},{"location":"technical/development/#workflow","title":"Workflow","text":"<ol> <li>Fork and Clone: Fork the repository and clone your fork</li> <li>Branch: Create feature branch from <code>main</code></li> <li>Develop: Implement changes with tests</li> <li>Quality: Ensure pre-commit hooks pass</li> <li>Test: Run full test suite</li> <li>Document: Update documentation if needed</li> <li>PR: Submit pull request with clear description</li> </ol>"},{"location":"technical/development/#commit-standards","title":"Commit Standards","text":"<p>Follow conventional commit format:</p> <pre><code>type(scope): description\n\nbody (optional)\n\nfooter (optional)\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>test</code>: Test additions or modifications - <code>refactor</code>: Code refactoring - <code>perf</code>: Performance improvements - <code>ci</code>: CI/CD changes</p> <p>Examples: <pre><code>feat(hunk-parser): add line-by-line splitting mode\n\nImplement optional line-by-line hunk splitting for more granular \nblame analysis. Useful for complex refactoring scenarios.\n\nCloses #123\n</code></pre></p> <pre><code>fix(blame-analyzer): correct confidence scoring algorithm\n\nChanged from recency-first to frequency-first selection with \nrecency as tiebreaker. Fixes issue where newest commits were \nalways preferred over more logical targets.\n\nFixes #456\n</code></pre>"},{"location":"technical/development/#pull-request-template","title":"Pull Request Template","text":"<pre><code>## Description\nBrief description of changes and motivation.\n\n## Type of Change\n- [ ] Bug fix (non-breaking change which fixes an issue)\n- [ ] New feature (non-breaking change which adds functionality)  \n- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)\n- [ ] Documentation update\n\n## Testing\n- [ ] Added tests for new functionality\n- [ ] All tests pass locally\n- [ ] Pre-commit hooks pass\n\n## Checklist  \n- [ ] Code follows project style guidelines\n- [ ] Self-review of code completed\n- [ ] Documentation updated if needed\n- [ ] No breaking changes without version bump\n</code></pre>"},{"location":"technical/development/#performance-considerations","title":"Performance Considerations","text":""},{"location":"technical/development/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"technical/development/#git-command-efficiency","title":"Git Command Efficiency","text":"<ul> <li>Minimize git subprocess calls</li> <li>Use appropriate git options (<code>--no-pager</code>, <code>--porcelain</code>)</li> <li>Cache results within single operation</li> <li>Batch similar operations when possible</li> </ul>"},{"location":"technical/development/#memory-management","title":"Memory Management","text":"<ul> <li>Use generators for large diff processing</li> <li>Stream blame results rather than loading all at once</li> <li>Release objects promptly in TUI updates</li> <li>Monitor memory usage in tests</li> </ul>"},{"location":"technical/development/#tui-responsiveness","title":"TUI Responsiveness","text":"<ul> <li>Use async operations for git commands</li> <li>Update UI progressively during analysis</li> <li>Implement cancellation for long operations</li> <li>Cache rendered content where appropriate</li> </ul>"},{"location":"technical/development/#performance-testing","title":"Performance Testing","text":"<pre><code>def test_performance_large_repository(large_repo_fixture):\n    \"\"\"Test performance with large repository.\"\"\"\n    import time\n\n    start_time = time.time()\n    result = run_autosquash_analysis(large_repo_fixture)\n    duration = time.time() - start_time\n\n    # Performance assertions\n    assert duration &lt; 30.0  # Should complete within 30 seconds\n    assert len(result.hunks) &gt; 100  # Verify substantial work done\n    assert result.memory_peak &lt; 100 * 1024 * 1024  # Under 100MB\n</code></pre>"},{"location":"technical/development/#debugging-and-troubleshooting","title":"Debugging and Troubleshooting","text":""},{"location":"technical/development/#debug-mode","title":"Debug Mode","text":"<p>Enable detailed logging:</p> <pre><code># Enable git tracing\nGIT_TRACE=1 git-autosquash\n\n# Python debugging\npython -X dev -c \"import git_autosquash.main; git_autosquash.main.main()\"\n\n# Textual debugging\ntextual console\n# In another terminal:\ngit-autosquash\n</code></pre>"},{"location":"technical/development/#common-development-issues","title":"Common Development Issues","text":""},{"location":"technical/development/#pre-commit-hook-failures","title":"Pre-commit Hook Failures","text":"<pre><code># Fix formatting issues\nuv run ruff format .\n\n# Fix linting issues  \nuv run ruff check . --fix\n\n# Check types\nuv run mypy src/\n</code></pre>"},{"location":"technical/development/#test-failures","title":"Test Failures","text":"<pre><code># Run specific failing test with verbose output\nuv run pytest tests/test_specific.py::test_function -v -s\n\n# Debug test with pdb\nuv run pytest tests/test_specific.py::test_function --pdb\n</code></pre>"},{"location":"technical/development/#tui-development","title":"TUI Development","text":"<pre><code># Use textual development tools\nuv run textual run --dev src/git_autosquash/tui/app.py\n\n# Console debugging\nuv run textual console\n</code></pre>"},{"location":"technical/development/#logging-configuration","title":"Logging Configuration","text":"<pre><code>import logging\n\n# Enable debug logging during development\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nlogger = logging.getLogger(__name__)\nlogger.debug(\"Debug information here\")\n</code></pre>"},{"location":"technical/development/#release-process","title":"Release Process","text":""},{"location":"technical/development/#version-management","title":"Version Management","text":"<p>Uses <code>setuptools-scm</code> for automatic versioning from git tags:</p> <pre><code># Check current version\ngit-autosquash --version\n\n# Create release\ngit tag v1.2.3\ngit push origin v1.2.3\n\n# Version automatically derived from tag\n</code></pre>"},{"location":"technical/development/#release-workflow","title":"Release Workflow","text":"<ol> <li>Prepare Release:</li> <li>Update CHANGELOG.md</li> <li>Ensure all tests pass</li> <li> <p>Update documentation if needed</p> </li> <li> <p>Create Release:    <pre><code>git tag -a v1.2.3 -m \"Release version 1.2.3\"\ngit push origin v1.2.3\n</code></pre></p> </li> <li> <p>CI/CD Pipeline:</p> </li> <li>GitHub Actions automatically builds and deploys to PyPI</li> <li>Documentation updated on GitHub Pages</li> <li> <p>Release notes generated from tag</p> </li> <li> <p>Verify Release:    <pre><code># Test installation from PyPI\npipx install git-autosquash==1.2.3\ngit-autosquash --version\n</code></pre></p> </li> </ol> <p>For detailed contribution instructions, see the project's CONTRIBUTING.md file.</p>"},{"location":"technical/testing/","title":"Testing Guide","text":"<p>This guide covers the comprehensive testing strategy for git-autosquash, including test categories, fixtures, and best practices.</p>"},{"location":"technical/testing/#test-architecture","title":"Test Architecture","text":""},{"location":"technical/testing/#test-categories","title":"Test Categories","text":"<pre><code>tests/\n\u251c\u2500\u2500 unit/                    # Fast, isolated component tests\n\u251c\u2500\u2500 integration/             # Cross-component interaction tests  \n\u251c\u2500\u2500 tui/                     # Terminal UI behavior tests\n\u251c\u2500\u2500 performance/             # Performance and scalability tests\n\u251c\u2500\u2500 regression/              # Tests for previously fixed bugs\n\u2514\u2500\u2500 fixtures/                # Shared test data and utilities\n</code></pre>"},{"location":"technical/testing/#testing-philosophy","title":"Testing Philosophy","text":"<ol> <li>Fast Feedback: Unit tests run in milliseconds</li> <li>Realistic Scenarios: Integration tests use real git repositories</li> <li>Edge Case Coverage: Handle unusual git states and user inputs</li> <li>Performance Validation: Ensure scalability with large repositories</li> <li>Regression Prevention: Lock in fixes for reported bugs</li> </ol>"},{"location":"technical/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"technical/testing/#core-component-tests","title":"Core Component Tests","text":""},{"location":"technical/testing/#git-operations-test_git_opspy","title":"Git Operations (<code>test_git_ops.py</code>)","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, patch, MagicMock\nimport subprocess\nfrom pathlib import Path\n\nfrom git_autosquash.git_ops import GitOps, GitError\n\nclass TestGitOps:\n    \"\"\"Test GitOps facade functionality.\"\"\"\n\n    def test_init_valid_repository(self, tmp_git_repo):\n        \"\"\"Test initialization with valid git repository.\"\"\"\n        git_ops = GitOps(tmp_git_repo)\n        assert git_ops.repo_path == tmp_git_repo\n\n    def test_init_invalid_repository(self, tmp_path):\n        \"\"\"Test initialization fails with invalid repository.\"\"\"\n        with pytest.raises(ValueError, match=\"Not a git repository\"):\n            GitOps(tmp_path)\n\n    @patch('subprocess.run')\n    def test_get_current_branch_success(self, mock_run, tmp_git_repo):\n        \"\"\"Test successful branch detection.\"\"\"\n        mock_run.return_value = Mock(\n            returncode=0,\n            stdout=\"feature/test-branch\",\n            stderr=\"\"\n        )\n\n        git_ops = GitOps(tmp_git_repo)\n        branch = git_ops.get_current_branch()\n\n        assert branch == \"feature/test-branch\"\n        mock_run.assert_called_once()\n\n    @patch('subprocess.run')\n    def test_get_current_branch_detached_head(self, mock_run, tmp_git_repo):\n        \"\"\"Test branch detection in detached HEAD state.\"\"\"\n        mock_run.return_value = Mock(\n            returncode=128,\n            stdout=\"\",\n            stderr=\"fatal: ref HEAD is not a symbolic ref\"\n        )\n\n        git_ops = GitOps(tmp_git_repo)\n        with pytest.raises(GitError, match=\"detached HEAD\"):\n            git_ops.get_current_branch()\n\n    def test_working_tree_states(self, git_repo_with_changes):\n        \"\"\"Test working tree state detection.\"\"\"\n        git_ops = GitOps(git_repo_with_changes.path)\n\n        # Clean state\n        status = git_ops.get_working_tree_status()\n        assert not status.has_changes\n\n        # Add unstaged changes\n        git_repo_with_changes.create_file(\"new.py\", \"content\")\n        status = git_ops.get_working_tree_status()\n        assert status.has_unstaged_changes\n        assert not status.has_staged_changes\n\n        # Stage changes\n        git_repo_with_changes.stage_file(\"new.py\")\n        status = git_ops.get_working_tree_status()\n        assert status.has_staged_changes\n        assert not status.has_unstaged_changes\n</code></pre>"},{"location":"technical/testing/#hunk-parser-test_hunk_parserpy","title":"Hunk Parser (<code>test_hunk_parser.py</code>)","text":"<pre><code>import pytest\nfrom git_autosquash.hunk_parser import HunkParser, DiffHunk\n\nclass TestHunkParser:\n    \"\"\"Test diff parsing and hunk extraction.\"\"\"\n\n    def test_parse_basic_diff(self):\n        \"\"\"Test parsing basic git diff output.\"\"\"\n        diff_output = \"\"\"\ndiff --git a/src/example.py b/src/example.py\nindex 1234567..abcdefg 100644\n--- a/src/example.py\n+++ b/src/example.py\n@@ -10,6 +10,8 @@ def example_function():\n     if condition:\n-        return None\n+        return {\"error\": \"Invalid input\"}\n+        \n+    # Added validation\n     return result\n\"\"\"\n\n        parser = HunkParser()\n        hunks = parser.parse_diff(diff_output)\n\n        assert len(hunks) == 1\n        hunk = hunks[0]\n        assert hunk.file_path == \"src/example.py\"\n        assert hunk.old_start == 10\n        assert hunk.old_count == 6\n        assert hunk.new_start == 10\n        assert hunk.new_count == 8\n        assert len(hunk.lines) == 6\n\n    def test_parse_line_by_line_mode(self):\n        \"\"\"Test line-by-line hunk splitting.\"\"\"\n        diff_output = \"\"\"\ndiff --git a/src/example.py b/src/example.py\n@@ -1,4 +1,4 @@\n def function():\n-    old_line1\n-    old_line2  \n+    new_line1\n+    new_line2\n\"\"\"\n\n        parser = HunkParser()\n        hunks = parser.parse_diff(diff_output, line_by_line=True)\n\n        # Should split into separate hunks per line change\n        assert len(hunks) == 2\n        assert hunks[0].lines[0].content == \"-    old_line1\"\n        assert hunks[0].lines[1].content == \"+    new_line1\"\n        assert hunks[1].lines[0].content == \"-    old_line2\"\n        assert hunks[1].lines[1].content == \"+    new_line2\"\n\n    def test_parse_binary_file(self):\n        \"\"\"Test handling binary file changes.\"\"\"\n        diff_output = \"\"\"\ndiff --git a/image.png b/image.png\nindex 1234567..abcdefg 100644\nBinary files a/image.png and b/image.png differ\n\"\"\"\n\n        parser = HunkParser()\n        hunks = parser.parse_diff(diff_output)\n\n        # Binary files should be ignored\n        assert len(hunks) == 0\n\n    def test_parse_new_file(self):\n        \"\"\"Test handling new file creation.\"\"\"\n        diff_output = \"\"\"\ndiff --git a/new_file.py b/new_file.py\nnew file mode 100644\nindex 0000000..1234567\n--- /dev/null\n+++ b/new_file.py\n@@ -0,0 +1,3 @@\n+def new_function():\n+    \"\"\"New functionality.\"\"\"\n+    pass\n\"\"\"\n\n        parser = HunkParser()\n        hunks = parser.parse_diff(diff_output)\n\n        assert len(hunks) == 1\n        hunk = hunks[0]\n        assert hunk.file_path == \"new_file.py\"\n        assert hunk.is_new_file\n        assert all(line.content.startswith('+') for line in hunk.lines)\n</code></pre>"},{"location":"technical/testing/#blame-analyzer-test_blame_analyzerpy","title":"Blame Analyzer (<code>test_blame_analyzer.py</code>)","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, patch\nfrom git_autosquash.blame_analyzer import BlameAnalyzer, BlameResult\n\nclass TestBlameAnalyzer:\n    \"\"\"Test git blame analysis and target resolution.\"\"\"\n\n    @patch('subprocess.run')\n    def test_analyze_hunk_basic(self, mock_run, tmp_git_repo):\n        \"\"\"Test basic blame analysis for a hunk.\"\"\"\n        # Mock git blame output\n        blame_output = \"\"\"\nabc123 src/example.py 1 1 Alice 2023-01-15 Fix validation logic\nabc123 src/example.py 2 2 Alice 2023-01-15 Fix validation logic\ndef456 src/example.py 3 3 Bob   2023-02-20 Add error handling\n\"\"\"\n        mock_run.return_value = Mock(\n            returncode=0,\n            stdout=blame_output,\n            stderr=\"\"\n        )\n\n        analyzer = BlameAnalyzer(GitOps(tmp_git_repo))\n        hunk = Mock()\n        hunk.file_path = \"src/example.py\"\n        hunk.blame_range = (1, 3)\n\n        result = analyzer.analyze_hunk(hunk, branch_commits=['abc123', 'def456'])\n\n        assert result.target_commit == 'abc123'  # Most frequent\n        assert result.confidence &gt; 0.7  # High confidence\n        assert len(result.commit_frequency) == 2\n\n    def test_confidence_calculation(self):\n        \"\"\"Test confidence score calculation.\"\"\"\n        analyzer = BlameAnalyzer(Mock())\n\n        # High confidence: all lines from same commit\n        result = analyzer._calculate_confidence(\n            commit_counts={'abc123': 5},\n            total_lines=5\n        )\n        assert result &gt; 0.9\n\n        # Medium confidence: majority from one commit\n        result = analyzer._calculate_confidence(\n            commit_counts={'abc123': 3, 'def456': 2},\n            total_lines=5\n        )\n        assert 0.5 &lt; result &lt; 0.8\n\n        # Low confidence: even split\n        result = analyzer._calculate_confidence(\n            commit_counts={'abc123': 2, 'def456': 2, 'ghi789': 1},\n            total_lines=5\n        )\n        assert result &lt; 0.5\n\n    def test_frequency_over_recency_selection(self):\n        \"\"\"Test that frequency takes precedence over recency.\"\"\"\n        analyzer = BlameAnalyzer(Mock())\n\n        # Commit abc123: older but more frequent\n        # Commit def456: newer but less frequent  \n        commit_counts = {'abc123': 4, 'def456': 1}\n        commit_dates = {'abc123': '2023-01-01', 'def456': '2023-12-01'}\n\n        target = analyzer._select_target_commit(commit_counts, commit_dates)\n\n        # Should select most frequent, not most recent\n        assert target == 'abc123'\n</code></pre>"},{"location":"technical/testing/#test-fixtures","title":"Test Fixtures","text":""},{"location":"technical/testing/#repository-fixtures-conftestpy","title":"Repository Fixtures (<code>conftest.py</code>)","text":"<pre><code>import pytest\nimport subprocess\nimport tempfile\nfrom pathlib import Path\nfrom typing import List, Optional\n\nclass GitRepoFixture:\n    \"\"\"Helper class for managing test git repositories.\"\"\"\n\n    def __init__(self, path: Path):\n        self.path = path\n        self._setup_git_config()\n\n    def _setup_git_config(self):\n        \"\"\"Configure git for testing.\"\"\"\n        subprocess.run([\n            \"git\", \"config\", \"user.email\", \"test@example.com\"\n        ], cwd=self.path, check=True)\n        subprocess.run([\n            \"git\", \"config\", \"user.name\", \"Test User\" \n        ], cwd=self.path, check=True)\n\n    def create_file(self, filename: str, content: str) -&gt; Path:\n        \"\"\"Create file with content.\"\"\"\n        file_path = self.path / filename\n        file_path.parent.mkdir(parents=True, exist_ok=True)\n        file_path.write_text(content)\n        return file_path\n\n    def commit_file(self, filename: str, content: str, message: str) -&gt; str:\n        \"\"\"Create file and commit it.\"\"\"\n        self.create_file(filename, content)\n        subprocess.run([\"git\", \"add\", filename], cwd=self.path, check=True)\n        subprocess.run([\n            \"git\", \"commit\", \"-m\", message\n        ], cwd=self.path, check=True)\n\n        # Return commit hash\n        result = subprocess.run([\n            \"git\", \"rev-parse\", \"HEAD\"\n        ], cwd=self.path, capture_output=True, text=True, check=True)\n        return result.stdout.strip()\n\n    def stage_file(self, filename: str):\n        \"\"\"Stage file for commit.\"\"\"\n        subprocess.run([\"git\", \"add\", filename], cwd=self.path, check=True)\n\n@pytest.fixture\ndef tmp_git_repo(tmp_path):\n    \"\"\"Create temporary git repository.\"\"\"\n    repo_path = tmp_path / \"test_repo\"\n    repo_path.mkdir()\n\n    subprocess.run([\"git\", \"init\"], cwd=repo_path, check=True)\n\n    return GitRepoFixture(repo_path)\n\n@pytest.fixture\ndef git_repo_with_history(tmp_git_repo):\n    \"\"\"Create git repository with commit history.\"\"\"\n    # Create initial commit\n    tmp_git_repo.commit_file(\"README.md\", \"# Test Project\", \"Initial commit\")\n\n    # Create feature commits\n    commits = []\n    commits.append(tmp_git_repo.commit_file(\n        \"src/auth.py\", \n        \"def authenticate(user): pass\",\n        \"Add authentication module\"\n    ))\n    commits.append(tmp_git_repo.commit_file(\n        \"src/ui.py\",\n        \"def render_login(): pass\", \n        \"Add login UI\"\n    ))\n    commits.append(tmp_git_repo.commit_file(\n        \"src/auth.py\",\n        \"def authenticate(user): return validate(user)\",\n        \"Fix authentication logic\"\n    ))\n\n    tmp_git_repo.commits = commits\n    return tmp_git_repo\n\n@pytest.fixture\ndef git_repo_with_changes(git_repo_with_history):\n    \"\"\"Repository with uncommitted changes.\"\"\"\n    # Modify existing files\n    git_repo_with_history.create_file(\n        \"src/auth.py\",\n        \"def authenticate(user): return validate_secure(user)\"\n    )\n    git_repo_with_history.create_file(\n        \"src/new_module.py\",\n        \"def new_feature(): pass\"\n    )\n\n    return git_repo_with_history\n</code></pre>"},{"location":"technical/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"technical/testing/#full-workflow-tests","title":"Full Workflow Tests","text":"<pre><code>class TestFullWorkflow:\n    \"\"\"Test complete git-autosquash workflows.\"\"\"\n\n    def test_basic_bug_fix_workflow(self, git_repo_with_changes):\n        \"\"\"Test bug fix gets squashed into original commit.\"\"\"\n        from git_autosquash.main import run_autosquash\n\n        # Setup: Repository has bug fix in working directory\n        # that should go back to original auth commit\n\n        result = run_autosquash(\n            git_repo_with_changes.path,\n            line_by_line=False,\n            approve_all=True  # Auto-approve for testing\n        )\n\n        assert result.success\n        assert len(result.applied_mappings) &gt; 0\n\n        # Verify the fix was applied to the correct commit\n        git_log = subprocess.run([\n            \"git\", \"log\", \"--oneline\", \"--grep=authentication\"\n        ], cwd=git_repo_with_changes.path, capture_output=True, text=True)\n\n        # Auth commit should now contain the fix\n        assert \"validate_secure\" in get_commit_content(\n            git_repo_with_changes.path, \n            git_repo_with_changes.commits[0]\n        )\n\n    def test_mixed_changes_workflow(self, git_repo_with_changes):\n        \"\"\"Test mixed new features and bug fixes.\"\"\"\n        # Add both new feature and bug fix\n        git_repo_with_changes.create_file(\"src/new_feature.py\", \"# New feature\")\n\n        result = run_autosquash(\n            git_repo_with_changes.path,\n            approve_all=True\n        )\n\n        # Bug fix should be squashed, new feature should remain\n        assert result.success\n        assert any(m.is_squashed for m in result.applied_mappings)\n        assert any(not m.is_squashed for m in result.applied_mappings)\n\n    def test_conflict_resolution_workflow(self, git_repo_with_conflicts):\n        \"\"\"Test handling of rebase conflicts.\"\"\"\n        result = run_autosquash(\n            git_repo_with_conflicts.path,\n            handle_conflicts=True  # Test automatic conflict resolution\n        )\n\n        # Should detect conflicts and provide resolution guidance\n        assert not result.success  # Conflicts prevent completion\n        assert len(result.conflicts) &gt; 0\n        assert result.conflict_resolution_steps  # Guidance provided\n\n    def test_performance_large_repository(self, large_git_repo):\n        \"\"\"Test performance with large repository.\"\"\"\n        import time\n\n        start_time = time.time()\n        result = run_autosquash(large_git_repo.path)\n        duration = time.time() - start_time\n\n        # Performance requirements\n        assert duration &lt; 60.0  # Complete within 1 minute\n        assert result.success\n        assert len(result.processed_hunks) &gt; 100  # Substantial work\n</code></pre>"},{"location":"technical/testing/#complex-scenario-tests","title":"Complex Scenario Tests","text":"<pre><code>class TestComplexScenarios:\n    \"\"\"Test challenging real-world scenarios.\"\"\"\n\n    def test_security_fix_distribution(self, repo_with_security_issues):\n        \"\"\"Test security fixes distributed to multiple commits.\"\"\"\n        # Setup: Security fixes affect multiple historical commits\n        security_fixes = [\n            (\"src/auth.py\", \"Fix SQL injection vulnerability\"),\n            (\"src/ui.py\", \"Fix XSS vulnerability\"),\n            (\"src/api.py\", \"Fix authentication bypass\")\n        ]\n\n        for filename, _ in security_fixes:\n            add_security_fix(repo_with_security_issues, filename)\n\n        result = run_autosquash(\n            repo_with_security_issues.path,\n            line_by_line=True  # Precision for security\n        )\n\n        # Each fix should go to appropriate historical commit\n        assert len(result.applied_mappings) == 3\n        for mapping in result.applied_mappings:\n            assert mapping.confidence &gt; 0.7  # High confidence required\n            assert mapping.target_commit in repo_with_security_issues.security_commits\n\n    def test_refactoring_distribution(self, repo_with_refactoring):\n        \"\"\"Test refactoring improvements distributed correctly.\"\"\"\n        # Apply performance improvements across multiple files\n        improvements = apply_performance_improvements(repo_with_refactoring)\n\n        result = run_autosquash(\n            repo_with_refactoring.path,\n            line_by_line=True\n        )\n\n        # Improvements should go back to original implementations\n        for improvement in improvements:\n            mapping = find_mapping_for_file(result, improvement.filename)\n            assert mapping.target_commit == improvement.original_commit\n\n    def test_cross_cutting_concerns(self, repo_with_cross_cutting):\n        \"\"\"Test changes affecting multiple modules.\"\"\"\n        # Add logging improvements across all modules\n        add_logging_improvements(repo_with_cross_cutting)\n\n        result = run_autosquash(repo_with_cross_cutting.path)\n\n        # Logging should be distributed to each module's original commit\n        logging_mappings = [m for m in result.applied_mappings \n                          if \"logging\" in m.description.lower()]\n\n        assert len(logging_mappings) &gt; 3  # Multiple modules affected\n        # Each should target different commits\n        target_commits = {m.target_commit for m in logging_mappings}\n        assert len(target_commits) &gt; 1\n</code></pre>"},{"location":"technical/testing/#tui-testing","title":"TUI Testing","text":""},{"location":"technical/testing/#widget-testing","title":"Widget Testing","text":"<pre><code>import pytest\nfrom textual.app import App\nfrom textual.widgets import Button\n\nfrom git_autosquash.tui.widgets import HunkMappingWidget, DiffViewer\n\nclass TestHunkMappingWidget:\n    \"\"\"Test hunk mapping widget behavior.\"\"\"\n\n    async def test_approval_toggle(self):\n        \"\"\"Test approval state toggling.\"\"\"\n        widget = HunkMappingWidget(test_mapping)\n\n        # Initially not approved\n        assert not widget.approved\n\n        # Toggle approval\n        await widget.action_toggle_approval()\n        assert widget.approved\n\n        # Toggle back\n        await widget.action_toggle_approval()\n        assert not widget.approved\n\n    async def test_confidence_display(self):\n        \"\"\"Test confidence level display.\"\"\"\n        high_confidence = create_test_mapping(confidence=0.9)\n        medium_confidence = create_test_mapping(confidence=0.6)\n        low_confidence = create_test_mapping(confidence=0.3)\n\n        high_widget = HunkMappingWidget(high_confidence)\n        medium_widget = HunkMappingWidget(medium_confidence)\n        low_widget = HunkMappingWidget(low_confidence)\n\n        # Check confidence styling\n        assert \"high\" in str(high_widget.confidence_style)\n        assert \"medium\" in str(medium_widget.confidence_style)\n        assert \"low\" in str(low_widget.confidence_style)\n\nclass TestDiffViewer:\n    \"\"\"Test diff viewer component.\"\"\"\n\n    async def test_syntax_highlighting(self):\n        \"\"\"Test syntax highlighting for different file types.\"\"\"\n        python_diff = create_python_diff()\n        javascript_diff = create_javascript_diff()\n\n        python_viewer = DiffViewer(python_diff)\n        js_viewer = DiffViewer(javascript_diff)\n\n        # Check syntax highlighting applied\n        assert python_viewer.lexer_name == \"python\"\n        assert js_viewer.lexer_name == \"javascript\"\n\n    async def test_line_navigation(self):\n        \"\"\"Test navigation within diff content.\"\"\"\n        viewer = DiffViewer(large_diff_content)\n\n        # Navigate to specific line\n        await viewer.action_goto_line(50)\n        assert viewer.current_line == 50\n\n        # Navigate with keyboard\n        await viewer.key_j()  # Down\n        assert viewer.current_line == 51\n\n        await viewer.key_k()  # Up  \n        assert viewer.current_line == 50\n</code></pre>"},{"location":"technical/testing/#screen-testing","title":"Screen Testing","text":"<pre><code>from git_autosquash.tui.screens import ApprovalScreen\nfrom git_autosquash.tui.app import AutoSquashApp\n\nclass TestApprovalScreen:\n    \"\"\"Test approval screen interactions.\"\"\"\n\n    async def test_keyboard_navigation(self):\n        \"\"\"Test keyboard navigation between mappings.\"\"\"\n        mappings = create_test_mappings(5)\n        screen = ApprovalScreen(mappings)\n\n        # Navigate down\n        await screen.key_j()\n        await screen.key_j()\n        assert screen.selected_index == 2\n\n        # Navigate up\n        await screen.key_k()\n        assert screen.selected_index == 1\n\n    async def test_bulk_approval(self):\n        \"\"\"Test bulk approval/rejection.\"\"\"\n        mappings = create_test_mappings(3)\n        screen = ApprovalScreen(mappings)\n\n        # Approve all\n        await screen.key_a()\n\n        approved = screen.get_approved_mappings()\n        assert len(approved) == 3\n\n        # Toggle all (should reject all)\n        await screen.key_a()\n\n        approved = screen.get_approved_mappings()\n        assert len(approved) == 0\n\n    async def test_execution_flow(self):\n        \"\"\"Test execution after approval.\"\"\"\n        mappings = create_test_mappings(2, auto_approve=True)\n        screen = ApprovalScreen(mappings)\n\n        # Execute\n        result = await screen.action_execute()\n\n        assert result is not None\n        assert len(result) == 2  # Both mappings approved\n        assert all(m.approved for m in result)\n\nclass TestAutoSquashApp:\n    \"\"\"Test main application flow.\"\"\"\n\n    async def test_app_initialization(self):\n        \"\"\"Test application starts correctly.\"\"\"\n        app = AutoSquashApp()\n\n        # Should initialize with approval screen\n        await app.startup()\n        assert isinstance(app.current_screen, ApprovalScreen)\n\n    async def test_error_handling(self):\n        \"\"\"Test error handling in TUI.\"\"\"\n        app = AutoSquashApp()\n\n        # Simulate git error\n        with patch('git_autosquash.git_ops.GitOps') as mock_git:\n            mock_git.side_effect = GitError(\"Test error\")\n\n            await app.startup()\n\n            # Should show error screen\n            assert \"error\" in str(app.current_screen).lower()\n</code></pre>"},{"location":"technical/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"technical/testing/#scalability-tests","title":"Scalability Tests","text":"<pre><code>class TestPerformance:\n    \"\"\"Test performance with various repository sizes.\"\"\"\n\n    def test_small_repository_performance(self, small_repo):\n        \"\"\"Test performance with small repository (&lt; 100 commits).\"\"\"\n        start_time = time.time()\n        result = run_autosquash(small_repo.path)\n        duration = time.time() - start_time\n\n        assert duration &lt; 5.0  # Should complete in under 5 seconds\n        assert result.success\n\n    def test_medium_repository_performance(self, medium_repo):\n        \"\"\"Test performance with medium repository (100-1000 commits).\"\"\" \n        start_time = time.time()\n        result = run_autosquash(medium_repo.path)\n        duration = time.time() - start_time\n\n        assert duration &lt; 30.0  # Should complete in under 30 seconds\n        assert result.success\n\n    def test_large_repository_performance(self, large_repo):\n        \"\"\"Test performance with large repository (1000+ commits).\"\"\"\n        start_time = time.time()\n        result = run_autosquash(large_repo.path)\n        duration = time.time() - start_time\n\n        assert duration &lt; 120.0  # Should complete in under 2 minutes\n        assert result.success\n\n    def test_memory_usage(self, large_repo):\n        \"\"\"Test memory usage remains reasonable.\"\"\"\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss\n\n        result = run_autosquash(large_repo.path)\n\n        final_memory = process.memory_info().rss\n        memory_increase = final_memory - initial_memory\n\n        # Memory increase should be reasonable (&lt; 500MB)\n        assert memory_increase &lt; 500 * 1024 * 1024\n        assert result.success\n</code></pre>"},{"location":"technical/testing/#running-tests","title":"Running Tests","text":""},{"location":"technical/testing/#local-testing","title":"Local Testing","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run specific test categories  \nuv run pytest tests/unit/\nuv run pytest tests/integration/\nuv run pytest tests/tui/\nuv run pytest tests/performance/\n\n# Run with coverage\nuv run pytest --cov=src/git_autosquash --cov-report=html\n\n# Run tests in parallel\nuv run pytest -n auto\n\n# Run tests with verbose output\nuv run pytest -v\n\n# Run specific test\nuv run pytest tests/unit/test_blame_analyzer.py::TestBlameAnalyzer::test_confidence_calculation\n</code></pre>"},{"location":"technical/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests are automatically run on: - All pull requests - Pushes to main branch - Multiple Python versions (3.9, 3.10, 3.11, 3.12) - Multiple operating systems (Ubuntu, macOS, Windows)</p>"},{"location":"technical/testing/#test-coverage-goals","title":"Test Coverage Goals","text":"<ul> <li>Unit tests: 95% code coverage</li> <li>Integration tests: Cover all major workflows</li> <li>TUI tests: Cover all user interactions</li> <li>Performance tests: Validate scalability requirements</li> <li>Regression tests: Lock in all bug fixes</li> </ul> <p>The comprehensive test suite ensures git-autosquash remains reliable and performant across diverse git repository scenarios and user workflows.</p>"},{"location":"user-guide/advanced-usage/","title":"Advanced Usage","text":"<p>This guide covers advanced git-autosquash features and workflows for power users and complex scenarios.</p>"},{"location":"user-guide/advanced-usage/#advanced-command-line-options","title":"Advanced Command-Line Options","text":""},{"location":"user-guide/advanced-usage/#line-by-line-mode","title":"Line-by-Line Mode","text":"<p>The <code>--line-by-line</code> option provides maximum precision when analyzing changes:</p> <pre><code>git-autosquash --line-by-line\n</code></pre> <p>When to use: - Mixed commits affecting same code section - Review feedback requiring precise targeting - Unrelated changes bundled together by git's default hunking</p> <p>Performance trade-offs: - Slower analysis (each line evaluated separately) - More granular control - Better separation of unrelated changes</p>"},{"location":"user-guide/advanced-usage/#environment-variable-control","title":"Environment Variable Control","text":"<p>Control git-autosquash behavior through environment variables:</p> <pre><code># Disable colors for scripting\nNO_COLOR=1 git-autosquash\n\n# Force specific terminal capabilities\nTERM=xterm-256color git-autosquash\n\n# Debug git operations\nGIT_TRACE=1 git-autosquash\n</code></pre>"},{"location":"user-guide/advanced-usage/#advanced-workflows","title":"Advanced Workflows","text":""},{"location":"user-guide/advanced-usage/#multi-stage-development","title":"Multi-Stage Development","text":"<p>For complex features spanning multiple commits:</p> <pre><code># Stage 1: Initial implementation\ngit commit -m \"Add user authentication framework\"\n\n# Stage 2: Add OAuth support + fix bugs in Stage 1\n# (working directory has mixed changes)\ngit-autosquash\n# OAuth changes stay as new commit\n# Bug fixes go back to Stage 1 commit\n\n# Stage 3: Continue with more features\ngit commit -m \"Add OAuth provider configuration\"\n</code></pre>"},{"location":"user-guide/advanced-usage/#handling-large-refactoring","title":"Handling Large Refactoring","text":"<p>When refactoring affects many files and historical commits:</p> <pre><code># After large refactoring session\ngit status --porcelain | wc -l\n# 50+ modified files\n\n# Use line-by-line for precision\ngit-autosquash --line-by-line\n\n# Review carefully - large refactorings often have mixed intentions\n</code></pre>"},{"location":"user-guide/advanced-usage/#branch-cleanup-workflows","title":"Branch Cleanup Workflows","text":""},{"location":"user-guide/advanced-usage/#pre-merge-cleanup","title":"Pre-merge Cleanup","text":"<pre><code># Before creating pull request\ngit checkout feature/user-dashboard\ngit-autosquash  # Clean up the branch history\n\n# Verify results\ngit log --oneline origin/main..HEAD\n\n# Push cleaned branch\ngit push --force-with-lease origin feature/user-dashboard\n</code></pre>"},{"location":"user-guide/advanced-usage/#post-review-cleanup","title":"Post-review Cleanup","text":"<pre><code># After addressing code review feedback\ngit-autosquash  # Distribute fixes back to original commits\n\n# Amend latest commit if needed\ngit commit --amend -m \"Add user dashboard with analytics\"\n\n# Force push cleaned history\ngit push --force-with-lease\n</code></pre>"},{"location":"user-guide/advanced-usage/#complex-scenarios","title":"Complex Scenarios","text":""},{"location":"user-guide/advanced-usage/#handling-merge-conflicts","title":"Handling Merge Conflicts","text":"<p>When rebase conflicts occur during git-autosquash execution:</p> <pre><code>git-autosquash\n# ... conflicts detected ...\n\n# Resolve conflicts manually\ngit status  # Shows conflicted files\nvim src/auth/login.py  # Edit and resolve\n\n# Stage resolved files\ngit add src/auth/login.py\n\n# Continue rebase\ngit rebase --continue\n\n# git-autosquash will continue with remaining commits\n</code></pre> <p>Recovery options: <pre><code># If conflicts are too complex, abort and try different approach\ngit rebase --abort\n\n# Try with different hunk splitting\ngit-autosquash --line-by-line\n\n# Or process fewer changes at once\ngit stash push -m \"Save some changes\"\ngit-autosquash\ngit stash pop\n</code></pre></p>"},{"location":"user-guide/advanced-usage/#working-with-shared-branches","title":"Working with Shared Branches","text":"<p>Team coordination: <pre><code># Before running git-autosquash on shared branch\ngit fetch origin\ngit status  # Ensure you're up to date\n\n# Coordinate with team\necho \"Running git-autosquash on shared branch, will force-push after\"\n\ngit-autosquash\ngit push --force-with-lease origin feature/shared-work\n\n# Notify team to rebase their local copies\necho \"Branch rebased, run: git pull --rebase\"\n</code></pre></p>"},{"location":"user-guide/advanced-usage/#partial-staging-workflows","title":"Partial Staging Workflows","text":"<p>Control exactly which changes get processed:</p> <pre><code># Stage only specific changes\ngit add -p src/auth/login.py  # Interactively stage hunks\n\n# Process only staged changes\ngit-autosquash\n# Choose option 's' to stash unstaged and process staged only\n\n# Later, unstash and process remaining changes\ngit stash pop\ngit-autosquash\n</code></pre>"},{"location":"user-guide/advanced-usage/#performance-optimization","title":"Performance Optimization","text":""},{"location":"user-guide/advanced-usage/#caching-and-performance","title":"Caching and Performance","text":"<p>git-autosquash includes several performance optimizations:</p> <p>Blame caching: - Commit metadata cached between runs - Branch scope filtering cached - File blame results cached per session</p> <p>Large repository strategies: <pre><code># For very large repos, limit scope\ngit-autosquash  # Only processes changes since last commit\n\n# For extensive changes, use line-by-line for precision\ngit-autosquash --line-by-line  # Slower but more accurate\n</code></pre></p>"},{"location":"user-guide/advanced-usage/#memory-and-disk-usage","title":"Memory and Disk Usage","text":"<p>Memory optimization: - Diff parsing uses generators for large files - Blame analysis processes files incrementally - TUI updates use efficient reactive patterns</p> <p>Disk usage considerations: - Temporary rebase files in <code>.git/rebase-merge/</code> - Stash entries if using staged-only mode - Git object database growth during rebase</p>"},{"location":"user-guide/advanced-usage/#integration-patterns","title":"Integration Patterns","text":""},{"location":"user-guide/advanced-usage/#git-hooks-integration","title":"Git Hooks Integration","text":""},{"location":"user-guide/advanced-usage/#pre-commit-hook","title":"Pre-commit Hook","text":"<pre><code>#!/bin/bash\n# .git/hooks/pre-commit\n\nif ! git diff --cached --quiet; then\n    echo \"Staged changes detected.\"\n    echo \"Consider running 'git-autosquash' to organize changes.\"\n\n    # Optional: Fail commit if working directory is dirty\n    if ! git diff --quiet; then\n        echo \"Working directory has unstaged changes.\"\n        echo \"Run 'git-autosquash' first to organize all changes.\"\n        exit 1\n    fi\nfi\n</code></pre>"},{"location":"user-guide/advanced-usage/#pre-push-hook","title":"Pre-push Hook","text":"<pre><code>#!/bin/bash\n# .git/hooks/pre-push\n\nbranch=$(git rev-parse --abbrev-ref HEAD)\nif [[ \"$branch\" != \"main\" &amp;&amp; \"$branch\" != \"master\" ]]; then\n    if ! git diff --quiet; then\n        echo \"Uncommitted changes on branch $branch\"\n        read -p \"Consider running git-autosquash first. Continue? (y/n): \" -n 1 -r\n        echo\n        if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n            exit 1\n        fi\n    fi\nfi\n</code></pre>"},{"location":"user-guide/advanced-usage/#ide-and-editor-integration","title":"IDE and Editor Integration","text":""},{"location":"user-guide/advanced-usage/#vs-code-tasks","title":"VS Code Tasks","text":"<pre><code>{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"git-autosquash\",\n            \"type\": \"shell\",\n            \"command\": \"git-autosquash\",\n            \"group\": \"build\",\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"always\",\n                \"focus\": true,\n                \"panel\": \"new\"\n            },\n            \"problemMatcher\": []\n        },\n        {\n            \"label\": \"git-autosquash (precise)\",\n            \"type\": \"shell\",\n            \"command\": \"git-autosquash\",\n            \"args\": [\"--line-by-line\"],\n            \"group\": \"build\",\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"always\", \n                \"focus\": true,\n                \"panel\": \"new\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"user-guide/advanced-usage/#vimneovim","title":"Vim/Neovim","text":"<pre><code>\" Add to .vimrc or init.vim\n\n\" Quick git-autosquash\nnnoremap &lt;leader&gt;ga :!git-autosquash&lt;CR&gt;\n\n\" Line-by-line mode\nnnoremap &lt;leader&gt;gA :!git-autosquash --line-by-line&lt;CR&gt;\n\n\" Function to check if autosquash would be useful\nfunction! CheckAutosquash()\n    let l:status = system('git diff --quiet')\n    if v:shell_error != 0\n        echo \"Changes detected - git-autosquash might be useful\"\n        call system('git diff --stat')\n    else\n        echo \"No changes to analyze\"\n    endif\nendfunction\n\ncommand! CheckAutosquash call CheckAutosquash()\n</code></pre>"},{"location":"user-guide/advanced-usage/#makefile-integration","title":"Makefile Integration","text":"<pre><code>.PHONY: autosquash autosquash-precise check-autosquash\n\n# Standard autosquash\nautosquash:\n    @echo \"Running git-autosquash...\"\n    @git-autosquash\n\n# Line-by-line precision mode\nautosquash-precise:\n    @echo \"Running git-autosquash with line-by-line precision...\"\n    @git-autosquash --line-by-line\n\n# Check if autosquash would be useful\ncheck-autosquash:\n    @if ! git diff --quiet; then \\\n        echo \"Changes detected:\"; \\\n        git diff --stat; \\\n        echo \"Consider running 'make autosquash'\"; \\\n    else \\\n        echo \"No changes to analyze\"; \\\n    fi\n\n# Pre-commit target\npre-commit: check-autosquash\n    @echo \"Ready for commit\"\n</code></pre>"},{"location":"user-guide/advanced-usage/#scripting-and-automation","title":"Scripting and Automation","text":""},{"location":"user-guide/advanced-usage/#batch-processing-scripts","title":"Batch Processing Scripts","text":"<pre><code>#!/bin/bash\n# bulk-autosquash.sh - Process multiple feature branches\n\nbranches=(\n    \"feature/user-auth\"\n    \"feature/dashboard-ui\" \n    \"feature/api-endpoints\"\n)\n\nfor branch in \"${branches[@]}\"; do\n    echo \"Processing branch: $branch\"\n    git checkout \"$branch\"\n\n    if ! git diff --quiet; then\n        echo \"Running git-autosquash on $branch...\"\n        git-autosquash\n\n        if [ $? -eq 0 ]; then\n            echo \"\u2713 $branch processed successfully\"\n            git push --force-with-lease origin \"$branch\"\n        else\n            echo \"\u2717 $branch failed, skipping push\"\n        fi\n    else\n        echo \"No changes in $branch, skipping\"\n    fi\n    echo \"---\"\ndone\n\ngit checkout main\n</code></pre>"},{"location":"user-guide/advanced-usage/#cicd-integration","title":"CI/CD Integration","text":"<pre><code># .github/workflows/autosquash-check.yml\nname: Check Autosquash Opportunities\non: [pull_request]\n\njobs:\n  check-organization:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - name: Install git-autosquash\n        run: pipx install git-autosquash\n\n      - name: Check for organization opportunities\n        run: |\n          if ! git diff --quiet origin/main..HEAD; then\n            echo \"::notice::Branch has changes that might benefit from git-autosquash\"\n            echo \"::notice::Consider running git-autosquash to organize commits\"\n\n            # Count potential targets (for metrics)\n            echo \"Commits in branch: $(git rev-list --count origin/main..HEAD)\"\n            echo \"Files changed: $(git diff --name-only origin/main..HEAD | wc -l)\"\n          fi\n</code></pre>"},{"location":"user-guide/advanced-usage/#troubleshooting-advanced-scenarios","title":"Troubleshooting Advanced Scenarios","text":""},{"location":"user-guide/advanced-usage/#performance-issues","title":"Performance Issues","text":"<p>Slow blame analysis: <pre><code># Check repository size\ndu -sh .git/\ngit count-objects -vH\n\n# Large repositories may benefit from:\ngit gc --aggressive  # Cleanup and optimize\ngit-autosquash --line-by-line  # More precise, potentially faster for complex changes\n</code></pre></p> <p>Memory usage: <pre><code># Monitor memory usage during operation\n/usr/bin/time -v git-autosquash\n\n# For very large changesets, process in smaller batches\ngit stash push -m \"Batch 2\" -- src/module2/\ngit-autosquash  # Process batch 1\ngit stash pop\ngit-autosquash  # Process batch 2\n</code></pre></p>"},{"location":"user-guide/advanced-usage/#complex-conflict-resolution","title":"Complex Conflict Resolution","text":"<p>Systematic conflict resolution: <pre><code>git-autosquash\n# Conflicts in multiple files...\n\n# Resolve conflicts systematically\ngit status --porcelain | grep \"^UU\" | cut -c4- | while read file; do\n    echo \"Resolving: $file\"\n    # Open each file individually\n    ${EDITOR:-vim} \"$file\"\n    git add \"$file\"\ndone\n\ngit rebase --continue\n</code></pre></p> <p>Recovery from failed rebase: <pre><code># If rebase gets too complex\ngit rebase --abort\n\n# Try different approach\ngit stash push -m \"Complex changes\"\ngit-autosquash  # Process simpler changes first\ngit stash pop\n# Manually organize complex changes\n</code></pre></p>"},{"location":"user-guide/advanced-usage/#branch-history-issues","title":"Branch History Issues","text":"<p>Fixing corrupted branch history: <pre><code># If git-autosquash results in unexpected history\ngit reflog  # Find previous state\ngit reset --hard HEAD@{N}  # Reset to previous state\n\n# Try alternative approaches\ngit-autosquash --line-by-line  # More precision\n# Or process changes manually\n</code></pre></p> <p>For more troubleshooting scenarios, see Troubleshooting Guide.</p>"},{"location":"user-guide/basic-workflow/","title":"Basic Workflow","text":"<p>This guide covers the most common git-autosquash usage patterns and workflows that you'll encounter in day-to-day development.</p>"},{"location":"user-guide/basic-workflow/#standard-development-workflow","title":"Standard Development Workflow","text":""},{"location":"user-guide/basic-workflow/#1-feature-development-with-bug-fixes","title":"1. Feature Development with Bug Fixes","text":"<p>This is the most common scenario: you're working on a feature branch and discover bugs in existing code that should be fixed in their original commits.</p> <p>Scenario: You're adding user authentication and notice a validation bug in existing login code.</p> <pre><code># You're on a feature branch\ngit checkout -b feature/oauth-integration\n\n# Make changes to multiple files\nvim src/auth/oauth.py      # New OAuth implementation\nvim src/auth/login.py      # Fix validation bug in existing code  \nvim src/ui/login_form.py   # Update form for OAuth\n\n# Check what you've changed\ngit status\n# modified:   src/auth/oauth.py\n# modified:   src/auth/login.py  \n# modified:   src/ui/login_form.py\n\n# Run git-autosquash\ngit-autosquash\n</code></pre> <p>Expected Results: - OAuth implementation changes \u2192 Stay in current working directory (no target found) - Login validation fix \u2192 Goes back to commit that introduced the login functionality - Form updates \u2192 Mixed (some to original form commit, some stay as new feature)</p>"},{"location":"user-guide/basic-workflow/#2-code-cleanup-and-refactoring","title":"2. Code Cleanup and Refactoring","text":"<p>Scenario: You've been refactoring code and want to distribute improvements back to their logical commits.</p> <pre><code># After refactoring session\ngit status\n# modified:   src/database/models.py     # Performance improvements\n# modified:   src/api/handlers.py        # Error handling improvements\n# modified:   src/utils/validation.py    # Code style cleanup\n\ngit-autosquash\n</code></pre> <p>The TUI will show you which improvements can go back to the commits that originally introduced each piece of functionality.</p>"},{"location":"user-guide/basic-workflow/#3-mixed-staged-and-unstaged-changes","title":"3. Mixed Staged and Unstaged Changes","text":"<p>git-autosquash intelligently handles different working tree states:</p> <pre><code># Some changes staged, others not\ngit add src/auth/login.py\ngit status\n# Changes to be committed:\n#   modified:   src/auth/login.py\n# Changes not staged for commit:\n#   modified:   src/ui/dashboard.py\n#   modified:   src/utils/helpers.py\n\ngit-autosquash\n# Mixed staged and unstaged changes detected.\n# Choose an option:\n#   a) Process all changes (staged + unstaged)  \n#   s) Stash unstaged changes and process only staged\n#   q) Quit\n</code></pre> <p>Recommended Approach</p> <ul> <li>Option a: Most common choice, processes all changes together</li> <li>Option s: Use when you want to be very careful about what gets rebased</li> <li>Option q: Use to manually stage exactly what you want first</li> </ul>"},{"location":"user-guide/basic-workflow/#tui-navigation-patterns","title":"TUI Navigation Patterns","text":""},{"location":"user-guide/basic-workflow/#efficient-review-workflow","title":"Efficient Review Workflow","text":"<ol> <li>Quick scan: Use \u2191/\u2193 to quickly review all mappings first</li> <li>Detailed review: For each mapping:</li> <li>Check the target commit message and date</li> <li>Review the diff in the right panel</li> <li>Consider the confidence level</li> <li>Batch approval: Use <code>a</code> to toggle all if most look good, then manually adjust</li> <li>Execute: Press Enter when satisfied</li> </ol>"},{"location":"user-guide/basic-workflow/#confidence-level-strategy","title":"Confidence Level Strategy","text":"<p>High Confidence (Green): - Usually safe to approve automatically - All lines blame to the target commit - Clear logical connection</p> <p>Medium Confidence (Yellow): - Review the diff carefully - Most lines match but some uncertainty - Consider the logical relationship</p> <p>Low Confidence (Red): - Be very cautious - Mixed blame results or newer commits involved - Often better to leave as new changes</p>"},{"location":"user-guide/basic-workflow/#keyboard-shortcuts-reference","title":"Keyboard Shortcuts Reference","text":"Action Key Description Navigate \u2191\u2193 or jk Move between hunk mappings Toggle approval Space Approve/reject current mapping Toggle all a Approve or reject all mappings Execute Enter Start rebase with approved changes Cancel Escape or q Abort operation Help ? Show help (if implemented)"},{"location":"user-guide/basic-workflow/#common-scenarios","title":"Common Scenarios","text":""},{"location":"user-guide/basic-workflow/#scenario-bug-fix-during-feature-work","title":"Scenario: Bug Fix During Feature Work","text":"<pre><code>graph LR\n    A[Working on Feature] --&gt; B[Notice Bug]\n    B --&gt; C[Fix Bug in Same Session]\n    C --&gt; D[Run git-autosquash]\n    D --&gt; E[Bug Fix \u2192 Historical Commit]\n    D --&gt; F[Feature Work \u2192 Stays Current]</code></pre> <p>Best Practice: Fix bugs as you encounter them, then use git-autosquash to organize the changes appropriately.</p>"},{"location":"user-guide/basic-workflow/#scenario-code-review-feedback","title":"Scenario: Code Review Feedback","text":"<p>You receive code review feedback asking for changes across multiple commits:</p> <pre><code># After addressing review feedback\ngit status\n# modified:   src/auth/login.py      # Requested security fix\n# modified:   src/ui/dashboard.py    # Requested UI improvement  \n# modified:   docs/api.md           # Documentation update\n\ngit-autosquash\n# Security fix \u2192 Goes to original login commit\n# UI improvement \u2192 Goes to original dashboard commit  \n# Documentation \u2192 Stays as new change (no logical target)\n</code></pre>"},{"location":"user-guide/basic-workflow/#scenario-merge-conflict-resolution","title":"Scenario: Merge Conflict Resolution","text":"<p>Sometimes you'll encounter conflicts during the rebase:</p> <pre><code>git-autosquash\n# ... TUI workflow ...\n# \u2713 Squash operation completed successfully!\n\n# Later, if conflicts occurred:\n# \u26a0\ufe0f Rebase conflicts detected:\n#   src/auth/login.py\n# \n# To resolve conflicts:\n# 1. Edit the conflicted files to resolve conflicts\n# 2. Stage the resolved files: git add &lt;files&gt;  \n# 3. Continue the rebase: git rebase --continue\n# 4. Or abort the rebase: git rebase --abort\n</code></pre> <p>Resolution Process: 1. Open conflicted files in your editor 2. Resolve conflicts (remove <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> markers) 3. Stage resolved files: <code>git add src/auth/login.py</code> 4. Continue: <code>git rebase --continue</code></p>"},{"location":"user-guide/basic-workflow/#branch-management","title":"Branch Management","text":""},{"location":"user-guide/basic-workflow/#safe-branch-practices","title":"Safe Branch Practices","text":"<p>\u2705 Good practices: - Use git-autosquash on feature branches only - Ensure your branch has a clear merge-base with main/master - Keep feature branches focused and reasonably sized</p> <p>\u274c Avoid: - Running on main/master branch directly - Using on branches without clear merge-base - Running on very large branches with complex history</p>"},{"location":"user-guide/basic-workflow/#working-with-shared-branches","title":"Working with Shared Branches","text":"<p>Shared Branch Caution</p> <p>If others are working on your branch:</p> <ol> <li>Coordinate first: Let team members know you're rebasing</li> <li>Force push required: After git-autosquash, you'll need <code>git push --force-with-lease</code></li> <li>Team updates: Others will need to <code>git pull --rebase</code> or reset their local branches</li> </ol>"},{"location":"user-guide/basic-workflow/#branch-cleanup-after-success","title":"Branch Cleanup After Success","text":"<pre><code># After successful git-autosquash\ngit log --oneline -10  # Verify the results look good\n\n# If satisfied, you might want to:\ngit push --force-with-lease origin feature/oauth-integration\n\n# Or continue with more development\ngit commit -m \"Add OAuth provider configuration\"\n</code></pre>"},{"location":"user-guide/basic-workflow/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/basic-workflow/#large-repositories","title":"Large Repositories","text":"<p>For large repositories with extensive history:</p> <ul> <li>git-autosquash caches blame and commit information</li> <li>First run may be slower as caches are built  </li> <li>Subsequent runs on the same branch are much faster</li> <li>Consider using <code>--line-by-line</code> for very precise control</li> </ul>"},{"location":"user-guide/basic-workflow/#optimizing-for-speed","title":"Optimizing for Speed","text":"<pre><code># For large changesets, line-by-line can be more precise\ngit-autosquash --line-by-line\n\n# Standard mode is faster for most cases\ngit-autosquash\n</code></pre>"},{"location":"user-guide/basic-workflow/#integration-with-git-workflows","title":"Integration with Git Workflows","text":""},{"location":"user-guide/basic-workflow/#pre-push-hook","title":"Pre-Push Hook","text":"<p>You can integrate git-autosquash into your workflow with git hooks:</p> <pre><code>#!/bin/bash\n# .git/hooks/pre-push\n\necho \"Checking if working directory needs git-autosquash...\"\nif ! git diff --quiet; then\n    echo \"Uncommitted changes found. Consider running git-autosquash first.\"\n    read -p \"Continue with push? (y/n): \" -n 1 -r\n    echo\n    if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n        exit 1\n    fi\nfi\n</code></pre>"},{"location":"user-guide/basic-workflow/#ide-integration","title":"IDE Integration","text":"<p>Many IDEs can be configured to run git-autosquash:</p> <ul> <li>VS Code: Add as a task or terminal command</li> <li>IntelliJ/PyCharm: Configure as external tool</li> <li>Vim/Neovim: Create command mapping</li> </ul>"},{"location":"user-guide/basic-workflow/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"user-guide/basic-workflow/#no-target-commits-found","title":"\"No target commits found\"","text":"<p>This happens when: - All changes are in new files - Changes are outside the branch scope (before merge-base) - Git blame doesn't find clear ownership</p> <p>Solution: Review if the changes actually belong in historical commits, or if they should stay as new changes.</p>"},{"location":"user-guide/basic-workflow/#command-not-found","title":"\"Command not found\"","text":"<p>Check installation: <pre><code>which git-autosquash\ngit-autosquash --version\n</code></pre></p> <p>Reinstall if needed: <pre><code>pipx reinstall git-autosquash\n</code></pre></p>"},{"location":"user-guide/basic-workflow/#not-in-a-git-repository","title":"\"Not in a git repository\"","text":"<p>Ensure you're in a Git repository: <pre><code>pwd\ngit status\n</code></pre></p>"},{"location":"user-guide/basic-workflow/#performance-issues","title":"Performance issues","text":"<p>For very large diffs: - Consider breaking changes into smaller chunks - Use <code>--line-by-line</code> for more granular control - Ensure you have adequate memory and disk space</p>"},{"location":"user-guide/basic-workflow/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Advanced Usage options and power features</li> <li>Explore Complex Workflows for challenging scenarios  </li> <li>Check Troubleshooting for detailed problem-solving guides</li> </ul>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>This guide will walk you through your first experience with git-autosquash, from setup to successfully distributing changes back to historical commits.</p> <p>Current Implementation Status</p> <p>git-autosquash is actively being developed. All core functionality is implemented and working: diff analysis, git blame integration, TUI interface, and interactive rebase execution. Some advanced features and edge case handling are still being refined.</p>"},{"location":"user-guide/getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have:</p> <ul> <li>Installed git-autosquash</li> <li>A Git repository with some commit history</li> <li>Working directory changes or staged changes to distribute</li> </ul>"},{"location":"user-guide/getting-started/#your-first-git-autosquash-session","title":"Your First git-autosquash Session","text":""},{"location":"user-guide/getting-started/#step-1-set-up-a-test-scenario","title":"Step 1: Set Up a Test Scenario","text":"<p>Let's create a realistic scenario. We'll assume you've been working on a feature and made several changes:</p> <pre><code># Check your current status\ngit status\n</code></pre> <p>You might see something like: <pre><code>On branch feature/user-dashboard\nChanges not staged for commit:\n  modified:   src/auth/login.py\n  modified:   src/ui/components.py\n  modified:   src/utils/helpers.py\n</code></pre></p>"},{"location":"user-guide/getting-started/#step-2-run-git-autosquash","title":"Step 2: Run git-autosquash","text":"<p>Simply run the command:</p> <pre><code>git-autosquash\n</code></pre> <p>You'll see initial analysis output: <pre><code>Current branch: feature/user-dashboard\nMerge base: a1b2c3d4\nWorking tree status: staged=False, unstaged=True, clean=False\n\nAnalyzing changes and finding target commits...\nFound 7 hunks to process\nFound target commits for 5 hunks\n\nLaunching interactive approval interface...\n</code></pre></p> <p>What's Happening?</p> <ul> <li>git-autosquash analyzes your branch and finds the merge base with main/master</li> <li>It parses your changes into individual \"hunks\" (code sections)</li> <li>For each hunk, it runs git blame to find which commit last modified those lines</li> <li>It launches an interactive TUI to show you the proposed mappings</li> </ul>"},{"location":"user-guide/getting-started/#step-3-navigate-the-tui-interface","title":"Step 3: Navigate the TUI Interface","text":"<p>The TUI opens with three main sections:</p> <pre><code>\u250c\u2500 Hunk Mappings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500 Diff Viewer \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u2713 src/auth/login.py @@ -23,3 +23,4 \u2502\u2502 @@ -23,3 +23,4 @@                   \u2502\n\u2502   \u2192 abc1234 Fix validation bug     \u2502\u2502  def validate_user(username):       \u2502\n\u2502   (high confidence)                \u2502\u2502      if not username:               \u2502\n\u2502   \u25a1 Include in squash               \u2502\u2502 +        return False               \u2502\n\u2502                                    \u2502\u2502      # ... rest of function         \u2502\n\u2502 \u2713 src/ui/components.py @@ -45,2... \u2502\u2502                                     \u2502\n\u2502   \u2192 def5678 Add button styling     \u2502\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   (medium confidence)              \u2502\u2502 Progress: 0/5 approved (0%)         \u2502\n\u2502   \u25a1 Include in squash               \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"user-guide/getting-started/#step-4-review-and-approve-changes","title":"Step 4: Review and Approve Changes","text":"<p>For each hunk mapping:</p> <ol> <li>Review the target commit: Check if the mapping makes sense</li> <li>Examine the diff: The right panel shows exactly what will be changed</li> <li>Check confidence level: </li> <li>High: Strong evidence this change belongs in the target commit</li> <li>Medium: Likely correct but review carefully</li> <li> <p>Low: Uncertain mapping, consider carefully</p> </li> <li> <p>Approve or reject: Check the box to approve squashing this hunk</p> </li> </ol>"},{"location":"user-guide/getting-started/#keyboard-navigation","title":"Keyboard Navigation","text":"<ul> <li>\u2191/\u2193 or j/k: Navigate between hunk mappings</li> <li>Space: Toggle approval checkbox for selected hunk</li> <li>Enter: Approve all hunks and continue</li> <li>a: Toggle all hunks at once</li> <li>Escape: Cancel the operation</li> </ul>"},{"location":"user-guide/getting-started/#step-5-execute-the-squash","title":"Step 5: Execute the Squash","text":"<p>After approving the changes you want, press Enter to execute:</p> <pre><code>User approved 3 hunks for squashing\n\nExecuting interactive rebase...\nDistributing 3 hunks to their target commits:\n  1 hunk \u2192 abc1234 Fix validation bug (7 minutes ago)\n  2 hunks \u2192 def5678 Add button styling (2 hours ago)\n\nStarting rebase operation...\n\u2713 Squash operation completed successfully!\nYour changes have been distributed to their target commits.\n</code></pre>"},{"location":"user-guide/getting-started/#step-6-verify-the-results","title":"Step 6: Verify the Results","text":"<p>Check your git history to see the changes:</p> <pre><code># View the updated commits\ngit log --oneline -10\n\n# Check specific commit changes\ngit show abc1234\ngit show def5678\n</code></pre> <p>You'll see that your changes have been incorporated into the appropriate historical commits!</p>"},{"location":"user-guide/getting-started/#understanding-the-process","title":"Understanding the Process","text":""},{"location":"user-guide/getting-started/#what-git-autosquash-does","title":"What git-autosquash Does","text":"<ol> <li>Analysis Phase:</li> <li>Parses your working directory changes into hunks</li> <li>Runs git blame on each changed line range</li> <li>Identifies the commit that last modified those lines</li> <li> <p>Filters commits to only include those on your current branch</p> </li> <li> <p>Approval Phase:</p> </li> <li>Shows you proposed hunk \u2192 commit mappings</li> <li>Lets you review diffs and approve/reject each mapping</li> <li> <p>Provides confidence levels based on blame analysis</p> </li> <li> <p>Execution Phase:</p> </li> <li>Groups approved hunks by target commit</li> <li>Executes interactive rebase to edit historical commits</li> <li>Applies patches to amend the appropriate commits</li> <li>Handles conflicts and provides guidance for resolution</li> </ol>"},{"location":"user-guide/getting-started/#confidence-levels-explained","title":"Confidence Levels Explained","text":"<ul> <li>High Confidence: All lines in the hunk were last modified by the target commit</li> <li>Medium Confidence: Most lines match the target commit, some uncertainty</li> <li>Low Confidence: Mixed blame results or newer commits involved</li> </ul> <p>Start Conservative</p> <p>On your first few uses, only approve \"high confidence\" mappings until you're comfortable with the process.</p>"},{"location":"user-guide/getting-started/#common-first-time-questions","title":"Common First-Time Questions","text":""},{"location":"user-guide/getting-started/#what-if-i-make-a-mistake","title":"\"What if I make a mistake?\"","text":"<p>git-autosquash includes several safety features: - All changes start as unapproved (you must explicitly approve them) - You can cancel at any time with Escape - If something goes wrong, git-autosquash attempts automatic rollback - You can always use <code>git rebase --abort</code> to manually undo an in-progress rebase</p>"},{"location":"user-guide/getting-started/#what-if-there-are-conflicts","title":"\"What if there are conflicts?\"","text":"<p>When conflicts occur, git-autosquash: 1. Pauses the rebase at the conflicted commit 2. Shows you exactly which files have conflicts 3. Provides clear instructions for resolution:    <pre><code>\u26a0\ufe0f Rebase conflicts detected:\n  src/auth/login.py\n\nTo resolve conflicts:\n1. Edit the conflicted files to resolve conflicts\n2. Stage the resolved files: git add &lt;files&gt;\n3. Continue the rebase: git rebase --continue\n4. Or abort the rebase: git rebase --abort\n</code></pre></p>"},{"location":"user-guide/getting-started/#can-i-undo-the-changes","title":"\"Can I undo the changes?\"","text":"<p>If you need to undo a completed git-autosquash operation:</p> <ol> <li> <p>If you haven't pushed yet: Use <code>git reflog</code> to find the commit before git-autosquash ran, then <code>git reset --hard &lt;commit&gt;</code></p> </li> <li> <p>If you have pushed: You'll need to force push (be careful on shared branches) or create new commits that revert the changes</p> </li> </ol>"},{"location":"user-guide/getting-started/#what-files-should-i-avoid-squashing","title":"\"What files should I avoid squashing?\"","text":"<p>Be cautious with: - Files that have been heavily modified by multiple commits - Configuration files that change frequently - Files where the blame information might not represent logical ownership - Large refactoring changes that span multiple commits</p>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've completed your first git-autosquash session:</p> <ul> <li>Learn about Basic Workflow patterns</li> <li>Explore Advanced Usage options like <code>--line-by-line</code></li> <li>Check out Example Scenarios for common use cases</li> <li>Review Troubleshooting for tips on handling edge cases</li> </ul>"},{"location":"user-guide/getting-started/#quick-reference","title":"Quick Reference","text":"Action Keyboard Shortcut Navigate up/down \u2191/\u2193 or k/j Toggle approval Space Approve all and continue Enter Toggle all hunks a Cancel operation Escape Quit application q or Ctrl+C"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting","text":"<p>This guide helps you diagnose and resolve common issues when using git-autosquash.</p>"},{"location":"user-guide/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"user-guide/troubleshooting/#command-not-found","title":"Command Not Found","text":"<p>Symptoms: <pre><code>$ git-autosquash\nbash: git-autosquash: command not found\n</code></pre></p> <p>Diagnosis: <pre><code># Check if installed\nwhich git-autosquash\necho $PATH\n\n# Check pipx installation\npipx list | grep git-autosquash\n</code></pre></p> <p>Solutions: <pre><code># Reinstall with pipx\npipx install git-autosquash\n\n# Or upgrade if already installed\npipx upgrade git-autosquash\n\n# Ensure pipx bin directory in PATH\npipx ensurepath\n\n# Restart shell\nexec $SHELL\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#permission-issues","title":"Permission Issues","text":"<p>Symptoms: <pre><code>$ git-autosquash\nPermission denied\n</code></pre></p> <p>Solutions: <pre><code># Check file permissions\nls -la $(which git-autosquash)\n\n# Fix permissions if needed\nchmod +x $(which git-autosquash)\n\n# Reinstall if permissions are consistently wrong\npipx uninstall git-autosquash\npipx install git-autosquash\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#git-repository-issues","title":"Git Repository Issues","text":""},{"location":"user-guide/troubleshooting/#not-in-git-repository","title":"Not in Git Repository","text":"<p>Symptoms: <pre><code>$ git-autosquash\nError: Not in a git repository\n</code></pre></p> <p>Diagnosis: <pre><code># Verify current directory\npwd\ngit status\n</code></pre></p> <p>Solutions: <pre><code># Navigate to git repository\ncd /path/to/your/repo\n\n# Or initialize new repository if intended\ngit init\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#detached-head-state","title":"Detached HEAD State","text":"<p>Symptoms: <pre><code>$ git-autosquash\nError: Cannot operate in detached HEAD state\n</code></pre></p> <p>Diagnosis: <pre><code>git branch\n# Shows: * (HEAD detached at abc1234)\n</code></pre></p> <p>Solutions: <pre><code># Switch to a branch\ngit checkout main\n\n# Or create new branch from current state\ngit checkout -b feature/new-work\n\n# Or go back to previous branch\ngit checkout -\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#no-merge-base-found","title":"No Merge Base Found","text":"<p>Symptoms: <pre><code>$ git-autosquash\nError: Cannot find merge base with main/master\n</code></pre></p> <p>Diagnosis: <pre><code># Check branch relationships\ngit log --oneline --graph --all -10\n\n# Check remote tracking\ngit branch -vv\n</code></pre></p> <p>Solutions: <pre><code># Fetch latest from remote\ngit fetch origin\n\n# Set upstream if missing\ngit branch --set-upstream-to=origin/main\n\n# Or specify merge base manually in future\ngit merge-base HEAD origin/main\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#working-directory-issues","title":"Working Directory Issues","text":""},{"location":"user-guide/troubleshooting/#mixed-stagedunstaged-changes","title":"Mixed Staged/Unstaged Changes","text":"<p>Symptoms: TUI shows confusing prompt about mixed changes</p> <p>Understanding the prompt: <pre><code># Mixed staged and unstaged changes detected.\n# Choose an option:\n#   a) Process all changes (staged + unstaged)\n#   s) Stash unstaged changes and process only staged  \n#   q) Quit\n</code></pre></p> <p>Recommendations: - Option a: Most common, processes everything together - Option s: Use when you want to be selective about what gets rebased - Option q: Use to manually stage exactly what you want first</p> <p>Manual staging approach: <pre><code># Exit git-autosquash and stage selectively\ngit add -p  # Interactive staging\n\n# Stage specific files only\ngit add src/specific/file.py\n\n# Then run git-autosquash again\ngit-autosquash\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#uncommitted-changes-blocking-operation","title":"Uncommitted Changes Blocking Operation","text":"<p>Symptoms: <pre><code>Error: Working directory must be clean or have only staged changes\n</code></pre></p> <p>Solutions: <pre><code># Stash current changes\ngit stash push -m \"Work in progress\"\n\n# Or commit changes first\ngit commit -m \"WIP: Current progress\"\n\n# Run git-autosquash\ngit-autosquash\n\n# Restore stashed changes\ngit stash pop\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#diff-analysis-issues","title":"Diff Analysis Issues","text":""},{"location":"user-guide/troubleshooting/#no-target-commits-found","title":"No Target Commits Found","text":"<p>Symptoms: <pre><code>No suitable target commits found for any changes.\nAll changes will remain as new commits.\n</code></pre></p> <p>Common causes: 1. All changes are in new files 2. Changes are in code sections not present in branch history 3. Changes are outside the merge-base scope</p> <p>Diagnosis: <pre><code># Check what you've changed\ngit diff --stat\n\n# Check blame for specific files\ngit blame src/problematic_file.py\n\n# Check branch history\ngit log --oneline -10\n</code></pre></p> <p>Solutions: <pre><code># For new files - this is expected behavior\n# New files have no history to squash into\n\n# For existing files with no targets:\n# 1. Check if changes are in code added after branch point\ngit log --oneline origin/main..HEAD -- src/problematic_file.py\n\n# 2. Try line-by-line mode for more precision\ngit-autosquash --line-by-line\n\n# 3. Manual inspection - some changes genuinely belong as new commits\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#low-confidence-mappings","title":"Low Confidence Mappings","text":"<p>Symptoms: TUI shows many red (low confidence) mappings</p> <p>Causes: - Mixed blame results (multiple commits modified same lines) - Recent commits dominating blame analysis - Complex refactoring scenarios</p> <p>Solutions: <pre><code># Use line-by-line mode for better granularity\ngit-autosquash --line-by-line\n\n# Manually review each mapping carefully\n# Red mappings often should be rejected\n\n# For complex scenarios, consider manual organization\ngit add -p  # Stage related changes together\ngit commit -m \"Organize: specific feature\"\ngit-autosquash  # Process remaining changes\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#tui-terminal-interface-issues","title":"TUI (Terminal Interface) Issues","text":""},{"location":"user-guide/troubleshooting/#tui-not-working","title":"TUI Not Working","text":"<p>Symptoms: - Blank screen - Garbled output - Immediate exit</p> <p>Diagnosis: <pre><code># Check terminal capabilities\necho $TERM\ntput colors\n\n# Test terminal size\ntput lines\ntput cols\n</code></pre></p> <p>Solutions: <pre><code># Try with basic terminal mode\nTERM=dumb git-autosquash\n\n# Ensure adequate terminal size (minimum 80x24)\nresize\n\n# Update terminal if needed\n# For tmux users:\ntmux kill-session\ntmux new-session\n\n# For screen users:\nscreen -X quit\nscreen\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#keyboard-navigation-issues","title":"Keyboard Navigation Issues","text":"<p>Symptoms: - Arrow keys not working - Shortcuts not responding</p> <p>Solutions: <pre><code># Use alternative navigation\n# j/k instead of arrow keys\n# Space for toggle instead of Enter\n\n# Check if running in compatible terminal\necho $TERM\n# Should show: xterm-256color, screen-256color, or similar\n\n# Try different terminal emulator\n# Terminal.app, iTerm2, gnome-terminal, etc.\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#display-corruption","title":"Display Corruption","text":"<p>Symptoms: - Overlapping text - Missing content - Color issues</p> <p>Solutions: <pre><code># Force terminal reset\nreset\nclear\n\n# Disable colors\nNO_COLOR=1 git-autosquash\n\n# Try different terminal\nTERM=xterm git-autosquash\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#rebase-execution-issues","title":"Rebase Execution Issues","text":""},{"location":"user-guide/troubleshooting/#merge-conflicts-during-rebase","title":"Merge Conflicts During Rebase","text":"<p>Symptoms: <pre><code>\u26a0\ufe0f Rebase conflicts detected:\n  src/auth/login.py\n  src/ui/dashboard.py\n</code></pre></p> <p>Understanding conflicts: Conflicts occur when the same lines were modified in both the target commit and your changes.</p> <p>Resolution process: <pre><code># 1. Check conflict status\ngit status\n\n# 2. Open conflicted files\nvim src/auth/login.py\n\n# 3. Resolve conflicts (remove conflict markers)\n#    &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n#    existing code\n#    =======\n#    your changes\n#    &gt;&gt;&gt;&gt;&gt;&gt;&gt; commit-message\n\n# 4. Stage resolved files\ngit add src/auth/login.py src/ui/dashboard.py\n\n# 5. Continue rebase\ngit rebase --continue\n\n# git-autosquash will continue processing remaining commits\n</code></pre></p> <p>Abort if needed: <pre><code># If conflicts are too complex\ngit rebase --abort\n\n# Try different approach\ngit-autosquash --line-by-line\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#rebase-fails-to-complete","title":"Rebase Fails to Complete","text":"<p>Symptoms: <pre><code>error: could not apply abc1234... commit message\n</code></pre></p> <p>Diagnosis: <pre><code># Check rebase status\ngit status\n\n# Check what's happening\ncat .git/rebase-merge/msgnum\ncat .git/rebase-merge/end\n</code></pre></p> <p>Solutions: <pre><code># If rebase is stuck\ngit rebase --skip  # Skip problematic commit\n# or\ngit rebase --abort  # Start over\n\n# Clean up any partial state\ngit reset --hard HEAD\ngit clean -fd\n\n# Try git-autosquash again with different options\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#force-push-required","title":"Force Push Required","text":"<p>Symptoms: After successful git-autosquash, <code>git push</code> fails: <pre><code>! [rejected] feature-branch -&gt; feature-branch (non-fast-forward)\n</code></pre></p> <p>Understanding: git-autosquash rewrites history, so force push is required.</p> <p>Safe force push: <pre><code># Use --force-with-lease for safety\ngit push --force-with-lease origin feature-branch\n\n# This fails if remote has commits you don't have locally\n# (protects against overwriting others' work)\n</code></pre></p> <p>If force-with-lease fails: <pre><code># Fetch and check what changed\ngit fetch origin\ngit log HEAD..origin/feature-branch\n\n# If safe to proceed\ngit push --force origin feature-branch\n\n# If others have pushed commits, coordinate with team first\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"user-guide/troubleshooting/#slow-blame-analysis","title":"Slow Blame Analysis","text":"<p>Symptoms: git-autosquash hangs or runs very slowly</p> <p>Causes: - Large repository history - Many files changed - Large individual files</p> <p>Solutions: <pre><code># Check repository size\ndu -sh .git/\ngit count-objects -vH\n\n# Optimize git repository\ngit gc --aggressive\ngit prune\n\n# Process changes in smaller batches\ngit stash push -m \"Batch 2\" -- src/large_module/\ngit-autosquash  # Process remaining\ngit stash pop\ngit-autosquash  # Process batch 2\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#memory-issues","title":"Memory Issues","text":"<p>Symptoms: <pre><code>MemoryError: Unable to allocate array\n# or system becomes unresponsive\n</code></pre></p> <p>Solutions: <pre><code># Monitor memory usage\n/usr/bin/time -v git-autosquash\n\n# Process fewer files at once\ngit add src/specific_module/\ngit-autosquash\n# Process only staged changes\n\n# Increase system swap if needed\nsudo swapon --show\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#tui-performance-issues","title":"TUI Performance Issues","text":"<p>Symptoms: - Slow scrolling - Laggy keyboard response - High CPU usage</p> <p>Solutions: <pre><code># Reduce terminal complexity\nTERM=xterm git-autosquash\n\n# Use smaller terminal window\n# Reduce number of visible items\n\n# Try fallback text mode\n# (git-autosquash automatically falls back if TUI fails)\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#error-messages-and-solutions","title":"Error Messages and Solutions","text":""},{"location":"user-guide/troubleshooting/#fatal-ambiguous-argument","title":"\"fatal: ambiguous argument\"","text":"<p>Full error: <pre><code>fatal: ambiguous argument 'HEAD~1': unknown revision or path not found.\n</code></pre></p> <p>Cause: Branch has only one commit</p> <p>Solutions: <pre><code># Check commit count\ngit rev-list --count HEAD\n\n# If only one commit, nothing to squash into\n# This is expected behavior\n\n# Add more commits to have squash targets\ngit commit -m \"Add more functionality\"\n# Then git-autosquash will have targets\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#error-pathspec-did-not-match-any-files","title":"\"error: pathspec did not match any file(s)\"","text":"<p>Cause: File was renamed or deleted</p> <p>Solutions: <pre><code># Check git status\ngit status --porcelain\n\n# Handle renames properly\ngit add -A  # Stage all changes including renames\ngit-autosquash\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#fatal-refusing-to-merge-unrelated-histories","title":"\"fatal: refusing to merge unrelated histories\"","text":"<p>Cause: Branch history is disconnected from main</p> <p>Solutions: <pre><code># Check branch relationships\ngit log --oneline --graph --all -20\n\n# If branches are truly unrelated, this is expected\n# git-autosquash requires shared history\n\n# To force relationship (dangerous):\ngit rebase --root --onto main\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#recovery-procedures","title":"Recovery Procedures","text":""},{"location":"user-guide/troubleshooting/#recovering-from-failed-git-autosquash","title":"Recovering from Failed git-autosquash","text":"<p>If git-autosquash leaves repository in unexpected state:</p> <pre><code># 1. Check reflog for previous state\ngit reflog -10\n\n# 2. Reset to previous good state\ngit reset --hard HEAD@{N}  # Replace N with appropriate number\n\n# 3. Verify state\ngit status\ngit log --oneline -5\n\n# 4. Try alternative approach\ngit-autosquash --line-by-line  # More conservative\n</code></pre>"},{"location":"user-guide/troubleshooting/#emergency-abort","title":"Emergency Abort","text":"<p>If git-autosquash seems stuck or unresponsive:</p> <pre><code># 1. Kill process (Ctrl+C in terminal)\n\n# 2. Check for ongoing rebase\ngit status\n\n# 3. Abort any ongoing rebase\ngit rebase --abort\n\n# 4. Clean working directory\ngit reset --hard HEAD\ngit clean -fd\n\n# 5. Check repository state\ngit status\ngit log --oneline -5\n</code></pre>"},{"location":"user-guide/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"user-guide/troubleshooting/#diagnostic-information","title":"Diagnostic Information","text":"<p>When reporting issues, include:</p> <pre><code># Version information\ngit-autosquash --version\ngit --version\npython --version\n\n# System information\nuname -a\necho $TERM\n\n# Repository state\ngit status --porcelain\ngit log --oneline -10\ngit diff --stat\n\n# Error output\ngit-autosquash 2&gt;&amp;1 | tee error.log\n</code></pre>"},{"location":"user-guide/troubleshooting/#debug-mode","title":"Debug Mode","text":"<p>Enable verbose output for troubleshooting:</p> <pre><code># Git operation tracing\nGIT_TRACE=1 git-autosquash\n\n# More detailed git tracing\nGIT_TRACE=2 GIT_TRACE_SETUP=1 git-autosquash\n\n# Python traceback for errors\npython -X dev -c \"import subprocess; subprocess.run(['git-autosquash'])\"\n</code></pre> <p>For issues not covered here, please report them at https://github.com/andrewleech/git-autosquash/issues with diagnostic information included.</p>"}]}